diff --git a/sympy/sets/sets.py b/sympy/sets/sets.py
index 3c4aa86e36..e76887723c 100644
--- a/sympy/sets/sets.py
+++ b/sympy/sets/sets.py
@@ -865,6 +865,25 @@ def __len__(self):
     def __bool__(self):
         return all([bool(s) for s in self.sets])
 
+    def _eval_is_subset(self, other):
+        """
+        Returns True if this ProductSet is a subset of other.
+        
+        A ProductSet is a subset of another set if all elements 
+        in the Cartesian product are contained in the other set.
+        """
+        if not isinstance(other, Set):
+            return None
+            
+        # If this ProductSet is finite and iterable, check each element
+        if self.is_finite_set and self.is_iterable:
+            # Convert Python tuples to SymPy Tuples for _contains
+            from sympy.core.containers import Tuple
+            return fuzzy_and(other._contains(Tuple(*element)) for element in self)
+        
+        # For infinite or non-iterable ProductSets, we can't easily check
+        return None
+
 
 class Interval(Set, EvalfMixin):
     """
@@ -1614,6 +1633,31 @@ def __iter__(self):
             else:
                 continue
 
+    def equals(self, other):
+        """
+        Returns True if this Complement is equal to other.
+        """
+        if not isinstance(other, Set):
+            return False
+        
+        # Two complements are equal if they have the same elements
+        # This is a basic implementation - could be made more sophisticated
+        if isinstance(other, Complement):
+            # Check if both arguments have equals method, otherwise use ==
+            try:
+                arg0_equal = self.args[0].equals(other.args[0]) if hasattr(self.args[0], 'equals') else self.args[0] == other.args[0]
+                arg1_equal = self.args[1].equals(other.args[1]) if hasattr(self.args[1], 'equals') else self.args[1] == other.args[1]
+                return arg0_equal and arg1_equal
+            except (AttributeError, NotImplementedError):
+                return self.args[0] == other.args[0] and self.args[1] == other.args[1]
+        
+        # For other types of sets, fall back to checking if they're the same
+        # by checking if each is a subset of the other
+        try:
+            return self.is_subset(other) and other.is_subset(self)
+        except (AttributeError, NotImplementedError):
+            return False
+
 
 class EmptySet(Set, metaclass=Singleton):
     """
@@ -1679,6 +1723,15 @@ def _complement(self, other):
     def _symmetric_difference(self, other):
         return other
 
+    def equals(self, other):
+        """
+        Returns True if other is also an empty set.
+        """
+        try:
+            return other.is_empty
+        except AttributeError:
+            return False
+
 
 class UniversalSet(Set, metaclass=Singleton):
     """
