diff --git a/sympy/physics/quantum/tensorproduct.py b/sympy/physics/quantum/tensorproduct.py
index 9dd10d219e..aab66beadd 100644
--- a/sympy/physics/quantum/tensorproduct.py
+++ b/sympy/physics/quantum/tensorproduct.py
@@ -145,10 +145,19 @@ def _eval_adjoint(self):
 
     def _eval_rewrite(self, pattern, rule, **hints):
         sargs = self.args
         terms = [t._eval_rewrite(pattern, rule, **hints) for t in sargs]
         return TensorProduct(*terms).expand(tensorproduct=True)
+        
+    def _eval_power(self, exp):
+        """Evaluate powers of tensor products.
+        
+        For integer powers, distribute the power to each element of the tensor product.
+        """
+        if exp.is_Integer and exp.is_positive:
+            return TensorProduct(*[arg ** exp for arg in self.args])
+        return None
 
     def _sympystr(self, printer, *args):
         from sympy.printing.str import sstr
         length = len(self.args)
         s = ''
@@ -237,11 +246,11 @@ def _label_wrap(label, nlabels):
 
     def doit(self, **hints):
         return TensorProduct(*[item.doit(**hints) for item in self.args])
 
     def _eval_expand_tensorproduct(self, **hints):
-        """Distribute TensorProducts across addition."""
+        """Distribute TensorProducts across addition and powers."""
         args = self.args
         add_args = []
         stop = False
         for i in range(len(args)):
             if isinstance(args[i], Add):
@@ -249,10 +258,15 @@ def _eval_expand_tensorproduct(self, **hints):
                     tp = TensorProduct(*args[:i] + (aa,) + args[i + 1:])
                     if isinstance(tp, TensorProduct):
                         tp = tp._eval_expand_tensorproduct()
                     add_args.append(tp)
                 break
+            elif isinstance(args[i], Pow) and args[i].exp.is_Integer and args[i].exp.is_positive:
+                # Distribute powers inside TensorProduct
+                new_args = list(args)
+                new_args[i] = args[i].base ** args[i].exp
+                return TensorProduct(*new_args)
 
         if add_args:
             return Add(*add_args)
         else:
             return self
@@ -376,15 +390,25 @@ def tensor_product_simp(e, **hints):
     commutators and anticommutators as well:
 
     >>> tensor_product_simp(e**2)
     (A*C)x(B*D)**2
 
+    It also works with powers of TensorProducts:
+
+    >>> tp = TensorProduct(A, B)
+    >>> tensor_product_simp(tp**2)
+    (A**2)x(B**2)
+
     """
     if isinstance(e, Add):
         return Add(*[tensor_product_simp(arg) for arg in e.args])
     elif isinstance(e, Pow):
-        return tensor_product_simp(e.base) ** e.exp
+        base = tensor_product_simp(e.base)
+        if isinstance(base, TensorProduct) and e.exp.is_Integer and e.exp.is_positive:
+            # For positive integer powers of TensorProduct, distribute the power to each element
+            return TensorProduct(*[arg ** e.exp for arg in base.args])
+        return base ** e.exp
     elif isinstance(e, Mul):
         return tensor_product_simp_Mul(e)
     elif isinstance(e, Commutator):
         return Commutator(*[tensor_product_simp(arg) for arg in e.args])
     elif isinstance(e, AntiCommutator):
