diff --git a/xarray/core/computation.py b/xarray/core/computation.py
index 823cbe02..5a1428a1 100644
--- a/xarray/core/computation.py
+++ b/xarray/core/computation.py
@@ -1905,6 +1905,14 @@ def polyval(
     coeffs = coeffs.reindex(
         {degree_dim: np.arange(max_deg + 1)}, fill_value=0, copy=False
     )
+    
+    # Special handling for DataArray: if the DataArray's name matches one of its coordinates,
+    # use the coordinate values instead of the data values for polynomial evaluation
+    from .dataarray import DataArray
+    if isinstance(coord, DataArray) and coord.name in coord.coords:
+        # Use the coordinate values instead of the data values
+        coord = coord.coords[coord.name]
+    
     coord = _ensure_numeric(coord)  # type: ignore # https://github.com/python/mypy/issues/1533 ?
 
     # using Horner's method
@@ -1933,7 +1941,7 @@ def _ensure_numeric(data: T_Xarray) -> T_Xarray:
     from .dataset import Dataset
 
     def to_floatable(x: DataArray) -> DataArray:
-        if x.dtype.kind in "mM":
+        if x.dtype.kind == "M":  # datetime64
             return x.copy(
                 data=datetime_to_numeric(
                     x.data,
@@ -1941,6 +1949,13 @@ def _ensure_numeric(data: T_Xarray) -> T_Xarray:
                     datetime_unit="ns",
                 ),
             )
+        elif x.dtype.kind == "m":  # timedelta64
+            return x.copy(
+                data=datetime_to_numeric(
+                    x.data,
+                    datetime_unit="s",  # Convert to seconds for reasonable scale
+                ),
+            )
         return x
 
     if isinstance(data, Dataset):
diff --git a/xarray/tests/test_computation.py b/xarray/tests/test_computation.py
index 737ed82b..832a7d11 100644
--- a/xarray/tests/test_computation.py
+++ b/xarray/tests/test_computation.py
@@ -2010,6 +2010,14 @@ def test_where_attrs() -> None:
             ),
             id="datetime",
         ),
+        pytest.param(
+            xr.DataArray(
+                np.array([0, 10, 20, 30], dtype="timedelta64[s]"), dims="x"
+            ),
+            xr.DataArray([1, 1], dims="degree", coords={"degree": [0, 1]}),
+            xr.DataArray([1, 11, 21, 31], dims="x"),
+            id="timedelta",
+        ),
     ],
 )
 def test_polyval(
@@ -2037,6 +2045,44 @@ def test_polyval_degree_dim_checks():
         xr.polyval(x, coeffs.assign_coords(degree=coeffs.degree.astype(float)))
 
 
+def test_polyval_coordinate_name_matching():
+    """Test that polyval uses coordinate values when DataArray name matches coordinate name.
+    
+    This is a regression test for GitHub issue where polyval with timedelta64 coordinates
+    produced wrong results because it was using datetime64 data values instead of 
+    timedelta64 coordinate values.
+    """
+    # Create datetime64 values
+    datetime_values = np.array([
+        "2021-04-01T05:25:19.000000000",
+        "2021-04-01T05:25:29.000000000",
+        "2021-04-01T05:25:39.000000000",
+    ], dtype="datetime64[ns]")
+    
+    # Create DataArray with datetime64 data but timedelta64 coordinate with same name
+    azimuth_time = xr.DataArray(
+        datetime_values, 
+        name="azimuth_time", 
+        coords={"azimuth_time": datetime_values - datetime_values[0]}
+    )
+    
+    # Simple polynomial: f(x) = x + 1 (where x is in seconds)
+    coeffs = xr.DataArray([1, 1], dims="degree", coords={"degree": [0, 1]})
+    
+    # polyval should use the coordinate values (timedelta64 converted to seconds: [0, 10, 20])
+    # not the data values (datetime64 which would be huge numbers)
+    result = xr.polyval(azimuth_time, coeffs)
+    
+    # Expected: [1, 11, 21] (since coordinate values are [0, 10, 20] seconds)
+    expected_values = np.array([1, 11, 21])
+    
+    # Check that results are reasonable (not astronomically large)
+    assert np.all(np.abs(result.values) < 1e6), "polyval should not produce astronomically large values"
+    
+    # Check that the result matches expected polynomial evaluation
+    np.testing.assert_allclose(result.values, expected_values, rtol=1e-10)
+
+
 @pytest.mark.parametrize("use_dask", [False, True])
 @pytest.mark.parametrize(
     "a, b, ae, be, dim, axis",
