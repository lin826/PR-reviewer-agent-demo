diff --git a/sympy/polys/monomials.py b/sympy/polys/monomials.py
index 0e84403307..43e7c4c757 100644
--- a/sympy/polys/monomials.py
+++ b/sympy/polys/monomials.py
@@ -127,7 +127,8 @@ def itermonomials(variables, max_degrees, min_degrees=None):
                 for variable in item:
                     if variable != 1:
                         powers[variable] += 1
-                if max(powers.values()) >= min_degree:
+                total_deg = sum(count for var, count in powers.items() if var != S.One)
+                if min_degree <= total_deg <= max_degree:
                     monomials_list_comm.append(Mul(*item))
             yield from set(monomials_list_comm)
         else:
@@ -139,7 +140,8 @@ def itermonomials(variables, max_degrees, min_degrees=None):
                 for variable in item:
                     if variable != 1:
                         powers[variable] += 1
-                if max(powers.values()) >= min_degree:
+                total_deg = sum(count for var, count in powers.items() if var != S.One)
+                if min_degree <= total_deg <= max_degree:
                     monomials_list_non_comm.append(Mul(*item))
             yield from set(monomials_list_non_comm)
     else:
diff --git a/sympy/polys/tests/test_monomials.py b/sympy/polys/tests/test_monomials.py
index 482cbee30d..0714ee768e 100644
--- a/sympy/polys/tests/test_monomials.py
+++ b/sympy/polys/tests/test_monomials.py
@@ -162,6 +162,41 @@ def test_monomials():
                     x*j**2, x*k**2, x*j*k, x**2*j**2*k**2, x*j*k**2, x**2, x**2*j*k**2
             }
 
+def test_itermonomials_min_degrees_total_degree():
+    """Test itermonomials with min_degrees in total degree mode.
+    
+    This test ensures that when min_degrees is specified in total degree mode,
+    all monomials with total degree between min_degrees and max_degrees are
+    generated, including mixed terms, not just pure powers.
+    
+    This addresses the bug where only monomials with max individual degree >= min_degree
+    were generated instead of all monomials with total degree >= min_degree.
+    """
+    # Test exact degree (min_degrees = max_degrees)
+    assert set(itermonomials([x, y], 2, min_degrees=2)) == {x**2, x*y, y**2}
+    assert set(itermonomials([x, y, z], 3, min_degrees=3)) == {
+        x**3, y**3, z**3,  # pure powers
+        x**2*y, x**2*z, y**2*x, y**2*z, z**2*x, z**2*y,  # mixed degree 3
+        x*y*z  # all variables degree 1
+    }
+    
+    # Test degree range
+    assert set(itermonomials([x, y], 2, min_degrees=1)) == {x, y, x**2, x*y, y**2}
+    assert set(itermonomials([x, y, z], 3, min_degrees=2)) == {
+        x**2, y**2, z**2, x*y, x*z, y*z,  # degree 2
+        x**3, y**3, z**3, x**2*y, x**2*z, y**2*x, y**2*z, z**2*x, z**2*y, x*y*z  # degree 3
+    }
+    
+    # Test single variable
+    assert set(itermonomials([x], 3, min_degrees=2)) == {x**2, x**3}
+    
+    # Test edge case with min_degrees = 0
+    assert set(itermonomials([x, y], 1, min_degrees=0)) == {S.One, x, y}
+    
+    # Test non-commutative variables
+    i, j = symbols('i j', commutative=False)
+    assert set(itermonomials([i, j], 2, min_degrees=2)) == {i**2, i*j, j*i, j**2}
+
 def test_monomial_count():
     assert monomial_count(2, 2) == 6
     assert monomial_count(2, 3) == 10
