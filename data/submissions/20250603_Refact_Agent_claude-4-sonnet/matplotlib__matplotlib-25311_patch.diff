diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py
index 1dee8a23d9..26cdc90917 100644
--- a/lib/matplotlib/offsetbox.py
+++ b/lib/matplotlib/offsetbox.py
@@ -1516,6 +1516,7 @@ class DraggableBase:
 
     def on_motion(self, evt):
         if self._check_still_parented() and self.got_artist:
+            self._ensure_canvas_connection()
             dx = evt.x - self.mouse_x
             dy = evt.y - self.mouse_y
             self.update_offset(dx, dy)
@@ -1529,6 +1530,7 @@ class DraggableBase:
 
     def on_pick(self, evt):
         if self._check_still_parented() and evt.artist == self.ref_artist:
+            self._ensure_canvas_connection()
             self.mouse_x = evt.mouseevent.x
             self.mouse_y = evt.mouseevent.y
             self.got_artist = True
@@ -1546,9 +1548,11 @@ class DraggableBase:
 
     def on_release(self, event):
         if self._check_still_parented() and self.got_artist:
+            self._ensure_canvas_connection()
             self.finalize_offset()
             self.got_artist = False
-            self.canvas.mpl_disconnect(self._c1)
+            if hasattr(self, '_c1'):
+                self.canvas.mpl_disconnect(self._c1)
 
             if self._use_blit:
                 self.ref_artist.set_animated(False)
@@ -1562,14 +1566,16 @@ class DraggableBase:
 
     def disconnect(self):
         """Disconnect the callbacks."""
-        for cid in self.cids:
-            self.canvas.mpl_disconnect(cid)
-        try:
-            c1 = self._c1
-        except AttributeError:
-            pass
-        else:
-            self.canvas.mpl_disconnect(c1)
+        self._ensure_canvas_connection()
+        if self.canvas is not None:
+            for cid in self.cids:
+                self.canvas.mpl_disconnect(cid)
+            try:
+                c1 = self._c1
+            except AttributeError:
+                pass
+            else:
+                self.canvas.mpl_disconnect(c1)
 
     def save_offset(self):
         pass
@@ -1580,6 +1586,63 @@ class DraggableBase:
     def finalize_offset(self):
         pass
 
+    def __getstate__(self):
+        """
+        Return the state for pickling.
+        
+        We exclude the canvas reference since it may not be picklable
+        (e.g., Qt canvases). The canvas will be restored from the 
+        ref_artist.figure.canvas when unpickling.
+        """
+        state = self.__dict__.copy()
+        # Remove the unpicklable canvas reference
+        state.pop('canvas', None)
+        # Also remove any active motion callback connection
+        state.pop('_c1', None)
+        # Reset dragging state
+        state['got_artist'] = False
+        return state
+
+    def __setstate__(self, state):
+        """
+        Restore the state from pickling.
+        
+        Reconnect to the canvas and restore callbacks.
+        """
+        self.__dict__.update(state)
+        # Initialize with safe defaults
+        self.canvas = None
+        self._use_blit = False
+        self.cids = []
+        
+        # We'll restore the canvas connection lazily when needed
+        # This avoids issues with the figure not being fully restored yet
+
+    def _ensure_canvas_connection(self):
+        """
+        Ensure that the canvas connection is established.
+        
+        This is called lazily to handle cases where the figure
+        might not be fully restored during unpickling.
+        """
+        if (self.canvas is None and 
+            hasattr(self, 'ref_artist') and 
+            self.ref_artist is not None and
+            hasattr(self.ref_artist, 'figure') and
+            self.ref_artist.figure is not None and
+            hasattr(self.ref_artist.figure, 'canvas') and
+            self.ref_artist.figure.canvas is not None):
+            
+            self.canvas = self.ref_artist.figure.canvas
+            self._use_blit = getattr(self, '_use_blit', False) and self.canvas.supports_blit
+            # Reconnect the callbacks
+            self.cids = [
+                self.canvas.callbacks._connect_picklable(
+                    'pick_event', self.on_pick),
+                self.canvas.callbacks._connect_picklable(
+                    'button_release_event', self.on_release),
+            ]
+
 
 class DraggableOffsetBox(DraggableBase):
     def __init__(self, ref_artist, offsetbox, use_blit=False):
