diff --git a/django/forms/models.py b/django/forms/models.py
index 5edbbd376f..9caaf837b3 100644
--- a/django/forms/models.py
+++ b/django/forms/models.py
@@ -50,7 +50,40 @@ def construct_instance(form, instance, fields=None, exclude=None):
         # checkbox inputs because they don't appear in POST data if not checked.
         if (f.has_default() and
                 form[f.name].field.widget.value_omitted_from_data(form.data, form.files, form.add_prefix(f.name))):
-            continue
+            # The field was omitted from the original form data, but it's in cleaned_data.
+            # We need to determine if the cleaned_data value was explicitly set
+            # (e.g., in clean() method) or if it's just the form field's default/initial value.
+            
+            field_value = cleaned_data[f.name]
+            form_field = form[f.name].field
+            
+            # Get what the form field would provide as its initial value
+            field_initial = form.get_initial_for_field(form_field, f.name)
+            
+            # For fields that were omitted from form data, we should only use the
+            # cleaned_data value if it was explicitly modified from the form field's
+            # initial value. This allows clean() methods to override defaults while
+            # preserving model defaults for truly unmodified fields.
+            
+            # Special handling for different field types:
+            if hasattr(form_field, 'empty_value'):
+                # For fields with an explicit empty_value (like CharField with empty_value='')
+                form_empty_value = form_field.empty_value
+            else:
+                # For other fields, assume None is the empty value
+                form_empty_value = None
+            
+            # If the cleaned_data value is the form field's empty value and no initial
+            # was provided, this means the field was not explicitly set in clean()
+            if field_value == form_empty_value and field_initial is None:
+                continue  # Use model default
+            
+            # If the cleaned_data value differs from the form's initial value,
+            # it was explicitly set (e.g., in clean()), so use it
+            if field_value != field_initial:
+                pass  # Use cleaned_data value
+            else:
+                continue  # Use model default
         # Defer saving file-type fields until after the other fields, so a
         # callable upload_to can use the values from other fields.
         if isinstance(f, models.FileField):
diff --git a/tests/model_forms/tests.py b/tests/model_forms/tests.py
index 3893eb334c..47cd1a0ccb 100644
--- a/tests/model_forms/tests.py
+++ b/tests/model_forms/tests.py
@@ -2916,3 +2916,52 @@ class ModelToDictTests(TestCase):
         # If data were a QuerySet, it would be reevaluated here and give "red"
         # instead of the original value.
         self.assertEqual(data, [blue])
+
+    def test_cleaned_data_overrides_default_when_computed_in_clean(self):
+        """
+        Test that a field with a default value can be overridden by cleaned_data
+        even when the field was not in the original form data.
+        
+        This addresses the issue where fields with defaults that are not in the
+        original form data but are set in cleaned_data (e.g., computed in clean())
+        should use the cleaned_data value instead of the default.
+        """
+        class TestForm(forms.ModelForm):
+            class Meta:
+                model = PublicationDefaults
+                fields = ['title', 'mode']
+            
+            def __init__(self, *args, **kwargs):
+                super().__init__(*args, **kwargs)
+                self.fields['mode'].widget = forms.HiddenInput()
+                self.fields['mode'].required = False
+            
+            def clean(self):
+                cleaned_data = super().clean()
+                # Set mode based on title (simulating computed field)
+                if cleaned_data.get('title') == 'urgent':
+                    cleaned_data['mode'] = 'de'  # delayed mode for urgent items
+                else:
+                    cleaned_data['mode'] = 'di'  # direct mode for normal items
+                return cleaned_data
+        
+        # Form data doesn't include 'mode'
+        form_data = {'title': 'urgent'}
+        form = TestForm(data=form_data)
+        
+        self.assertTrue(form.is_valid())
+        self.assertEqual(form.cleaned_data['mode'], 'de')
+        
+        # Save the form and check that the computed value is used
+        instance = form.save(commit=False)
+        self.assertEqual(instance.mode, 'de')  # Should be 'de', not 'di' (the default)
+        
+        # Test with non-urgent title
+        form_data = {'title': 'normal_task'}
+        form = TestForm(data=form_data)
+        
+        self.assertTrue(form.is_valid())
+        self.assertEqual(form.cleaned_data['mode'], 'di')
+        
+        instance = form.save(commit=False)
+        self.assertEqual(instance.mode, 'di')  # Should be 'di' (computed, same as default)
