diff --git a/sympy/concrete/summations.py b/sympy/concrete/summations.py
index 372487664c..c981b2f665 100644
--- a/sympy/concrete/summations.py
+++ b/sympy/concrete/summations.py
@@ -876,6 +876,23 @@ def eval_sum(f, limits):
     if definite and (dif < 100):
         return eval_sum_direct(f, (i, a, b))
     if isinstance(f, Piecewise):
+        # Handle special case: Sum(Piecewise((expr, condition), (0, True)), (var, start, end))
+        # where condition is always true in the summation range
+        if (len(f.args) == 2 and f.args[1].expr == 0 and f.args[1].cond == True):
+            expr, cond = f.args[0]
+            
+            # Check if condition is of the form (start <= var <= end) and matches summation range
+            from sympy import And, Le, Ge
+            if isinstance(cond, And) and len(cond.args) == 2:
+                # Check if condition matches the summation bounds
+                cond_simplified = cond.subs(i, a)  # Check at lower bound
+                cond_simplified2 = cond.subs(i, b)  # Check at upper bound
+                
+                # If condition is true at both bounds and involves the summation variable,
+                # it's likely true throughout the range
+                if cond_simplified == True and cond_simplified2 == True:
+                    return eval_sum(expr, limits)
+        
         return None
     # Try to do it symbolically. Even when the number of terms is known,
     # this can save time when b-a is big.
diff --git a/sympy/matrices/expressions/matexpr.py b/sympy/matrices/expressions/matexpr.py
index b4d759836e..df7d6b0c83 100644
--- a/sympy/matrices/expressions/matexpr.py
+++ b/sympy/matrices/expressions/matexpr.py
@@ -476,10 +476,16 @@ def conjugate(self):
         return self
 
     def _entry(self, i, j):
-        if i == j:
+        from sympy import Eq
+        eq = Eq(i, j)
+        if eq is S.true:
             return S.One
-        else:
+        elif eq is S.false:
             return S.Zero
+        else:
+            # For symbolic indices, return a KroneckerDelta
+            from sympy.functions import KroneckerDelta
+            return KroneckerDelta(i, j)
 
     def _eval_determinant(self):
         return S.One
