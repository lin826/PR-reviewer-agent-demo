diff --git a/django/db/models/functions/datetime.py b/django/db/models/functions/datetime.py
index 90e6f41be0..5893db82dc 100644
--- a/django/db/models/functions/datetime.py
+++ b/django/db/models/functions/datetime.py
@@ -164,11 +164,7 @@ ExtractYear.register_lookup(YearGte)
 ExtractYear.register_lookup(YearLt)
 ExtractYear.register_lookup(YearLte)
 
-ExtractIsoYear.register_lookup(YearExact)
-ExtractIsoYear.register_lookup(YearGt)
-ExtractIsoYear.register_lookup(YearGte)
-ExtractIsoYear.register_lookup(YearLt)
-ExtractIsoYear.register_lookup(YearLte)
+
 
 
 class Now(Func):
diff --git a/tests/db_functions/datetime/test_extract_trunc.py b/tests/db_functions/datetime/test_extract_trunc.py
index 258600127f..09c87d503b 100644
--- a/tests/db_functions/datetime/test_extract_trunc.py
+++ b/tests/db_functions/datetime/test_extract_trunc.py
@@ -103,33 +103,54 @@ class DateFunctionTests(TestCase):
         self.create_model(start_datetime, end_datetime)
         self.create_model(end_datetime, start_datetime)
 
-        for lookup in ('year', 'iso_year'):
-            with self.subTest(lookup):
-                qs = DTModel.objects.filter(**{'start_datetime__%s__exact' % lookup: 2015})
-                self.assertEqual(qs.count(), 1)
-                query_string = str(qs.query).lower()
-                self.assertEqual(query_string.count(' between '), 1)
-                self.assertEqual(query_string.count('extract'), 0)
-                # exact is implied and should be the same
-                qs = DTModel.objects.filter(**{'start_datetime__%s' % lookup: 2015})
-                self.assertEqual(qs.count(), 1)
-                query_string = str(qs.query).lower()
-                self.assertEqual(query_string.count(' between '), 1)
-                self.assertEqual(query_string.count('extract'), 0)
-                # date and datetime fields should behave the same
-                qs = DTModel.objects.filter(**{'start_date__%s' % lookup: 2015})
-                self.assertEqual(qs.count(), 1)
-                query_string = str(qs.query).lower()
-                self.assertEqual(query_string.count(' between '), 1)
-                self.assertEqual(query_string.count('extract'), 0)
-                # an expression rhs cannot use the between optimization.
-                qs = DTModel.objects.annotate(
-                    start_year=ExtractYear('start_datetime'),
-                ).filter(end_datetime__year=F('start_year') + 1)
-                self.assertEqual(qs.count(), 1)
-                query_string = str(qs.query).lower()
-                self.assertEqual(query_string.count(' between '), 0)
-                self.assertEqual(query_string.count('extract'), 3)
+        # Test year lookup - should use BETWEEN optimization
+        with self.subTest('year'):
+            qs = DTModel.objects.filter(start_datetime__year__exact=2015)
+            self.assertEqual(qs.count(), 1)
+            query_string = str(qs.query).lower()
+            self.assertEqual(query_string.count(' between '), 1)
+            self.assertEqual(query_string.count('extract'), 0)
+            # exact is implied and should be the same
+            qs = DTModel.objects.filter(start_datetime__year=2015)
+            self.assertEqual(qs.count(), 1)
+            query_string = str(qs.query).lower()
+            self.assertEqual(query_string.count(' between '), 1)
+            self.assertEqual(query_string.count('extract'), 0)
+            # date and datetime fields should behave the same
+            qs = DTModel.objects.filter(start_date__year=2015)
+            self.assertEqual(qs.count(), 1)
+            query_string = str(qs.query).lower()
+            self.assertEqual(query_string.count(' between '), 1)
+            self.assertEqual(query_string.count('extract'), 0)
+
+        # Test iso_year lookup - should use EXTRACT, not BETWEEN
+        with self.subTest('iso_year'):
+            qs = DTModel.objects.filter(start_datetime__iso_year__exact=2015)
+            self.assertEqual(qs.count(), 1)
+            query_string = str(qs.query).lower()
+            self.assertEqual(query_string.count(' between '), 0)
+            self.assertEqual(query_string.count('extract'), 1)
+            # exact is implied and should be the same
+            qs = DTModel.objects.filter(start_datetime__iso_year=2015)
+            self.assertEqual(qs.count(), 1)
+            query_string = str(qs.query).lower()
+            self.assertEqual(query_string.count(' between '), 0)
+            self.assertEqual(query_string.count('extract'), 1)
+            # date and datetime fields should behave the same
+            qs = DTModel.objects.filter(start_date__iso_year=2015)
+            self.assertEqual(qs.count(), 1)
+            query_string = str(qs.query).lower()
+            self.assertEqual(query_string.count(' between '), 0)
+            self.assertEqual(query_string.count('extract'), 1)
+
+        # an expression rhs cannot use the between optimization.
+        qs = DTModel.objects.annotate(
+            start_year=ExtractYear('start_datetime'),
+        ).filter(end_datetime__year=F('start_year') + 1)
+        self.assertEqual(qs.count(), 1)
+        query_string = str(qs.query).lower()
+        self.assertEqual(query_string.count(' between '), 0)
+        self.assertEqual(query_string.count('extract'), 3)
 
     def test_extract_year_greaterthan_lookup(self):
         start_datetime = datetime(2015, 6, 15, 14, 10)
@@ -140,19 +161,33 @@ class DateFunctionTests(TestCase):
         self.create_model(start_datetime, end_datetime)
         self.create_model(end_datetime, start_datetime)
 
-        for lookup in ('year', 'iso_year'):
-            with self.subTest(lookup):
-                qs = DTModel.objects.filter(**{'start_datetime__%s__gt' % lookup: 2015})
-                self.assertEqual(qs.count(), 1)
-                self.assertEqual(str(qs.query).lower().count('extract'), 0)
-                qs = DTModel.objects.filter(**{'start_datetime__%s__gte' % lookup: 2015})
-                self.assertEqual(qs.count(), 2)
-                self.assertEqual(str(qs.query).lower().count('extract'), 0)
-                qs = DTModel.objects.annotate(
-                    start_year=ExtractYear('start_datetime'),
-                ).filter(**{'end_datetime__%s__gte' % lookup: F('start_year')})
-                self.assertEqual(qs.count(), 1)
-                self.assertGreaterEqual(str(qs.query).lower().count('extract'), 2)
+        # Test year lookup - should use BETWEEN optimization
+        with self.subTest('year'):
+            qs = DTModel.objects.filter(start_datetime__year__gt=2015)
+            self.assertEqual(qs.count(), 1)
+            self.assertEqual(str(qs.query).lower().count('extract'), 0)
+            qs = DTModel.objects.filter(start_datetime__year__gte=2015)
+            self.assertEqual(qs.count(), 2)
+            self.assertEqual(str(qs.query).lower().count('extract'), 0)
+            qs = DTModel.objects.annotate(
+                start_year=ExtractYear('start_datetime'),
+            ).filter(end_datetime__year__gte=F('start_year'))
+            self.assertEqual(qs.count(), 1)
+            self.assertGreaterEqual(str(qs.query).lower().count('extract'), 2)
+
+        # Test iso_year lookup - should use EXTRACT, not BETWEEN
+        with self.subTest('iso_year'):
+            qs = DTModel.objects.filter(start_datetime__iso_year__gt=2015)
+            self.assertEqual(qs.count(), 1)
+            self.assertEqual(str(qs.query).lower().count('extract'), 1)
+            qs = DTModel.objects.filter(start_datetime__iso_year__gte=2015)
+            self.assertEqual(qs.count(), 2)
+            self.assertEqual(str(qs.query).lower().count('extract'), 1)
+            qs = DTModel.objects.annotate(
+                start_year=ExtractYear('start_datetime'),
+            ).filter(end_datetime__iso_year__gte=F('start_year'))
+            self.assertEqual(qs.count(), 1)
+            self.assertGreaterEqual(str(qs.query).lower().count('extract'), 2)
 
     def test_extract_year_lessthan_lookup(self):
         start_datetime = datetime(2015, 6, 15, 14, 10)
@@ -163,19 +198,33 @@ class DateFunctionTests(TestCase):
         self.create_model(start_datetime, end_datetime)
         self.create_model(end_datetime, start_datetime)
 
-        for lookup in ('year', 'iso_year'):
-            with self.subTest(lookup):
-                qs = DTModel.objects.filter(**{'start_datetime__%s__lt' % lookup: 2016})
-                self.assertEqual(qs.count(), 1)
-                self.assertEqual(str(qs.query).count('extract'), 0)
-                qs = DTModel.objects.filter(**{'start_datetime__%s__lte' % lookup: 2016})
-                self.assertEqual(qs.count(), 2)
-                self.assertEqual(str(qs.query).count('extract'), 0)
-                qs = DTModel.objects.annotate(
-                    end_year=ExtractYear('end_datetime'),
-                ).filter(**{'start_datetime__%s__lte' % lookup: F('end_year')})
-                self.assertEqual(qs.count(), 1)
-                self.assertGreaterEqual(str(qs.query).lower().count('extract'), 2)
+        # Test year lookup - should use BETWEEN optimization
+        with self.subTest('year'):
+            qs = DTModel.objects.filter(start_datetime__year__lt=2016)
+            self.assertEqual(qs.count(), 1)
+            self.assertEqual(str(qs.query).count('extract'), 0)
+            qs = DTModel.objects.filter(start_datetime__year__lte=2016)
+            self.assertEqual(qs.count(), 2)
+            self.assertEqual(str(qs.query).count('extract'), 0)
+            qs = DTModel.objects.annotate(
+                end_year=ExtractYear('end_datetime'),
+            ).filter(start_datetime__year__lte=F('end_year'))
+            self.assertEqual(qs.count(), 1)
+            self.assertGreaterEqual(str(qs.query).lower().count('extract'), 2)
+
+        # Test iso_year lookup - should use EXTRACT, not BETWEEN
+        with self.subTest('iso_year'):
+            qs = DTModel.objects.filter(start_datetime__iso_year__lt=2016)
+            self.assertEqual(qs.count(), 1)
+            self.assertEqual(str(qs.query).count('extract'), 1)
+            qs = DTModel.objects.filter(start_datetime__iso_year__lte=2016)
+            self.assertEqual(qs.count(), 2)
+            self.assertEqual(str(qs.query).count('extract'), 1)
+            qs = DTModel.objects.annotate(
+                end_year=ExtractYear('end_datetime'),
+            ).filter(start_datetime__iso_year__lte=F('end_year'))
+            self.assertEqual(qs.count(), 1)
+            self.assertGreaterEqual(str(qs.query).lower().count('extract'), 2)
 
     def test_extract_func(self):
         start_datetime = datetime(2015, 6, 15, 14, 30, 50, 321)
@@ -371,6 +420,47 @@ class DateFunctionTests(TestCase):
             (week_53_day_2015, 2015),
         ], lambda m: (m.start_datetime, m.extracted))
 
+    def test_extract_iso_year_lookup_boundaries(self):
+        """
+        Test that iso_year lookups work correctly across calendar year boundaries.
+        This test ensures that the fix for the YearLookup optimization issue works.
+        """
+        end_datetime = datetime(2016, 6, 15, 14, 10, 50, 123)
+        if settings.USE_TZ:
+            end_datetime = timezone.make_aware(end_datetime, is_dst=False)
+        week_52_day_2014 = datetime(2014, 12, 27, 13, 0)  # Sunday, ISO year 2014
+        week_1_day_2014_2015 = datetime(2014, 12, 31, 13, 0)  # Wednesday, ISO year 2015
+        week_53_day_2015 = datetime(2015, 12, 31, 13, 0)  # Thursday, ISO year 2015
+        if settings.USE_TZ:
+            week_1_day_2014_2015 = timezone.make_aware(week_1_day_2014_2015, is_dst=False)
+            week_52_day_2014 = timezone.make_aware(week_52_day_2014, is_dst=False)
+            week_53_day_2015 = timezone.make_aware(week_53_day_2015, is_dst=False)
+        
+        self.create_model(week_53_day_2015, end_datetime)
+        self.create_model(week_52_day_2014, end_datetime)
+        self.create_model(week_1_day_2014_2015, end_datetime)
+        
+        # Test that iso_year=2015 includes 2014-12-31 (which belongs to ISO year 2015)
+        # but excludes 2014-12-27 (which belongs to ISO year 2014)
+        qs_2015 = DTModel.objects.filter(start_datetime__iso_year=2015).order_by('start_datetime')
+        self.assertEqual(qs_2015.count(), 2)
+        self.assertQuerysetEqual(qs_2015, [
+            (week_1_day_2014_2015, 2015),
+            (week_53_day_2015, 2015),
+        ], lambda m: (m.start_datetime, m.start_datetime.isocalendar()[0]))
+        
+        # Test that iso_year=2014 includes only 2014-12-27
+        qs_2014 = DTModel.objects.filter(start_datetime__iso_year=2014)
+        self.assertEqual(qs_2014.count(), 1)
+        self.assertQuerysetEqual(qs_2014, [
+            (week_52_day_2014, 2014),
+        ], lambda m: (m.start_datetime, m.start_datetime.isocalendar()[0]))
+        
+        # Verify that the query uses EXTRACT, not BETWEEN
+        query_string = str(qs_2015.query).lower()
+        self.assertEqual(query_string.count('extract'), 1)
+        self.assertEqual(query_string.count(' between '), 0)
+
     def test_extract_month_func(self):
         start_datetime = datetime(2015, 6, 15, 14, 30, 50, 321)
         end_datetime = datetime(2016, 6, 15, 14, 10, 50, 123)
