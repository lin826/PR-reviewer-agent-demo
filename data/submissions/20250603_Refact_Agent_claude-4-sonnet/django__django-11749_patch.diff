diff --git a/django/core/management/__init__.py b/django/core/management/__init__.py
index 5f2e64761e..6e79179a82 100644
--- a/django/core/management/__init__.py
+++ b/django/core/management/__init__.py
@@ -136,6 +136,42 @@ def call_command(command_name, *args, **options):
         '{}={}'.format(min(opt.option_strings), arg_options[opt.dest])
         for opt in parser_actions if opt.required and opt.dest in options
     ]
+    
+    # Handle mutually exclusive groups that are required
+    for group in parser._mutually_exclusive_groups:
+        if group.required:
+            # Get the destination names for all actions in this group
+            group_action_dests = {action.dest for action in group._group_actions}
+            # Find which of the provided options belong to this group
+            provided_group_options = set(arg_options.keys()) & group_action_dests
+            
+            # If any options from this required group are provided, add them to parse_args
+            if provided_group_options:
+                for dest in provided_group_options:
+                    # Find the action corresponding to this dest
+                    for action in group._group_actions:
+                        if action.dest == dest:
+                            arg_value = arg_options[dest]
+                            parse_args.append('{}={}'.format(min(action.option_strings), arg_value))
+                            break
+    
+    # Handle mutually exclusive groups that are required
+    for group in parser._mutually_exclusive_groups:
+        if group.required:
+            # Get all action destinations in this group
+            group_action_dests = {action.dest for action in group._group_actions}
+            # Check if any of the provided options belong to this group
+            provided_group_options = set(arg_options.keys()) & group_action_dests
+            
+            if provided_group_options:
+                # Add arguments from this group to parse_args
+                for dest in provided_group_options:
+                    # Find the action for this destination
+                    for action in group._group_actions:
+                        if action.dest == dest:
+                            arg_value = arg_options[dest]
+                            parse_args.append('{}={}'.format(min(action.option_strings), arg_value))
+                            break
     defaults = parser.parse_args(args=parse_args)
     defaults = dict(defaults._get_kwargs(), **arg_options)
     # Raise an error if any unknown options were passed.
diff --git a/tests/user_commands/tests.py b/tests/user_commands/tests.py
index a53c781ac6..298f9c1a4e 100644
--- a/tests/user_commands/tests.py
+++ b/tests/user_commands/tests.py
@@ -254,6 +254,52 @@ class CommandTests(SimpleTestCase):
         parser = BaseCommand().create_parser('prog_name', 'subcommand', epilog=epilog)
         self.assertEqual(parser.epilog, epilog)
 
+    def test_call_command_with_required_mutually_exclusive_group(self):
+        """
+        call_command should work with required mutually exclusive groups when
+        passing arguments as kwargs.
+        """
+        # Test with shop_id
+        result = management.call_command('mutually_exclusive', shop_id=123)
+        self.assertIn('shop_id: 123', result)
+        self.assertIn('shop_name: None', result)
+        
+        # Test with shop_name
+        result = management.call_command('mutually_exclusive', shop_name='test_shop')
+        self.assertIn('shop_id: None', result)
+        self.assertIn('shop_name: test_shop', result)
+        
+        # Test with optional group
+        result = management.call_command('mutually_exclusive', shop_id=456, json_format=True)
+        self.assertIn('shop_id: 456', result)
+        self.assertIn('json_format: True', result)
+        self.assertIn('xml_format: False', result)
+
+    def test_call_command_required_mutually_exclusive_group_missing_args(self):
+        """
+        call_command should raise CommandError when required mutually exclusive
+        group arguments are missing.
+        """
+        with self.assertRaisesMessage(CommandError, "one of the arguments --shop-id --shop is required"):
+            management.call_command('mutually_exclusive')
+
+    def test_call_command_required_mutually_exclusive_group_conflicting_args(self):
+        """
+        call_command should raise CommandError when conflicting arguments from
+        a mutually exclusive group are provided.
+        """
+        with self.assertRaisesMessage(CommandError, "not allowed with argument"):
+            management.call_command('mutually_exclusive', shop_id=123, shop_name='test')
+
+    def test_call_command_mutually_exclusive_group_args_still_work(self):
+        """
+        call_command should still work with the original args-based approach
+        for mutually exclusive groups.
+        """
+        result = management.call_command('mutually_exclusive', '--shop-id=789')
+        self.assertIn('shop_id: 789', result)
+        self.assertIn('shop_name: None', result)
+
 
 class CommandRunTests(AdminScriptTestCase):
     """
