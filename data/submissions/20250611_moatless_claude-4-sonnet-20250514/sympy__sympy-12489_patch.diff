--- a/sympy/combinatorics/permutations.py
+++ b/sympy/combinatorics/permutations.py
@@ -857,19 +857,22 @@
         #g) (Permutation) = adjust size or return copy
         ok = True
         if not args:  # a
-            return _af_new(list(range(size or 0)))
+            return _af_new(list(range(size or 0)), cls)
         elif len(args) > 1:  # c
-            return _af_new(Cycle(*args).list(size))
+            return _af_new(Cycle(*args).list(size), cls)
         if len(args) == 1:
             a = args[0]
             if isinstance(a, Perm):  # g
                 if size is None or size == a.size:
-                    return a
-                return Perm(a.array_form, size=size)
+                    if type(a) is cls:
+                        return a
+                    else:
+                        return cls(a.array_form)
+                return cls(a.array_form, size=size)
             if isinstance(a, Cycle):  # f
-                return _af_new(a.list(size))
+                return _af_new(a.list(size), cls)
             if not is_sequence(a):  # b
-                return _af_new(list(range(a + 1)))
+                return _af_new(list(range(a + 1)), cls)
             if has_variety(is_sequence(ai) for ai in a):
                 ok = False
         else:
@@ -925,7 +928,7 @@
         return obj
 
     @staticmethod
-    def _af_new(perm):
+    def _af_new(perm, cls=None):
         """A method to produce a Permutation object from a list;
         the list is bound to the _array_form attribute, so it must
         not be modified; this method is meant for internal use only;
@@ -944,7 +947,9 @@
         Permutation([2, 1, 3, 0])
 
         """
-        p = Basic.__new__(Perm, perm)
+        if cls is None:
+            cls = Perm
+        p = Basic.__new__(cls, perm)
         p._array_form = perm
         p._size = len(perm)
         return p
@@ -1235,11 +1240,11 @@
         """
         a = _af_invert(self._array_form)
         b = other._array_form
-        return _af_new(_af_rmul(a, b))
+        return _af_new(_af_rmul(a, b), self.__class__)
 
     def __rmul__(self, other):
         """This is needed to coerse other to Permutation in rmul."""
-        return Perm(other)*self
+        return self.__class__(other)*self
 
     def __mul__(self, other):
         """
@@ -1341,7 +1346,7 @@
             raise NotImplementedError(
                 'p**p is not defined; do you mean p^p (conjugate)?')
         n = int(n)
-        return _af_new(_af_pow(self.array_form, n))
+        return _af_new(_af_pow(self.array_form, n), self.__class__)
 
     def __rxor__(self, i):
         """Return self(i) when ``i`` is an int.
@@ -1436,7 +1441,7 @@
         p = self._array_form
         for i in range(self.size):
             a[h[i]] = h[p[i]]
-        return _af_new(a)
+        return _af_new(a, self.__class__)
 
     def transpositions(self):
         """
@@ -1519,7 +1524,7 @@
         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])
         True
         """
-        return _af_new(_af_invert(self._array_form))
+        return _af_new(_af_invert(self._array_form), self.__class__)
 
     def __iter__(self):
         """Yield elements from array form.
@@ -1629,7 +1634,7 @@
                 perm[j], perm[i] = perm[i], perm[j]
                 i += 1
                 j -= 1
-        return _af_new(perm)
+        return _af_new(perm, self.__class__)
 
     @classmethod
     def unrank_nonlex(self, n, r):
@@ -1661,7 +1666,7 @@
         n = int(n)
         r = r % ifac(n)
         _unrank1(n, r, id_perm)
-        return _af_new(id_perm)
+        return _af_new(id_perm, self)
 
     def rank_nonlex(self, inv_perm=None):
         """
@@ -1724,7 +1729,7 @@
         r = self.rank_nonlex()
         if r == ifac(self.size) - 1:
             return None
-        return Perm.unrank_nonlex(self.size, r + 1)
+        return self.__class__.unrank_nonlex(self.size, r + 1)
 
     def rank(self):
         """
@@ -2125,7 +2130,7 @@
         invb = [None]*n
         for i in range(n):
             invb[b[i]] = i
-        return _af_new([a[b[inva[i]]] for i in invb])
+        return _af_new([a[b[inva[i]]] for i in invb], self.__class__)
 
     def signature(self):
         """
@@ -2423,7 +2428,7 @@
                     perm[i] = perm[i - 1]
                 perm[k] = j - 1
             r2 = r1
-        return _af_new(perm)
+        return _af_new(perm, self)
 
     def next_trotterjohnson(self):
         """
@@ -2477,7 +2482,7 @@
                     done = True
         if m == 0:
             return None
-        return _af_new(pi)
+        return _af_new(pi, self.__class__)
 
     def get_precedence_matrix(self):
         """
@@ -2707,7 +2712,7 @@
                 Q.append(Q.popleft())
             perm.append(Q.popleft())
         perm.extend(list(Q))
-        return Perm(perm)
+        return self(perm)
 
     @classmethod
     def from_inversion_vector(self, inversion):
@@ -2734,7 +2739,7 @@
         except IndexError:
             raise ValueError("The inversion vector is not valid.")
         perm.extend(N)
-        return _af_new(perm)
+        return _af_new(perm, self)
 
     @classmethod
     def random(self, n):
@@ -2753,7 +2758,7 @@
         """
         perm_array = list(range(n))
         random.shuffle(perm_array)
-        return _af_new(perm_array)
+        return _af_new(perm_array, self)
 
     @classmethod
     def unrank_lex(self, size, rank):
@@ -2787,7 +2792,7 @@
                 if perm_array[j] > d - 1:
                     perm_array[j] += 1
             psize = new_psize
-        return _af_new(perm_array)
+        return _af_new(perm_array, self)
 
     # global flag to control how permutations are printed
     # when True, Permutation([0, 2, 1, 3]) -> Cycle(1, 2)
