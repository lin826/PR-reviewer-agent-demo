diff --git a/sphinx/directives/code.py b/sphinx/directives/code.py
index 2bf31d0..826f7f8 100644
--- a/sphinx/directives/code.py
+++ b/sphinx/directives/code.py
@@ -1,6 +1,8 @@
 import sys
 import textwrap
+import re
 from difflib import unified_diff
+
 from typing import TYPE_CHECKING, Any, Dict, List, Tuple
 
 from docutils import nodes
@@ -340,20 +342,52 @@ class LiteralIncludeReader:
 
         return lines
 
+
     def prepend_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
         prepend = self.options.get('prepend')
         if prepend:
+            # Determine indentation from the first non‑blank line of the included block
+            indent = ''
+            for line in lines:
+                if line.strip():
+                    m = re.match(r'^(\s*)', line)
+                    indent = m.group(1) if m else ''
+                    break
+
+            # If the user‑supplied prepend text is not already indented,
+            # prefix the detected indentation to each logical line
+            if prepend and not prepend[0].isspace() and indent:
+                prepend = '\n'.join((indent + l) if l else l for l in prepend.splitlines())
+
+            # Insert the (possibly indented) prepend text
             lines.insert(0, prepend + '\n')
 
         return lines
 
+
+
     def append_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
         append = self.options.get('append')
         if append:
+            # Determine indentation from the last non‑blank line of the included block
+            indent = ''
+            for line in reversed(lines):
+                if line.strip():
+                    m = re.match(r'^(\s*)', line)
+                    indent = m.group(1) if m else ''
+                    break
+
+            # If the user‑supplied append text is not already indented,
+            # prefix the detected indentation to each logical line
+            if append and not append[0].isspace() and indent:
+                append = '\n'.join((indent + l) if l else l for l in append.splitlines())
+
+            # Append the (possibly indented) append text
             lines.append(append + '\n')
 
         return lines
 
+
     def dedent_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
         if 'dedent' in self.options:
             return dedent_lines(lines, self.options.get('dedent'), location=location)
