diff --git a/sympy/printing/conventions.py b/sympy/printing/conventions.py
index 9a3be6bbe9..480c9e9d2f 100644
--- a/sympy/printing/conventions.py
+++ b/sympy/printing/conventions.py
@@ -58,16 +58,26 @@ def split_super_sub(text):
         elif part.startswith("_"):
             subs.append(part[1:])
         else:
             raise RuntimeError("This should never happen.")
 
-    # make a little exception when a name ends with digits, i.e. treat them
-    # as a subscript too.
+    # Handle automatic digit-to-subscript conversion, but skip Greek letters
+    # to avoid incorrect subscript formatting (e.g., omega0 should be ω0, not ω₀)
     m = _name_with_digits_p.match(name)
     if m:
-        name, sub = m.groups()
-        subs.insert(0, sub)
+        base_name, digits = m.groups()
+        # Import here to avoid circular imports
+        try:
+            from sympy.core.alphabets import greeks
+            # Only apply automatic subscript conversion for non-Greek letters
+            if base_name.lower() not in greeks:
+                name, sub = base_name, digits
+                subs.insert(0, sub)
+        except ImportError:
+            # Fallback: apply conversion for all letters if greeks is not available
+            name, sub = base_name, digits
+            subs.insert(0, sub)
 
     return name, supers, subs
 
 
 def requires_partial(expr):
diff --git a/sympy/printing/pretty/pretty_symbology.py b/sympy/printing/pretty/pretty_symbology.py
index 3f7c4a2dc7..c441748042 100644
--- a/sympy/printing/pretty/pretty_symbology.py
+++ b/sympy/printing/pretty/pretty_symbology.py
@@ -522,10 +522,23 @@ def translate(s, bold_name) :
             gG = greek_bold_unicode.get(s)
         else:
             gG = greek_unicode.get(s)
         if gG is not None:
             return gG
+        
+        # Handle Greek letters with digits (e.g., "omega0" -> "ω0")
+        import re
+        greek_with_digits = re.match(r'^([a-zA-Z]+)([0-9]+)$', s)
+        if greek_with_digits:
+            greek_part, digit_part = greek_with_digits.groups()
+            if bold_name:
+                greek_unicode_char = greek_bold_unicode.get(greek_part.lower())
+            else:
+                greek_unicode_char = greek_unicode.get(greek_part.lower())
+            if greek_unicode_char is not None:
+                return greek_unicode_char + digit_part
+        
         for key in sorted(modifier_dict.keys(), key=lambda k:len(k), reverse=True) :
             if s.lower().endswith(key) and len(s)>len(key):
                 return modifier_dict[key](translate(s[:-len(key)], bold_name))
         if bold_name:
             return ''.join([bold_unicode[c] for c in s])
