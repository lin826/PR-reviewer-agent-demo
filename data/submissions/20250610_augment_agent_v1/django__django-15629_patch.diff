diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py
index 696bfd7742..907cfc00ea 100644
--- a/django/db/backends/base/schema.py
+++ b/django/db/backends/base/schema.py
@@ -1036,13 +1036,29 @@ class BaseDatabaseSchemaEditor:
             rels_to_update.extend(_related_non_m2m_objects(old_field, new_field))
         # Handle our type alters on the other end of rels from the PK stuff above
         for old_rel, new_rel in rels_to_update:
             rel_db_params = new_rel.field.db_parameters(connection=self.connection)
             rel_type = rel_db_params["type"]
-            fragment, other_actions = self._alter_column_type_sql(
-                new_rel.related_model, old_rel.field, new_rel.field, rel_type
-            )
+            
+            # Check if the referenced field's collation has changed and apply it to the foreign key field
+            old_target_db_params = old_rel.field.target_field.db_parameters(connection=self.connection)
+            new_target_db_params = new_rel.field.target_field.db_parameters(connection=self.connection)
+            old_target_collation = old_target_db_params.get("collation")
+            new_target_collation = new_target_db_params.get("collation")
+            
+            if old_target_collation != new_target_collation:
+                # Collation change in the referenced field - apply the same collation to the foreign key field
+                fragment = self._alter_column_collation_sql(
+                    new_rel.related_model, new_rel.field, rel_type, new_target_collation
+                )
+                other_actions = []
+            else:
+                # No collation change - just handle type change
+                fragment, other_actions = self._alter_column_type_sql(
+                    new_rel.related_model, old_rel.field, new_rel.field, rel_type
+                )
+            
             self.execute(
                 self.sql_alter_column
                 % {
                     "table": self.quote_name(new_rel.related_model._meta.db_table),
                     "changes": fragment[0],
diff --git a/tests/schema/tests.py b/tests/schema/tests.py
index 2d12796cbd..48d4f7266d 100644
--- a/tests/schema/tests.py
+++ b/tests/schema/tests.py
@@ -4702,5 +4702,71 @@ class SchemaTests(TransactionTestCase):
             self.assertIs(Author.objects.filter(name="Andrew").exists(), False)
         finally:
             if connection.vendor == "postgresql":
                 with connection.cursor() as cursor:
                     cursor.execute("DROP COLLATION IF EXISTS case_insensitive")
+
+    @skipUnlessDBFeature("supports_collation_on_charfield")
+    def test_alter_primary_key_db_collation_with_foreign_keys(self):
+        """
+        Test that when a primary key field with db_collation is altered,
+        the collation is properly propagated to related foreign key fields.
+        This addresses the issue where foreign key constraints fail in MySQL
+        due to collation mismatches.
+        """
+        collation = connection.features.test_collations.get("non_default")
+        if not collation:
+            self.skipTest("Language collations are not supported.")
+
+        # Create models with foreign key relationships
+        class Account(Model):
+            id = CharField(primary_key=True, max_length=22)
+            name = CharField(max_length=100)
+
+            class Meta:
+                app_label = "schema"
+
+        class Profile(Model):
+            id = CharField(primary_key=True, max_length=22)
+            account = ForeignKey(Account, on_delete=CASCADE)
+            bio = TextField()
+
+            class Meta:
+                app_label = "schema"
+
+        self.isolated_local_models = [Account, Profile]
+
+        # Create the models
+        with connection.schema_editor() as editor:
+            editor.create_model(Account)
+            editor.create_model(Profile)
+
+        # Alter the Account.id field to add db_collation
+        old_field = Account._meta.get_field("id")
+        new_field = CharField(primary_key=True, max_length=22, db_collation=collation)
+        new_field.set_attributes_from_name("id")
+        new_field.model = Account
+
+        # This should not raise an exception (previously would fail with foreign key constraint errors)
+        with connection.schema_editor() as editor:
+            editor.alter_field(Account, old_field, new_field, strict=True)
+
+        # Verify the primary key field has the correct collation
+        self.assertEqual(
+            self.get_column_collation(Account._meta.db_table, "id"),
+            collation,
+        )
+
+        # For databases that support introspecting foreign key collations,
+        # verify that the foreign key field also has the correct collation
+        if hasattr(self, 'get_column_collation'):
+            try:
+                fk_collation = self.get_column_collation(Profile._meta.db_table, "account_id")
+                if fk_collation is not None:
+                    self.assertEqual(fk_collation, collation)
+            except Exception:
+                # Some databases might not support introspecting FK collations
+                pass
+
+        # Clean up - revert the collation change
+        with connection.schema_editor() as editor:
+            editor.alter_field(Account, new_field, old_field, strict=True)
