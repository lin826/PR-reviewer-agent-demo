diff --git a/sympy/printing/pycode.py b/sympy/printing/pycode.py
index b669a2c783..acf8ea815c 100644
--- a/sympy/printing/pycode.py
+++ b/sympy/printing/pycode.py
@@ -231,12 +231,28 @@ def _print_NegativeInfinity(self, expr):
 
     def _print_ComplexInfinity(self, expr):
         return self._print_NaN(expr)
 
     def _print_Mod(self, expr):
-        PREC = precedence(expr)
+        from .precedence import PRECEDENCE
+        PREC = PRECEDENCE["Mul"]
         return ('{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))
+    
+    def parenthesize(self, item, level, strict=False):
+        # Override parenthesize to handle Mod expressions specially
+        # When a Mod expression is converted to %, it should have the same precedence as multiplication
+        if hasattr(item, 'func') and item.func.__name__ == 'Mod':
+            # The % operator in Python has the same precedence as *, but it can be confusing
+            # in contexts involving unary minus or other operations. To be safe, we parenthesize
+            # Mod expressions when they're part of any larger expression.
+            if level > 0:  # If we're not at the top level, parenthesize
+                return "(%s)" % self._print(item)
+            else:
+                return self._print(item)
+        else:
+            # Use the default behavior for other expressions
+            return super().parenthesize(item, level, strict)
 
     def _print_Piecewise(self, expr):
         result = []
         i = 0
         for arg in expr.args:
