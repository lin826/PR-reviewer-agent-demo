diff --git b/sphinx/directives/other.py a/sphinx/directives/other.py
index 52edec77b..19f7c0a8d 100644
--- b/sphinx/directives/other.py
+++ a/sphinx/directives/other.py
@@ -374,102 +374,11 @@ class Include(BaseInclude, SphinxDirective):
             # docutils "standard" includes, do not do path processing
             return super().run()
         rel_filename, filename = self.env.relfn2path(self.arguments[0])
         self.arguments[0] = filename
         self.env.note_included(filename)
-        
-        # Check if the included file is a Sphinx document that should be processed
-        # through the source-read event
-        docname = self.env.path2doc(rel_filename)
-        if docname is not None:
-            # This is a Sphinx document, so we need to process it through
-            # the source-read event before including it
-            return self._run_with_source_read_event(filename, docname)
-        else:
-            # Not a Sphinx document, use the standard docutils behavior
-            return super().run()
-    
-    def _run_with_source_read_event(self, filename: str, docname: str) -> list[Node]:
-        """Run the include directive with source-read event processing."""
-        # We need to temporarily override the file reading mechanism
-        # to use Sphinx's source-read event processing
-        
-        # Store the original arguments
-        original_arguments = self.arguments[:]
-        
-        try:
-            # Read the file content and process it through source-read event
-            from sphinx.io import SphinxFileInput
-            
-            # Create a file input object
-            encoding = self.options.get(
-                'encoding', self.state.document.settings.input_encoding)
-            error_handler = self.state.document.settings.input_encoding_error_handler
-            
-            try:
-                source_input = SphinxFileInput(
-                    source_path=filename,
-                    encoding=encoding,
-                    error_handler=error_handler
-                )
-                content = source_input.read()
-            except (OSError, UnicodeError) as error:
-                # Let the parent class handle the error
-                return super().run()
-            
-            # Emit the source-read event
-            arg = [content]
-            self.env.events.emit('source-read', docname, arg)
-            processed_content = arg[0]
-            
-            # If the content was modified, we need to create a temporary source
-            # and use it instead of the file
-            if processed_content != content:
-                return self._run_with_processed_content(processed_content, filename)
-            else:
-                # Content wasn't modified, use standard behavior
-                return super().run()
-                
-        except Exception:
-            # If anything goes wrong, fall back to standard behavior
-            return super().run()
-        finally:
-            # Restore original arguments
-            self.arguments[:] = original_arguments
-    
-    def _run_with_processed_content(self, content: str, filename: str) -> list[Node]:
-        """Run the include directive with pre-processed content."""
-        # We need to monkey-patch the file reading to use our processed content
-        from docutils import io
-        from docutils.parsers.rst import directives
-        from docutils import statemachine
-        import tempfile
-        import os
-        
-        # Create a temporary file with the processed content
-        with tempfile.NamedTemporaryFile(mode='w', suffix='.rst', delete=False, encoding='utf-8') as tmp_file:
-            tmp_file.write(content)
-            tmp_filename = tmp_file.name
-        
-        try:
-            # Temporarily replace the filename argument
-            original_filename = self.arguments[0]
-            self.arguments[0] = tmp_filename
-            
-            # Call the parent run method
-            result = super().run()
-            
-            return result
-            
-        finally:
-            # Clean up the temporary file
-            try:
-                os.unlink(tmp_filename)
-            except OSError:
-                pass
-            # Restore the original filename
-            self.arguments[0] = original_filename
+        return super().run()
 
 
 def setup(app: Sphinx) -> dict[str, Any]:
     directives.register_directive('toctree', TocTree)
     directives.register_directive('sectionauthor', Author)
