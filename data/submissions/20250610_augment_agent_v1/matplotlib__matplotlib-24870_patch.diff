diff --git a/lib/matplotlib/contour.py b/lib/matplotlib/contour.py
index 144eadeae2..dd874fcceb 100644
--- a/lib/matplotlib/contour.py
+++ b/lib/matplotlib/contour.py
@@ -1121,11 +1121,21 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):
         """
         Determine the contour levels and store in self.levels.
         """
         if self.levels is None:
             if len(args) == 0:
-                levels_arg = 7  # Default, hard-wired.
+                # Auto-detect boolean arrays and use appropriate default levels
+                if (hasattr(self, '_z_is_boolean') and self._z_is_boolean and 
+                    self.zmin < self.zmax):  # Only for mixed boolean arrays
+                    if self.filled:
+                        # Filled contours need at least 2 levels
+                        levels_arg = [0, 0.5, 1]
+                    else:
+                        # Line contours can use a single level
+                        levels_arg = [0.5]
+                else:
+                    levels_arg = 7  # Default, hard-wired.
             else:
                 levels_arg = args[0]
         else:
             levels_arg = self.levels
         if isinstance(levels_arg, Integral):
@@ -1445,14 +1455,22 @@ class QuadContourSet(ContourSet):
             fn = 'contourf'
         else:
             fn = 'contour'
         nargs = len(args)
         if nargs <= 2:
-            z = ma.asarray(args[0], dtype=np.float64)
+            # Check if the original z array is boolean before conversion
+            z_orig = args[0]
+            self._z_is_boolean = (hasattr(z_orig, 'dtype') and 
+                                  np.issubdtype(z_orig.dtype, np.bool_))
+            z = ma.asarray(z_orig, dtype=np.float64)
             x, y = self._initialize_x_y(z)
             args = args[1:]
         elif nargs <= 4:
+            # Check if the original z array is boolean before conversion
+            z_orig = args[2]
+            self._z_is_boolean = (hasattr(z_orig, 'dtype') and 
+                                  np.issubdtype(z_orig.dtype, np.bool_))
             x, y, z = self._check_xyz(args[:3], kwargs)
             args = args[3:]
         else:
             raise _api.nargs_error(fn, takes="from 1 to 4", given=nargs)
         z = ma.masked_invalid(z, copy=False)
