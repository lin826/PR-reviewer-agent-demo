diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py
index fafc1beee8..b063430e0f 100644
--- a/django/db/models/fields/json.py
+++ b/django/db/models/fields/json.py
@@ -2,10 +2,11 @@ import json
 
 from django import forms
 from django.core import checks, exceptions
 from django.db import NotSupportedError, connections, router
 from django.db.models import lookups
+from django.db.models.expressions import Value
 from django.db.models.lookups import PostgresOperatorLookup, Transform
 from django.utils.translation import gettext_lazy as _
 
 from . import Field
 from .mixins import CheckFieldDefaultMixin
@@ -477,13 +478,68 @@ class KeyTransformGt(KeyTransformNumericLookupMixin, lookups.GreaterThan):
 
 class KeyTransformGte(KeyTransformNumericLookupMixin, lookups.GreaterThanOrEqual):
     pass
 
 
+class KeyTransformIn(lookups.In):
+    def batch_process_rhs(self, compiler, connection, rhs=None):
+        if rhs is None:
+            rhs = self.rhs
+        if self.bilateral_transforms:
+            sqls, sqls_params = [], []
+            for p in rhs:
+                value = Value(p, output_field=self.lhs.output_field)
+                value = self.apply_bilateral_transforms(value)
+                value = value.resolve_expression(compiler.query)
+                sql, sql_params = compiler.compile(value)
+                sqls.append(sql)
+                sqls_params.extend(sql_params)
+        else:
+            # Get the base processing from the parent class
+            sqls, sqls_params = super().batch_process_rhs(compiler, connection, rhs)
+            
+            # Convert None values to 'null' string like JSONExact does
+            sqls_params = ['null' if param is None else param for param in sqls_params]
+            
+            # Apply JSON-specific processing for different database vendors
+            if connection.vendor == 'oracle':
+                # Convert parameters to JSON functions like KeyTransformExact does
+                func = []
+                for value in sqls_params:
+                    if value == 'null':
+                        # Handle null values specially for Oracle
+                        func.append('NULL')
+                    else:
+                        # Convert the value to JSON if it's a string representation
+                        try:
+                            parsed_value = json.loads(value) if isinstance(value, str) else value
+                        except (json.JSONDecodeError, TypeError):
+                            parsed_value = value
+                        
+                        function = 'JSON_QUERY' if isinstance(parsed_value, (list, dict)) else 'JSON_VALUE'
+                        func.append("%s('%s', '$.value')" % (
+                            function,
+                            json.dumps({'value': parsed_value}),
+                        ))
+                sqls = func
+                sqls_params = []
+            elif connection.vendor == 'sqlite':
+                # Wrap each value in JSON_EXTRACT like KeyTransformExact does
+                func = ["JSON_EXTRACT(%s, '$')" if value != 'null' else '%s' for value in sqls_params]
+                sqls = func
+            elif connection.vendor == 'mysql':
+                # For MySQL, wrap each value in JSON_EXTRACT like JSONExact does
+                func = ["JSON_EXTRACT(%s, '$')"] * len(sqls_params)
+                sqls = func
+                
+        return sqls, sqls_params
+
+
 KeyTransform.register_lookup(KeyTransformExact)
 KeyTransform.register_lookup(KeyTransformIExact)
 KeyTransform.register_lookup(KeyTransformIsNull)
+KeyTransform.register_lookup(KeyTransformIn)
 KeyTransform.register_lookup(KeyTransformIContains)
 KeyTransform.register_lookup(KeyTransformStartsWith)
 KeyTransform.register_lookup(KeyTransformIStartsWith)
 KeyTransform.register_lookup(KeyTransformEndsWith)
 KeyTransform.register_lookup(KeyTransformIEndsWith)
