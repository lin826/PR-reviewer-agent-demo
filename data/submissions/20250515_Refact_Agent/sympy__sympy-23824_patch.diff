diff --git a/sympy/physics/hep/gamma_matrices.py b/sympy/physics/hep/gamma_matrices.py
index 23284e4a92..e3f2bd7e23 100644
--- a/sympy/physics/hep/gamma_matrices.py
+++ b/sympy/physics/hep/gamma_matrices.py
@@ -674,7 +674,8 @@ def kahane_simplify(expression):
                 pointer = next_ones[0]
 
             if pointer >= first_dum_pos and free_pos[pointer] is not None:
-                prepend_indices.insert(0, free_pos[pointer])
+                # collect free indices in traversal order
+                prepend_indices.append(free_pos[pointer])
         # if `prepend_indices` is void, it means there are no free indices
         # in the loop (and it can be shown that there must be a virtual index),
         # loops of virtual indices only contribute by a factor of two:
@@ -694,8 +695,13 @@ def kahane_simplify(expression):
 
     # If `first_dum_pos` is not zero, it means that there are trailing free gamma
     # matrices in front of `expression`, so multiply by them:
-    for i in range(0, first_dum_pos):
-        [ri.insert(0, free_pos[i]) for ri in resulting_indices]
+    # Re-add any leading free γ's *before* the first contraction,
+    # preserving the original left-to-right order:
+    if first_dum_pos > 0:
+        prefix = [free_pos[i] for i in range(first_dum_pos)]
+        for ri in resulting_indices:
+            # insert the entire prefix at the front, in correct order
+            ri[0:0] = prefix
 
     resulting_expr = S.Zero
     for i in resulting_indices:
diff --git a/sympy/physics/hep/tests/test_gamma_matrices.py b/sympy/physics/hep/tests/test_gamma_matrices.py
index 27509803f2..57f099602d 100644
--- a/sympy/physics/hep/tests/test_gamma_matrices.py
+++ b/sympy/physics/hep/tests/test_gamma_matrices.py
@@ -399,3 +399,14 @@ def test_gamma_matrix_trace():
     t = ps*ps*ps*ps*ps*ps*ps*ps
     r = gamma_trace(t)
     assert r.equals(4*p2*p2*p2*p2)
+
+
+def test_kahane_simplify_leading_free_gammas():
+    mu, nu, rho, sigma = tensor_indices("mu, nu, rho, sigma", LorentzIndex)
+    # free γ's *after* the contraction — already correct
+    t1 = G(mu)*G(-mu)*G(rho)*G(sigma)
+    assert kahane_simplify(t1).equals(4*G(rho)*G(sigma))
+
+    # free γ's *before* the contraction — order must be preserved
+    t2 = G(rho)*G(sigma)*G(mu)*G(-mu)
+    assert kahane_simplify(t2).equals(4*G(rho)*G(sigma))
