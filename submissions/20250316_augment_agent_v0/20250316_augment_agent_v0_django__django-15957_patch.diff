diff --git a/django/db/models/query.py b/django/db/models/query.py
index be0deb90b0..4d46886d7f 100644
--- a/django/db/models/query.py
+++ b/django/db/models/query.py
@@ -2446,18 +2446,33 @@ def prefetch_one_level(instances, prefetcher, lookup, level):
     #  boolean that is True when the previous argument is a cache name vs a field name).
 
     # The 'values to be matched' must be hashable as they will be used
     # in a dictionary.
 
+    queryset = lookup.get_current_queryset(level)
+    
+    # Handle sliced querysets
+    low_mark = high_mark = None
+    if queryset is not None and queryset.query.is_sliced:
+        # Store the slice limits
+        low_mark, high_mark = queryset.query.low_mark, queryset.query.high_mark
+        # Clone the queryset and clear the limits
+        queryset = queryset._chain()
+        queryset.query.clear_limits()
+    
     (
         rel_qs,
         rel_obj_attr,
         instance_attr,
         single,
         cache_name,
         is_descriptor,
-    ) = prefetcher.get_prefetch_queryset(instances, lookup.get_current_queryset(level))
+    ) = prefetcher.get_prefetch_queryset(instances, queryset)
+    
+    # Apply the stored slice limits to the result queryset
+    if low_mark is not None or high_mark is not None:
+        rel_qs = rel_qs[low_mark:high_mark]
     # We have to handle the possibility that the QuerySet we just got back
     # contains some prefetch_related lookups. We don't want to trigger the
     # prefetch_related functionality by evaluating the query. Rather, we need
     # to merge in the prefetch_related lookups.
     # Copy the lookups in case it is a Prefetch object which could be reused
