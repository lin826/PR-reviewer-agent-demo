diff --git a/src/_pytest/reports.py b/src/_pytest/reports.py
index 4682d5b6e..58da8d6b2 100644
--- a/src/_pytest/reports.py
+++ b/src/_pytest/reports.py
@@ -184,11 +184,18 @@ class BaseReport:
                 "sections": rep.longrepr.sections,
             }
 
         d = self.__dict__.copy()
         if hasattr(self.longrepr, "toterminal"):
-            if hasattr(self.longrepr, "reprtraceback") and hasattr(
+            # For chained exceptions, convert to string representation
+            if hasattr(self.longrepr, "chain") and hasattr(self, "config") and hasattr(self.config, "workerinput"):
+                # Capture the string representation of the exception chain
+                io = py.io.TextIO()
+                tw = py.io.TerminalWriter(file=io)
+                self.longrepr.toterminal(tw)
+                d["longrepr"] = io.getvalue().strip()
+            elif hasattr(self.longrepr, "reprtraceback") and hasattr(
                 self.longrepr, "reprcrash"
             ):
                 d["longrepr"] = disassembled_report(self)
             else:
                 d["longrepr"] = str(self.longrepr)
@@ -210,15 +217,24 @@ class BaseReport:
         class. It's the callers responsibility to know which class to pass here.
 
         Experimental method.
         """
         if reportdict["longrepr"]:
-            if (
+            # If longrepr is a string and contains chained exception markers, 
+            # it's a serialized chained exception
+            if isinstance(reportdict["longrepr"], str) and (
+                "The above exception was the direct cause of the following exception" in reportdict["longrepr"] or
+                "During handling of the above exception, another exception occurred" in reportdict["longrepr"]
+            ):
+                # Keep it as a string, it will be displayed correctly
+                pass
+            elif (
+                isinstance(reportdict["longrepr"], dict) and
                 "reprcrash" in reportdict["longrepr"]
                 and "reprtraceback" in reportdict["longrepr"]
             ):
-
+                # Handle single exception
                 reprtraceback = reportdict["longrepr"]["reprtraceback"]
                 reprcrash = reportdict["longrepr"]["reprcrash"]
 
                 unserialized_entries = []
                 reprentry = None
@@ -358,14 +374,30 @@ class TestReport(BaseReport):
                 longrepr = (str(r.path), r.lineno, r.message)
             else:
                 outcome = "failed"
                 if call.when == "call":
                     longrepr = item.repr_failure(excinfo)
+                    
+                    # For xdist compatibility, if we have a chained exception,
+                    # convert it to a string representation
+                    if hasattr(longrepr, "chain") and hasattr(item.config, "workerinput"):
+                        io = py.io.TextIO()
+                        tw = py.io.TerminalWriter(file=io)
+                        longrepr.toterminal(tw)
+                        longrepr = io.getvalue().strip()
                 else:  # exception in setup or teardown
                     longrepr = item._repr_failure_py(
                         excinfo, style=item.config.getoption("tbstyle", "auto")
                     )
+                    
+                    # For xdist compatibility, if we have a chained exception,
+                    # convert it to a string representation
+                    if hasattr(longrepr, "chain") and hasattr(item.config, "workerinput"):
+                        io = py.io.TextIO()
+                        tw = py.io.TerminalWriter(file=io)
+                        longrepr.toterminal(tw)
+                        longrepr = io.getvalue().strip()
         for rwhen, key, content in item._report_sections:
             sections.append(("Captured {} {}".format(key, rwhen), content))
         return cls(
             item.nodeid,
             item.location,
diff --git a/src/_pytest/terminal.py b/src/_pytest/terminal.py
index 0d9794159..e87329a61 100644
--- a/src/_pytest/terminal.py
+++ b/src/_pytest/terminal.py
@@ -845,11 +845,18 @@ class TerminalReporter:
                     msg = "ERROR at {} of {}".format(rep.when, msg)
                 self.write_sep("_", msg, red=True, bold=True)
                 self._outrep_summary(rep)
 
     def _outrep_summary(self, rep):
-        rep.toterminal(self._tw)
+        # Handle string representation of chained exceptions
+        if isinstance(rep.longrepr, str) and (
+            "The above exception was the direct cause of the following exception" in rep.longrepr or
+            "During handling of the above exception, another exception occurred" in rep.longrepr
+        ):
+            self._tw.line(rep.longrepr)
+        else:
+            rep.toterminal(self._tw)
         showcapture = self.config.option.showcapture
         if showcapture == "no":
             return
         for secname, content in rep.sections:
             if showcapture != "all" and showcapture not in secname:
