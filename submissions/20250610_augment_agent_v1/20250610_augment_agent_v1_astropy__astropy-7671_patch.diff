diff --git a/astropy/utils/introspection.py b/astropy/utils/introspection.py
index 3e784f9fc3..923476119f 100644
--- a/astropy/utils/introspection.py
+++ b/astropy/utils/introspection.py
@@ -4,11 +4,19 @@
 
 
 import inspect
 import types
 import importlib
-from distutils.version import LooseVersion
+
+# Try to use the modern packaging.version.Version if available,
+# otherwise fall back to distutils.version.LooseVersion
+try:
+    from packaging.version import Version as _Version
+    _use_packaging = True
+except ImportError:
+    from distutils.version import LooseVersion as _Version
+    _use_packaging = False
 
 
 __all__ = ['resolve_name', 'minversion', 'find_current_module',
            'isinstancemethod']
 
@@ -138,13 +146,103 @@ def minversion(module, version, inclusive=True, version_path='__version__'):
         have_version = getattr(module, version_path)
     else:
         have_version = resolve_name(module.__name__, version_path)
 
     if inclusive:
-        return LooseVersion(have_version) >= LooseVersion(version)
+        return _compare_versions(have_version, version, '>=')
+    else:
+        return _compare_versions(have_version, version, '>')
+
+
+def _compare_versions(version1, version2, operator):
+    """
+    Compare two version strings using the best available version parser.
+    
+    This function tries to use packaging.version.Version if available,
+    otherwise falls back to distutils.version.LooseVersion with error handling
+    for the known TypeError bug when comparing versions with mixed types.
+    
+    Parameters
+    ----------
+    version1 : str
+        First version string
+    version2 : str  
+        Second version string
+    operator : str
+        Comparison operator: '>=' or '>'
+        
+    Returns
+    -------
+    bool
+        Result of the version comparison
+    """
+    try:
+        v1 = _Version(version1)
+        v2 = _Version(version2)
+        if operator == '>=':
+            return v1 >= v2
+        elif operator == '>':
+            return v1 > v2
+        else:
+            raise ValueError(f"Unsupported operator: {operator}")
+    except TypeError:
+        # Handle the LooseVersion bug when comparing mixed types
+        # This occurs when comparing versions like '1.14.3' with '1.14dev'
+        if not _use_packaging:
+            return _fallback_version_compare(version1, version2, operator)
+        else:
+            # This shouldn't happen with packaging.version, but just in case
+            raise
+
+
+def _fallback_version_compare(version1, version2, operator):
+    """
+    Fallback version comparison for when LooseVersion fails with TypeError.
+    
+    This implements a simple comparison logic for the specific case where
+    LooseVersion fails due to mixed type comparison (int vs str).
+    """
+    import re
+    
+    # Extract numeric parts and pre-release identifiers
+    def parse_version(v):
+        # Match pattern like "1.14.3" or "1.14dev" or "1.14rc1"
+        match = re.match(r'^(\d+(?:\.\d+)*)(.*)', v)
+        if match:
+            numeric_part = match.group(1)
+            suffix = match.group(2)
+            # Convert numeric part to tuple of integers for comparison
+            numeric_tuple = tuple(int(x) for x in numeric_part.split('.'))
+            return numeric_tuple, suffix
+        else:
+            # Fallback: treat as string
+            return (0,), v
+    
+    num1, suffix1 = parse_version(version1)
+    num2, suffix2 = parse_version(version2)
+    
+    # Compare numeric parts first
+    if num1 != num2:
+        if operator == '>=':
+            return num1 >= num2
+        else:  # operator == '>'
+            return num1 > num2
+    
+    # If numeric parts are equal, compare suffixes
+    # Empty suffix (final release) > any non-empty suffix (pre-release)
+    if not suffix1 and suffix2:
+        return True  # 1.14 >= 1.14dev
+    elif suffix1 and not suffix2:
+        return False  # 1.14dev < 1.14
+    elif not suffix1 and not suffix2:
+        return operator == '>='  # 1.14 >= 1.14 is True, 1.14 > 1.14 is False
     else:
-        return LooseVersion(have_version) > LooseVersion(version)
+        # Both have suffixes, compare lexicographically
+        if operator == '>=':
+            return suffix1 >= suffix2
+        else:  # operator == '>'
+            return suffix1 > suffix2
 
 
 def find_current_module(depth=1, finddiff=False):
     """
     Determines the module/package from which this function is called.
