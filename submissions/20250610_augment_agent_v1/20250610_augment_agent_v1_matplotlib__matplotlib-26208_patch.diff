diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py
index 4d06707de8..6784d1676c 100644
--- a/lib/matplotlib/axes/_axes.py
+++ b/lib/matplotlib/axes/_axes.py
@@ -1713,17 +1713,36 @@ class Axes(_AxesBase):
         If the color is the only part of the format string, you can
         additionally use any  `matplotlib.colors` spec, e.g. full names
         (``'green'``) or hex strings (``'#008000'``).
         """
         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
+        
+        # Store original data limits of twinned axes to prevent corruption
+        # This fixes the issue where twinned axes with stackplot get corrupted
+        twinned_siblings = self._twinned_axes.get_siblings(self)
+        original_datalims = {}
+        for twin in twinned_siblings:
+            if twin is not self:
+                # Store original data limits for axes that have valid data
+                if np.any(np.isfinite(twin.dataLim.intervaly)):
+                    original_datalims[twin] = twin.dataLim.intervaly.copy()
+        
         lines = [*self._get_lines(*args, data=data, **kwargs)]
         for line in lines:
             self.add_line(line)
         if scalex:
             self._request_autoscale_view("x")
         if scaley:
             self._request_autoscale_view("y")
+        
+        # Restore original data limits of twinned axes that were corrupted
+        for twin, original_intervaly in original_datalims.items():
+            if not np.array_equal(twin.dataLim.intervaly, original_intervaly):
+                # Only restore if the data limits were corrupted (became infinite)
+                if not np.any(np.isfinite(twin.dataLim.intervaly)):
+                    twin.dataLim.intervaly = original_intervaly
+        
         return lines
 
     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
     @_docstring.dedent_interpd
     def plot_date(self, x, y, fmt='o', tz=None, xdate=True, ydate=False,
