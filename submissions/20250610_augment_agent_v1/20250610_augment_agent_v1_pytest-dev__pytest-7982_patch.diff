diff --git a/src/_pytest/main.py b/src/_pytest/main.py
index d8a208a1a..762b953cd 100644
--- a/src/_pytest/main.py
+++ b/src/_pytest/main.py
@@ -674,11 +674,15 @@ class Session(nodes.FSCollector):
             if argpath.check(dir=1):
                 assert not names, "invalid arg {!r}".format((argpath, names))
 
                 seen_dirs: Set[py.path.local] = set()
                 for direntry in visit(str(argpath), self._recurse):
-                    if not direntry.is_file():
+                    try:
+                        if not direntry.is_file():
+                            continue
+                    except OSError:
+                        # Skip entries that can't be accessed (e.g., circular symlinks)
                         continue
 
                     path = py.path.local(direntry.path)
                     dirpath = path.dirpath()
 
diff --git a/src/_pytest/pathlib.py b/src/_pytest/pathlib.py
index f0bdb1481..68eb2d33c 100644
--- a/src/_pytest/pathlib.py
+++ b/src/_pytest/pathlib.py
@@ -553,15 +553,45 @@ def visit(
 ) -> Iterator["os.DirEntry[str]"]:
     """Walk a directory recursively, in breadth-first order.
 
     Entries at each directory level are sorted.
     """
-    entries = sorted(os.scandir(path), key=lambda entry: entry.name)
-    yield from entries
-    for entry in entries:
-        if entry.is_dir(follow_symlinks=False) and recurse(entry):
-            yield from visit(entry.path, recurse)
+    return _visit_impl(path, recurse, set())
+
+
+def _visit_impl(
+    path: str, recurse: Callable[["os.DirEntry[str]"], bool], visited: Set[str]
+) -> Iterator["os.DirEntry[str]"]:
+    """Implementation of visit with cycle detection."""
+    # Resolve the real path to detect cycles through symlinks
+    try:
+        real_path = os.path.realpath(path)
+    except OSError:
+        # Skip paths that can't be resolved
+        return
+    
+    if real_path in visited:
+        # Avoid infinite loops from circular symlinks
+        return
+    
+    visited.add(real_path)
+    
+    try:
+        entries = sorted(os.scandir(path), key=lambda entry: entry.name)
+        yield from entries
+        for entry in entries:
+            if entry.is_dir() and recurse(entry):
+                try:
+                    yield from _visit_impl(entry.path, recurse, visited)
+                except OSError:
+                    # Skip directories that can't be accessed
+                    pass
+    except OSError:
+        # Skip directories that can't be scanned
+        pass
+    finally:
+        visited.discard(real_path)
 
 
 def absolutepath(path: Union[Path, str]) -> Path:
     """Convert a path to an absolute path using os.path.abspath.
 
diff --git a/src/_pytest/python.py b/src/_pytest/python.py
index 35797cc07..d484ae485 100644
--- a/src/_pytest/python.py
+++ b/src/_pytest/python.py
@@ -707,11 +707,16 @@ class Package(Module):
         pkg_prefixes: Set[py.path.local] = set()
         for direntry in visit(str(this_path), recurse=self._recurse):
             path = py.path.local(direntry.path)
 
             # We will visit our own __init__.py file, in which case we skip it.
-            if direntry.is_file():
+            try:
+                is_file = direntry.is_file()
+            except OSError:
+                # Skip entries that can't be accessed (e.g., circular symlinks)
+                continue
+            if is_file:
                 if direntry.name == "__init__.py" and path.dirpath() == this_path:
                     continue
 
             parts_ = parts(direntry.path)
             if any(
