diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py
index 850734709d..f0e8d48f88 100644
--- a/django/db/models/sql/compiler.py
+++ b/django/db/models/sql/compiler.py
@@ -58,10 +58,27 @@ class SQLCompiler:
         extra_select = self.get_extra_select(order_by, self.select)
         self.has_extra_select = bool(extra_select)
         group_by = self.get_group_by(self.select + extra_select, order_by)
         return extra_select, order_by, group_by
 
+    def _is_meta_ordering_field(self, col):
+        """
+        Check if a column corresponds to a field in Meta.ordering.
+        """
+        if not hasattr(self, '_meta_ordering') or not self._meta_ordering:
+            return False
+        
+        # Get the field name from the column
+        if hasattr(col, 'target') and hasattr(col.target, 'name'):
+            field_name = col.target.name
+            # Check if this field name is in Meta.ordering (ignoring direction prefixes)
+            for ordering_field in self._meta_ordering:
+                clean_field = ordering_field.lstrip('-')
+                if clean_field == field_name:
+                    return True
+        return False
+
     def get_group_by(self, select, order_by):
         """
         Return a list of 2-tuples of form (sql, params).
 
         The logic of what exactly the GROUP BY clause contains is hard
@@ -122,15 +139,27 @@ class SQLCompiler:
             # by reference.
             if expr in ref_sources:
                 continue
             cols = expr.get_group_by_cols()
             for col in cols:
+                # Skip Meta.ordering fields when there's a GROUP BY clause
+                if (self.query.group_by is not None and 
+                    hasattr(self, '_meta_ordering') and 
+                    self._meta_ordering and
+                    self._is_meta_ordering_field(col)):
+                    continue
                 expressions.append(col)
         for expr, (sql, params, is_ref) in order_by:
             # Skip References to the select clause, as all expressions in the
             # select clause are already part of the group by.
             if not is_ref:
+                # Skip Meta.ordering fields when there's a GROUP BY clause
+                if (self.query.group_by is not None and 
+                    hasattr(self, '_meta_ordering') and 
+                    self._meta_ordering):
+                    # Skip all order_by expressions when Meta.ordering is being used
+                    continue
                 expressions.extend(expr.get_group_by_cols())
         having_group_by = self.having.get_group_by_cols() if self.having else ()
         for expr in having_group_by:
             expressions.append(expr)
         result = []
