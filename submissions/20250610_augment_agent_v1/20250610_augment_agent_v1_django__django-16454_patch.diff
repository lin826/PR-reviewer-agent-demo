diff --git a/django/core/management/base.py b/django/core/management/base.py
index abc6f79a15..aa4a6ea837 100644
--- a/django/core/management/base.py
+++ b/django/core/management/base.py
@@ -41,10 +41,28 @@ class SystemCheckError(CommandError):
     """
 
     pass
 
 
+class DjangoSubParsersAction(argparse._SubParsersAction):
+    """
+    Custom subparsers action that preserves Django CommandParser arguments.
+    """
+
+    def __init__(self, *args, **kwargs):
+        # Extract Django-specific arguments from parent parser
+        self._django_kwargs = kwargs.pop('django_kwargs', {})
+        super().__init__(*args, **kwargs)
+
+    def add_parser(self, name, **kwargs):
+        # Merge Django-specific kwargs with the provided kwargs
+        # Django kwargs take precedence if not explicitly overridden
+        for key, value in self._django_kwargs.items():
+            kwargs.setdefault(key, value)
+        return super().add_parser(name, **kwargs)
+
+
 class CommandParser(ArgumentParser):
     """
     Customized ArgumentParser class to improve some error messages and prevent
     SystemExit in several occasions, as SystemExit is unacceptable when a
     command is called programmatically.
@@ -69,10 +87,47 @@ class CommandParser(ArgumentParser):
         if self.called_from_command_line:
             super().error(message)
         else:
             raise CommandError("Error: %s" % message)
 
+    def add_subparsers(self, **kwargs):
+        if self._subparsers is not None:
+            self.error('cannot have multiple subparser arguments')
+
+        # Preserve Django-specific arguments for subparsers
+        django_kwargs = {
+            'missing_args_message': self.missing_args_message,
+            'called_from_command_line': self.called_from_command_line,
+        }
+        kwargs['django_kwargs'] = django_kwargs
+
+        # add the parser class to the arguments if it's not present
+        kwargs.setdefault('parser_class', type(self))
+
+        if 'title' in kwargs or 'description' in kwargs:
+            title = kwargs.pop('title', 'subcommands')
+            description = kwargs.pop('description', None)
+            self._subparsers = self.add_argument_group(title, description)
+        else:
+            self._subparsers = self._positionals
+
+        # prog defaults to the usage message of this parser, skipping
+        # optional arguments and with no "usage:" prefix
+        if kwargs.get('prog') is None:
+            formatter = self._get_formatter()
+            positionals = self._get_positional_actions()
+            groups = self._mutually_exclusive_groups
+            formatter.add_usage(self.usage, positionals, groups, '')
+            kwargs['prog'] = formatter.format_help().strip()
+
+        # create the parsers action and add it to the positionals list
+        action = DjangoSubParsersAction(option_strings=[], **kwargs)
+        self._subparsers._add_action(action)
+
+        # return the created parsers action
+        return action
+
 
 def handle_default_options(options):
     """
     Include any default options that all commands should accept here
     so that ManagementUtility can handle them before searching for
