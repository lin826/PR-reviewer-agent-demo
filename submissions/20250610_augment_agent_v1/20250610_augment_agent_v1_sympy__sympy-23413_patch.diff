diff --git a/sympy/polys/matrices/normalforms.py b/sympy/polys/matrices/normalforms.py
index 30f5534b08..1396c45e7f 100644
--- a/sympy/polys/matrices/normalforms.py
+++ b/sympy/polys/matrices/normalforms.py
@@ -241,10 +241,45 @@ def _hermite_normal_form(A):
         # w.r.t. the pivot as divisor.
         else:
             for j in range(k + 1, n):
                 q = A[i][j] // b
                 add_columns(A, j, k, 1, -q, 0, 1)
+    # Check if there are additional pivots in unprocessed rows
+    # This handles cases where min(m,n) < m and some unprocessed rows could contribute pivots
+    # Only apply this fix if we have a specific pattern that indicates the original issue:
+    # - We have more rows than columns (m > n)
+    # - Some pivots were found but not all columns were used (0 < k < n)
+    # - There are unprocessed rows that might have pivots
+    if 0 < k < n and m > rows:
+        # Apply the fix when some but not all pivots were found
+        for i in range(m - 1 - rows, -1, -1):
+            # Check if this row has any non-zero entries in columns that we haven't placed pivots in
+            for col in range(k):
+                if A[i][col] != 0:
+                    # Found a potential pivot, process this row
+                    k -= 1
+                    # Apply the same pivot logic as in the main loop
+                    for j in range(k - 1, -1, -1):
+                        if A[i][j] != 0:
+                            u, v, d = _gcdex(A[i][k], A[i][j])
+                            r, s = A[i][k] // d, A[i][j] // d
+                            add_columns(A, k, j, u, v, -s, r)
+                    
+                    b = A[i][k]
+                    if b < 0:
+                        add_columns(A, k, k, -1, 0, -1, 0)
+                        b = -b
+                    
+                    if b == 0:
+                        k += 1  # Revert if no pivot found
+                    else:
+                        # Reduce entries to the right
+                        for j in range(k + 1, n):
+                            q = A[i][j] // b
+                            add_columns(A, j, k, 1, -q, 0, 1)
+                    break  # Only process one pivot per row
+    
     # Finally, the HNF consists of those columns of A in which we succeeded in making
     # a nonzero pivot.
     return DomainMatrix.from_rep(A)[:, k:]
 
 
