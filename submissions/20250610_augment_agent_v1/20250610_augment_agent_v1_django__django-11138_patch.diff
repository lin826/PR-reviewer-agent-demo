diff --git a/django/db/backends/mysql/operations.py b/django/db/backends/mysql/operations.py
index 50f85e0621..e2a0ae793a 100644
--- a/django/db/backends/mysql/operations.py
+++ b/django/db/backends/mysql/operations.py
@@ -68,11 +68,11 @@ class DatabaseOperations(BaseDatabaseOperations):
         else:
             return "DATE(%s)" % (field_name)
 
     def _convert_field_to_tz(self, field_name, tzname):
         if settings.USE_TZ:
-            field_name = "CONVERT_TZ(%s, 'UTC', '%s')" % (field_name, tzname)
+            field_name = "CONVERT_TZ(%s, '%s', '%s')" % (field_name, self.connection.timezone_name, tzname)
         return field_name
 
     def datetime_cast_date_sql(self, field_name, tzname):
         field_name = self._convert_field_to_tz(field_name, tzname)
         return "DATE(%s)" % field_name
diff --git a/django/db/backends/oracle/operations.py b/django/db/backends/oracle/operations.py
index c1afb2ed5e..897e56d658 100644
--- a/django/db/backends/oracle/operations.py
+++ b/django/db/backends/oracle/operations.py
@@ -97,13 +97,17 @@ END;
     def _convert_field_to_tz(self, field_name, tzname):
         if not settings.USE_TZ:
             return field_name
         if not self._tzname_re.match(tzname):
             raise ValueError("Invalid time zone name: %s" % tzname)
-        # Convert from UTC to local time, returning TIMESTAMP WITH TIME ZONE
+        # Convert from database timezone to target timezone, returning TIMESTAMP WITH TIME ZONE
         # and cast it back to TIMESTAMP to strip the TIME ZONE details.
-        return "CAST((FROM_TZ(%s, '0:00') AT TIME ZONE '%s') AS TIMESTAMP)" % (field_name, tzname)
+        source_tz = self.connection.timezone_name
+        # Oracle FROM_TZ expects UTC offset format for UTC, not timezone name
+        if source_tz == 'UTC':
+            source_tz = '0:00'
+        return "CAST((FROM_TZ(%s, '%s') AT TIME ZONE '%s') AS TIMESTAMP)" % (field_name, source_tz, tzname)
 
     def datetime_cast_date_sql(self, field_name, tzname):
         field_name = self._convert_field_to_tz(field_name, tzname)
         return 'TRUNC(%s)' % field_name
 
diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py
index 6a19236c48..0dd3552547 100644
--- a/django/db/backends/sqlite3/base.py
+++ b/django/db/backends/sqlite3/base.py
@@ -191,16 +191,18 @@ class DatabaseWrapper(BaseDatabaseWrapper):
         kwargs.update({'check_same_thread': False, 'uri': True})
         return kwargs
 
     def get_new_connection(self, conn_params):
         conn = Database.connect(**conn_params)
+        # Create timezone-aware functions that use the database timezone
+        db_timezone_name = self.timezone_name
         conn.create_function("django_date_extract", 2, _sqlite_datetime_extract)
         conn.create_function("django_date_trunc", 2, _sqlite_date_trunc)
-        conn.create_function("django_datetime_cast_date", 2, _sqlite_datetime_cast_date)
-        conn.create_function("django_datetime_cast_time", 2, _sqlite_datetime_cast_time)
-        conn.create_function("django_datetime_extract", 3, _sqlite_datetime_extract)
-        conn.create_function("django_datetime_trunc", 3, _sqlite_datetime_trunc)
+        conn.create_function("django_datetime_cast_date", 2, lambda dt, tzname: _sqlite_datetime_cast_date_with_db_tz(dt, tzname, db_timezone_name))
+        conn.create_function("django_datetime_cast_time", 2, lambda dt, tzname: _sqlite_datetime_cast_time_with_db_tz(dt, tzname, db_timezone_name))
+        conn.create_function("django_datetime_extract", 3, lambda lookup_type, dt, tzname: _sqlite_datetime_extract_with_db_tz(lookup_type, dt, tzname, db_timezone_name))
+        conn.create_function("django_datetime_trunc", 3, lambda lookup_type, dt, tzname: _sqlite_datetime_trunc_with_db_tz(lookup_type, dt, tzname, db_timezone_name))
         conn.create_function("django_time_extract", 2, _sqlite_time_extract)
         conn.create_function("django_time_trunc", 2, _sqlite_time_trunc)
         conn.create_function("django_time_diff", 2, _sqlite_time_diff)
         conn.create_function("django_timestamp_diff", 2, _sqlite_timestamp_diff)
         conn.create_function("django_format_dtdelta", 3, _sqlite_format_dtdelta)
@@ -564,5 +566,91 @@ def _sqlite_lpad(text, length, fill_text):
 
 
 @none_guard
 def _sqlite_rpad(text, length, fill_text):
     return (text + fill_text * length)[:length]
+
+
+def _sqlite_datetime_parse_with_db_tz(dt, tzname=None, db_timezone_name='UTC'):
+    """
+    Parse a datetime string and handle timezone conversion properly.
+    
+    This version uses the database timezone instead of assuming UTC.
+    """
+    if dt is None:
+        return None
+    try:
+        # Parse the datetime string - this returns a naive datetime
+        dt = backend_utils.typecast_timestamp(dt)
+        if dt is None:
+            return None
+        
+        # If the datetime is already timezone-aware (from typecast_timestamp when USE_TZ=True),
+        # it's assumed to be in UTC, but it should be in the database timezone
+        if timezone.is_aware(dt):
+            # Convert from UTC to database timezone, then make naive
+            dt = timezone.make_naive(dt, timezone.pytz.timezone(db_timezone_name))
+        
+        # Now make it aware in the database timezone
+        dt = timezone.make_aware(dt, timezone.pytz.timezone(db_timezone_name))
+        
+    except (TypeError, ValueError):
+        return None
+    
+    # Convert to target timezone if specified
+    if tzname is not None:
+        dt = timezone.localtime(dt, timezone.pytz.timezone(tzname))
+    return dt
+
+
+def _sqlite_datetime_cast_date_with_db_tz(dt, tzname, db_timezone_name):
+    dt = _sqlite_datetime_parse_with_db_tz(dt, tzname, db_timezone_name)
+    if dt is None:
+        return None
+    return dt.date().isoformat()
+
+
+def _sqlite_datetime_cast_time_with_db_tz(dt, tzname, db_timezone_name):
+    dt = _sqlite_datetime_parse_with_db_tz(dt, tzname, db_timezone_name)
+    if dt is None:
+        return None
+    return dt.time().isoformat()
+
+
+def _sqlite_datetime_extract_with_db_tz(lookup_type, dt, tzname, db_timezone_name):
+    dt = _sqlite_datetime_parse_with_db_tz(dt, tzname, db_timezone_name)
+    if dt is None:
+        return None
+    if lookup_type == 'week_day':
+        return (dt.isoweekday() % 7) + 1
+    elif lookup_type == 'week':
+        return dt.isocalendar()[1]
+    elif lookup_type == 'quarter':
+        return math.ceil(dt.month / 3)
+    elif lookup_type == 'iso_year':
+        return dt.isocalendar()[0]
+    else:
+        return getattr(dt, lookup_type)
+
+
+def _sqlite_datetime_trunc_with_db_tz(lookup_type, dt, tzname, db_timezone_name):
+    dt = _sqlite_datetime_parse_with_db_tz(dt, tzname, db_timezone_name)
+    if dt is None:
+        return None
+    if lookup_type == 'year':
+        return "%i-01-01 00:00:00" % dt.year
+    elif lookup_type == 'quarter':
+        month_in_quarter = dt.month - (dt.month - 1) % 3
+        return '%i-%02i-01 00:00:00' % (dt.year, month_in_quarter)
+    elif lookup_type == 'month':
+        return "%i-%02i-01 00:00:00" % (dt.year, dt.month)
+    elif lookup_type == 'week':
+        dt = dt - datetime.timedelta(days=dt.weekday())
+        return "%i-%02i-%02i 00:00:00" % (dt.year, dt.month, dt.day)
+    elif lookup_type == 'day':
+        return "%i-%02i-%02i 00:00:00" % (dt.year, dt.month, dt.day)
+    elif lookup_type == 'hour':
+        return "%i-%02i-%02i %02i:00:00" % (dt.year, dt.month, dt.day, dt.hour)
+    elif lookup_type == 'minute':
+        return "%i-%02i-%02i %02i:%02i:00" % (dt.year, dt.month, dt.day, dt.hour, dt.minute)
+    elif lookup_type == 'second':
+        return "%i-%02i-%02i %02i:%02i:%02i" % (dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second)
