diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index 9735ce10c8..44c725fc90 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -548,13 +548,87 @@ class Query(BaseExpression):
     def get_count(self, using):
         """
         Perform a COUNT() query using the current filter constraints.
         """
         obj = self.clone()
+        # Clear annotations that are not referenced by filters to optimize the query
+        obj._strip_unused_annotations_for_count()
         obj.add_annotation(Count("*"), alias="__count", is_summary=True)
         return obj.get_aggregation(using, ["__count"])["__count"]
 
+    def _strip_unused_annotations_for_count(self):
+        """
+        Remove annotations that are not referenced by filters or other annotations
+        to optimize count queries. This is similar to how select_related is ignored
+        for count queries.
+        
+        This optimization is conservative and only applies when:
+        1. The query has no WHERE clause references to annotations
+        2. The query is not using values() or values_list() 
+        3. The query is not using distinct()
+        4. The query has no ordering
+        """
+        if not self.annotations:
+            return
+        
+        # Be conservative: only optimize simple cases
+        # Don't optimize if the query uses values/values_list, distinct, or ordering
+        if (getattr(self, 'values_select', None) or 
+            getattr(self, 'distinct', False) or 
+            self.order_by):
+            return
+        
+        # Find annotations that are referenced in WHERE clauses
+        referenced_annotations = self._get_referenced_annotations_in_where()
+        
+        # Keep only annotations that are referenced in filters
+        if referenced_annotations:
+            # Keep only the referenced annotations
+            self.annotations = {
+                alias: annotation 
+                for alias, annotation in self.annotations.items()
+                if alias in referenced_annotations
+            }
+            # Don't clear JOINs when annotations are referenced in WHERE clauses
+        else:
+            # No annotations are referenced in WHERE, so we can clear them all
+            self.annotations = {}
+            
+            # Also clear JOINs that were only added for annotations
+            # Keep only the base table
+            base_table_alias = self.get_initial_alias()
+            self.alias_map = {base_table_alias: self.alias_map[base_table_alias]}
+            self.table_map = {self.model._meta.db_table: [base_table_alias]}
+        
+        # Clear the annotation select mask and cache since we've modified annotations
+        self.annotation_select_mask = None
+        self._annotation_select_cache = None
+
+    def _get_referenced_annotations_in_where(self):
+        """
+        Return a set of annotation aliases that are referenced in WHERE clauses.
+        """
+        referenced = set()
+        
+        def collect_refs(node):
+            if hasattr(node, 'children'):
+                for child in node.children:
+                    collect_refs(child)
+            
+            # Check if this node contains aggregate expressions that match our annotations
+            if hasattr(node, 'lhs') and hasattr(node, 'rhs'):
+                # Check if the lhs is an aggregate expression that matches one of our annotations
+                for alias, annotation in self.annotations.items():
+                    if str(node.lhs) == str(annotation):
+                        referenced.add(alias)
+                        break
+        
+        if self.where:
+            collect_refs(self.where)
+        
+        return referenced
+
     def has_filters(self):
         return self.where
 
     def exists(self, limit=True):
         q = self.clone()
