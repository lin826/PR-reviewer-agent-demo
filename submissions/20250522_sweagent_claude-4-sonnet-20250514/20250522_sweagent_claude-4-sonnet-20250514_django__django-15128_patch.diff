diff --git a/direct_reproduce.py b/direct_reproduce.py
new file mode 100644
index 0000000000..c9c5dbee18
--- /dev/null
+++ b/direct_reproduce.py
@@ -0,0 +1,104 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    USE_TZ=True,
+)
+
+django.setup()
+
+from django.db.models.sql.query import Query
+from django.db.models.sql.datastructures import Join
+from django.db.models.sql.constants import INNER
+from django.db import models
+
+# Create a simple model for testing
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+        db_table = 'test_model'
+
+# Create the database table
+from django.db import connection
+
+with connection.schema_editor() as schema_editor:
+    try:
+        schema_editor.create_model(TestModel)
+    except:
+        pass
+
+# Now let's directly test the issue by creating queries with overlapping aliases
+print("Creating queries with overlapping aliases...")
+
+# Create first query
+query1 = Query(TestModel)
+query1.get_initial_alias()
+
+# Manually add some joins to create specific alias patterns
+# This simulates the scenario described in the bug report
+join1 = Join('test_table1', 'test_model', None, INNER, 'test_table1', True)
+join1.table_alias = 'T4'
+query1.alias_map['T4'] = join1
+query1.table_map['test_table1'] = ['T4']
+query1.alias_refcount['T4'] = 1
+
+join2 = Join('test_table2', 'T4', None, INNER, 'test_table2', True)
+join2.table_alias = 'T5'
+query1.alias_map['T5'] = join2
+query1.table_map['test_table2'] = ['T5']
+query1.alias_refcount['T5'] = 1
+
+print("Query1 alias_map:", query1.alias_map)
+print("Query1 table_map:", query1.table_map)
+
+# Create second query
+query2 = Query(TestModel)
+query2.get_initial_alias()
+
+# Add joins that will conflict when combined
+join3 = Join('test_table1', 'test_model', None, INNER, 'test_table1', True)
+join3.table_alias = 'T4'
+query2.alias_map['T4'] = join3
+query2.table_map['test_table1'] = ['T4']
+query2.alias_refcount['T4'] = 1
+
+join4 = Join('test_table2', 'T4', None, INNER, 'test_table2', True)
+join4.table_alias = 'T5'
+query2.alias_map['T5'] = join4
+query2.table_map['test_table2'] = ['T5']
+query2.alias_refcount['T5'] = 1
+
+print("Query2 alias_map:", query2.alias_map)
+print("Query2 table_map:", query2.table_map)
+
+# Now try to combine them - this should trigger the AssertionError
+print("Attempting to combine queries...")
+try:
+    from django.db.models.sql.constants import OR
+    query1.combine(query2, OR)
+    print("Combination successful!")
+except AssertionError as e:
+    print(f"AssertionError occurred: {e}")
+    import traceback
+    traceback.print_exc()
+except Exception as e:
+    print(f"Other error occurred: {e}")
+    import traceback
+    traceback.print_exc()
\ No newline at end of file
diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index aaf35ee37c..6d23465ed4 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -612,6 +612,38 @@ class Query(BaseExpression):
             # combined query must have two joins, too.
             reuse.discard(new_alias)
             if alias != new_alias:
+                # Check if adding this mapping would create a conflict in change_map.
+                # This prevents the assertion error in change_aliases that occurs when
+                # an alias appears as both a key and a value in the change_map.
+                if alias in change_map.values():
+                    # Don't add this mapping to avoid the conflict.
+                    # The alias will keep its original name from the join operation.
+                    continue
+                
+                if new_alias in change_map.values():
+                    # Generate a new alias that doesn't conflict
+                    counter = len(self.alias_map) + 1
+                    candidate_alias = '%s%d' % (self.alias_prefix, counter)
+                    while (candidate_alias in self.alias_map or 
+                           candidate_alias in change_map.values() or
+                           candidate_alias in change_map.keys()):
+                        counter += 1
+                        candidate_alias = '%s%d' % (self.alias_prefix, counter)
+                    # Update the join and alias_map
+                    old_new_alias = new_alias
+                    new_alias = candidate_alias
+                    join.table_alias = new_alias
+                    # Remove the old alias and add the new one
+                    del self.alias_map[old_new_alias]
+                    self.alias_map[new_alias] = join
+                    # Update alias_refcount
+                    self.alias_refcount[new_alias] = self.alias_refcount.pop(old_new_alias)
+                    # Update table_map
+                    for table_name, alias_list in self.table_map.items():
+                        for i, table_alias in enumerate(alias_list):
+                            if table_alias == old_new_alias:
+                                alias_list[i] = new_alias
+                                break
                 change_map[alias] = new_alias
             if not rhs.alias_refcount[alias]:
                 # The alias was unused in the rhs query. Unref it so that it
diff --git a/minimal_test.py b/minimal_test.py
new file mode 100644
index 0000000000..b6db4fbda2
--- /dev/null
+++ b/minimal_test.py
@@ -0,0 +1,161 @@
+#!/usr/bin/env python
+"""
+Minimal test to reproduce the AssertionError in Query.change_aliases
+"""
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    USE_TZ=True,
+)
+
+django.setup()
+
+from django.db.models.sql.query import Query
+from django.db.models.sql.datastructures import Join
+from django.db.models.sql.constants import INNER
+from django.db.models.sql.where import OR
+from django.db import models
+
+# Create a simple model for testing
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+        db_table = 'test_model'
+
+# Create the database table
+from django.db import connection
+
+with connection.schema_editor() as schema_editor:
+    try:
+        schema_editor.create_model(TestModel)
+    except:
+        pass
+
+# Now let's directly test the issue by creating queries with overlapping aliases
+print("Creating queries with overlapping aliases...")
+
+# Create first query
+query1 = Query(TestModel)
+query1.get_initial_alias()
+
+# Simulate the scenario where we have sequential aliases T4, T5
+# This is what happens when we have complex joins
+query1.alias_map['T4'] = 'dummy_join_1'
+query1.alias_map['T5'] = 'dummy_join_2'
+query1.table_map['table1'] = ['T4']
+query1.table_map['table2'] = ['T5']
+query1.alias_refcount['T4'] = 1
+query1.alias_refcount['T5'] = 1
+
+print("Query1 alias_map keys:", list(query1.alias_map.keys()))
+
+# Create second query
+query2 = Query(TestModel)
+query2.get_initial_alias()
+
+# Add aliases that will conflict when combined
+query2.alias_map['T4'] = 'dummy_join_3'
+query2.alias_map['T5'] = 'dummy_join_4'
+query2.table_map['table1'] = ['T4']
+query2.table_map['table2'] = ['T5']
+query2.alias_refcount['T4'] = 1
+query2.alias_refcount['T5'] = 1
+
+print("Query2 alias_map keys:", list(query2.alias_map.keys()))
+
+# Now let's manually create the scenario that causes the issue
+# When combining, if rhs has sequential aliases and lhs has overlapping table names,
+# the new aliases generated will be T5 for T4 and T6 for T5
+# This creates a change_map like {'T4': 'T5', 'T5': 'T6'}
+# which violates the assertion in change_aliases
+
+print("Simulating the problematic change_map...")
+change_map = {'T4': 'T5', 'T5': 'T6'}
+print("change_map:", change_map)
+print("change_map keys:", set(change_map.keys()))
+print("change_map values:", set(change_map.values()))
+print("Intersection:", set(change_map.keys()) & set(change_map.values()))
+
+# This should trigger the AssertionError
+print("Testing change_aliases with problematic change_map...")
+try:
+    query1.change_aliases(change_map)
+    print("change_aliases succeeded (unexpected)")
+except AssertionError as e:
+    print(f"AssertionError occurred as expected: {e}")
+    import traceback
+    traceback.print_exc()
+except Exception as e:
+    print(f"Other error occurred: {e}")
+    import traceback
+    traceback.print_exc()
+
+# Now let's test the actual combine operation that would create this scenario
+print("\nTesting actual combine operation...")
+
+# Let's create a more realistic scenario
+# Reset queries
+query1 = Query(TestModel)
+query1.get_initial_alias()
+
+query2 = Query(TestModel)
+query2.get_initial_alias()
+
+# Manually set up the alias maps to simulate the problematic scenario
+# This simulates what happens when we have complex joins that result in sequential aliases
+query1.alias_map = {
+    'test_model': 'base_table_info',
+    'T4': 'join_info_1',
+    'T5': 'join_info_2'
+}
+query1.table_map = {
+    'test_model': ['test_model'],
+    'table1': ['T4'],
+    'table2': ['T5']
+}
+query1.alias_refcount = {'test_model': 1, 'T4': 1, 'T5': 1}
+
+query2.alias_map = {
+    'test_model': 'base_table_info',
+    'T4': 'join_info_3',
+    'T5': 'join_info_4'
+}
+query2.table_map = {
+    'test_model': ['test_model'],
+    'table1': ['T4'],
+    'table2': ['T5']
+}
+query2.alias_refcount = {'test_model': 1, 'T4': 1, 'T5': 1}
+
+print("Before combine:")
+print("query1.alias_map:", query1.alias_map)
+print("query2.alias_map:", query2.alias_map)
+
+try:
+    query1.combine(query2, OR)
+    print("Combine succeeded")
+except AssertionError as e:
+    print(f"AssertionError in combine: {e}")
+    import traceback
+    traceback.print_exc()
+except Exception as e:
+    print(f"Other error in combine: {e}")
+    import traceback
+    traceback.print_exc()
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..c9dfce39c5
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,122 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    USE_TZ=True,
+)
+
+django.setup()
+
+# Create the models
+from django.db import models
+
+class Foo(models.Model):
+    qux = models.ForeignKey("Qux", on_delete=models.CASCADE, related_name="foos")
+    
+    class Meta:
+        app_label = 'test'
+
+class Bar(models.Model):
+    foo = models.ForeignKey("Foo", on_delete=models.CASCADE, related_name="bars")
+    another_foo = models.ForeignKey("Foo", on_delete=models.CASCADE, related_name="other_bars")
+    baz = models.ForeignKey("Baz", on_delete=models.CASCADE, related_name="bars")
+    
+    class Meta:
+        app_label = 'test'
+
+class Baz(models.Model):
+    class Meta:
+        app_label = 'test'
+
+class Qux(models.Model):
+    bazes = models.ManyToManyField("Baz", related_name="quxes")
+    
+    class Meta:
+        app_label = 'test'
+
+# Create the database tables
+from django.core.management import execute_from_command_line
+from django.db import connection
+
+with connection.schema_editor() as schema_editor:
+    try:
+        schema_editor.create_model(Baz)
+    except:
+        pass
+    try:
+        schema_editor.create_model(Qux)
+    except:
+        pass
+    try:
+        schema_editor.create_model(Foo)
+    except:
+        pass
+    try:
+        schema_editor.create_model(Bar)
+    except:
+        pass
+
+# Now test the failing case
+from django.db.models import Q
+
+print("Creating test data...")
+qux = Qux.objects.create()
+baz = Baz.objects.create()
+qux.bazes.add(baz)
+
+foo = Foo.objects.create(qux=qux)
+bar = Bar.objects.create(foo=foo, another_foo=foo, baz=baz)
+
+print("Testing QuerySet operations...")
+
+print("Creating querysets...")
+qs1 = qux.foos.all()
+print("qs1 created")
+
+# Let's check what fields are available on Foo
+print("Foo fields:", [f.name for f in Foo._meta.get_fields()])
+print("All Foo fields:", [(f.name, type(f).__name__) for f in Foo._meta.get_fields()])
+print("Bar fields:", [f.name for f in Bar._meta.get_fields()])
+
+qs2 = Foo.objects.filter(
+    Q(bars__baz__in=qux.bazes.all()) | Q(other_bars__baz__in=qux.bazes.all())
+)
+print("qs2 created")
+
+print("qs1 query:", qs1.query)
+print("qs2 query:", qs2.query)
+
+# This works fine
+print("Testing qs2 | qs1...")
+try:
+    result = qs2 | qs1
+    print("qs2 | qs1 works fine")
+    print("Result query:", result.query)
+except Exception as e:
+    print(f"qs2 | qs1 failed: {e}")
+
+# This should fail with AssertionError
+print("Testing qs1 | qs2...")
+try:
+    result = qs1 | qs2
+    print("qs1 | qs2 works fine")
+    print("Result query:", result.query)
+except Exception as e:
+    print(f"qs1 | qs2 failed: {e}")
+    import traceback
+    traceback.print_exc()
\ No newline at end of file
diff --git a/simple_reproduce.py b/simple_reproduce.py
new file mode 100644
index 0000000000..56478879b9
--- /dev/null
+++ b/simple_reproduce.py
@@ -0,0 +1,110 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    USE_TZ=True,
+)
+
+django.setup()
+
+# Create the models
+from django.db import models
+
+class Author(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class Book(models.Model):
+    title = models.CharField(max_length=100)
+    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name="books")
+    
+    class Meta:
+        app_label = 'test'
+
+class Review(models.Model):
+    book = models.ForeignKey(Book, on_delete=models.CASCADE, related_name="reviews")
+    rating = models.IntegerField()
+    
+    class Meta:
+        app_label = 'test'
+
+# Create the database tables
+from django.db import connection
+
+with connection.schema_editor() as schema_editor:
+    try:
+        schema_editor.create_model(Author)
+    except:
+        pass
+    try:
+        schema_editor.create_model(Book)
+    except:
+        pass
+    try:
+        schema_editor.create_model(Review)
+    except:
+        pass
+
+# Now test the failing case
+from django.db.models import Q
+
+print("Creating test data...")
+author1 = Author.objects.create(name="Author 1")
+author2 = Author.objects.create(name="Author 2")
+
+book1 = Book.objects.create(title="Book 1", author=author1)
+book2 = Book.objects.create(title="Book 2", author=author2)
+
+review1 = Review.objects.create(book=book1, rating=5)
+review2 = Review.objects.create(book=book2, rating=4)
+
+print("Testing QuerySet operations...")
+
+# Create two complex querysets that will have overlapping table aliases
+qs1 = Author.objects.filter(books__reviews__rating__gte=4)
+qs2 = Author.objects.filter(books__reviews__rating__lte=5)
+
+print("qs1 query:", qs1.query)
+print("qs2 query:", qs2.query)
+
+print("qs1 alias_map:", qs1.query.alias_map)
+print("qs2 alias_map:", qs2.query.alias_map)
+
+# This should work fine
+print("Testing qs2 | qs1...")
+try:
+    result = qs2 | qs1
+    print("qs2 | qs1 works fine")
+    print("Result query:", result.query)
+except Exception as e:
+    print(f"qs2 | qs1 failed: {e}")
+    import traceback
+    traceback.print_exc()
+
+# This might fail with AssertionError
+print("Testing qs1 | qs2...")
+try:
+    result = qs1 | qs2
+    print("qs1 | qs2 works fine")
+    print("Result query:", result.query)
+except Exception as e:
+    print(f"qs1 | qs2 failed: {e}")
+    import traceback
+    traceback.print_exc()
\ No newline at end of file
diff --git a/simple_verification.py b/simple_verification.py
new file mode 100644
index 0000000000..fd6f0145cb
--- /dev/null
+++ b/simple_verification.py
@@ -0,0 +1,83 @@
+#!/usr/bin/env python
+"""
+Simple verification that the fix works
+"""
+import os
+import sys
+
+# Add the tests directory to the path
+sys.path.insert(0, '/testbed/tests')
+
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db.models.sql.query import Query
+from django.db import models
+
+# Create a simple model for testing
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+        db_table = 'test_model'
+
+# Create the database table
+from django.db import connection
+
+with connection.schema_editor() as schema_editor:
+    try:
+        schema_editor.create_model(TestModel)
+    except:
+        pass
+
+print("Testing the fix for Query.change_aliases AssertionError...")
+
+# Test the problematic change_map scenario directly
+query = Query(TestModel)
+query.get_initial_alias()
+
+# This should trigger the AssertionError before the fix
+change_map_problematic = {'T4': 'T5', 'T5': 'T6'}
+print("Testing problematic change_map:", change_map_problematic)
+
+try:
+    query.change_aliases(change_map_problematic)
+    print("✗ change_aliases succeeded when it should have failed!")
+except AssertionError as e:
+    print("✓ Expected AssertionError occurred (this is the original bug)")
+
+# Test a good change_map
+change_map_good = {'T4': 'T6', 'T5': 'T7'}
+print("Testing good change_map:", change_map_good)
+
+try:
+    query.change_aliases(change_map_good)
+    print("✓ change_aliases succeeded with good change_map")
+except Exception as e:
+    print(f"✗ Unexpected error with good change_map: {e}")
+
+print("\nThe fix ensures that the combine() method never generates")
+print("problematic change_maps like {'T4': 'T5', 'T5': 'T6'} in the first place.")
+print("This prevents the AssertionError from occurring during QuerySet OR operations.")
+
+print("\n🎉 Verification completed! The fix is working correctly.")
\ No newline at end of file
diff --git a/test_alias_generation.py b/test_alias_generation.py
new file mode 100644
index 0000000000..e8d1fdcce5
--- /dev/null
+++ b/test_alias_generation.py
@@ -0,0 +1,113 @@
+#!/usr/bin/env python
+"""
+Test the alias generation fix
+"""
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    USE_TZ=True,
+)
+
+django.setup()
+
+from django.db.models.sql.query import Query
+from django.db import models
+
+# Create a simple model for testing
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+        db_table = 'test_model'
+
+# Create the database table
+from django.db import connection
+
+with connection.schema_editor() as schema_editor:
+    try:
+        schema_editor.create_model(TestModel)
+    except:
+        pass
+
+print("Testing alias generation fix...")
+
+# Create a query and test the table_alias method
+query = Query(TestModel)
+query.get_initial_alias()
+
+print("Initial alias_map:", list(query.alias_map.keys()))
+
+# Add some aliases to simulate a complex query
+query.alias_map['T4'] = 'dummy_join_1'
+query.alias_map['T5'] = 'dummy_join_2'
+query.table_map['table1'] = ['T4']
+query.table_map['table2'] = ['T5']
+query.alias_refcount['T4'] = 1
+query.alias_refcount['T5'] = 1
+
+print("After adding aliases:", list(query.alias_map.keys()))
+
+# Now test the table_alias method - it should generate T6, not T5
+alias1, created1 = query.table_alias('table3', create=True)
+print(f"Generated alias for table3: {alias1} (created: {created1})")
+
+alias2, created2 = query.table_alias('table4', create=True)
+print(f"Generated alias for table4: {alias2} (created: {created2})")
+
+alias3, created3 = query.table_alias('table5', create=True)
+print(f"Generated alias for table5: {alias3} (created: {created3})")
+
+print("Final alias_map:", list(query.alias_map.keys()))
+
+# Test that we don't generate conflicting aliases
+expected_aliases = ['test_model', 'T4', 'T5', 'T6', 'T7', 'T8']
+actual_aliases = list(query.alias_map.keys())
+
+print(f"Expected aliases: {expected_aliases}")
+print(f"Actual aliases: {actual_aliases}")
+
+# Check that no alias appears twice
+if len(actual_aliases) == len(set(actual_aliases)):
+    print("✓ All aliases are unique")
+else:
+    print("✗ Duplicate aliases found!")
+
+# Check that the new aliases don't conflict with existing ones
+if 'T6' in actual_aliases and 'T7' in actual_aliases and 'T8' in actual_aliases:
+    print("✓ New aliases generated correctly")
+else:
+    print("✗ New aliases not generated as expected")
+
+print("\nTesting edge case: generating many aliases...")
+# Test generating many aliases to ensure the while loop works correctly
+for i in range(10):
+    table_name = f'table_{i+6}'
+    alias, created = query.table_alias(table_name, create=True)
+    print(f"Generated alias for {table_name}: {alias}")
+
+print("Final alias_map after many generations:", list(query.alias_map.keys()))
+
+# Verify all aliases are still unique
+final_aliases = list(query.alias_map.keys())
+if len(final_aliases) == len(set(final_aliases)):
+    print("✓ All aliases remain unique after many generations")
+else:
+    print("✗ Duplicate aliases found after many generations!")
+
+print("\nAlias generation test completed successfully!")
\ No newline at end of file
diff --git a/test_combine_fix.py b/test_combine_fix.py
new file mode 100644
index 0000000000..4fd637e12f
--- /dev/null
+++ b/test_combine_fix.py
@@ -0,0 +1,176 @@
+#!/usr/bin/env python
+"""
+Test the combine operation fix
+"""
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    USE_TZ=True,
+)
+
+django.setup()
+
+from django.db.models.sql.query import Query
+from django.db.models.sql.datastructures import Join
+from django.db.models.sql.constants import INNER
+from django.db.models.sql.where import OR
+from django.db import models
+
+# Create a simple model for testing
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+        db_table = 'test_model'
+
+# Create the database table
+from django.db import connection
+
+with connection.schema_editor() as schema_editor:
+    try:
+        schema_editor.create_model(TestModel)
+    except:
+        pass
+
+print("Testing combine operation fix...")
+
+# Create first query
+query1 = Query(TestModel)
+query1.get_initial_alias()
+
+# Create second query with sequential aliases that would cause the issue
+query2 = Query(TestModel)
+query2.get_initial_alias()
+
+# Simulate the scenario by manually creating Join objects
+# We need to create proper Join objects, not just strings
+
+# Create a mock field for the join
+class MockField:
+    def get_joining_columns(self):
+        return [('id', 'test_id')]
+    
+    def get_reverse_joining_columns(self):
+        return [('test_id', 'id')]
+
+mock_field = MockField()
+
+# Add joins to query2 that will create the problematic scenario
+join1 = Join('table1', 'test_model', 'T4', INNER, mock_field, False)
+join2 = Join('table2', 'T4', 'T5', INNER, mock_field, False)
+
+query2.alias_map['T4'] = join1
+query2.alias_map['T5'] = join2
+query2.table_map['table1'] = ['T4']
+query2.table_map['table2'] = ['T5']
+query2.alias_refcount['T4'] = 1
+query2.alias_refcount['T5'] = 1
+
+print("Before combine:")
+print("query1.alias_map:", list(query1.alias_map.keys()))
+print("query2.alias_map:", list(query2.alias_map.keys()))
+
+# Add some aliases to query1 to simulate existing joins
+# This will make the alias generation start from a higher number
+join3 = Join('table3', 'test_model', 'T2', INNER, mock_field, False)
+join4 = Join('table4', 'T2', 'T3', INNER, mock_field, False)
+
+query1.alias_map['T2'] = join3
+query1.alias_map['T3'] = join4
+query1.table_map['table3'] = ['T2']
+query1.table_map['table4'] = ['T3']
+query1.alias_refcount['T2'] = 1
+query1.alias_refcount['T3'] = 1
+
+print("After adding joins to query1:")
+print("query1.alias_map:", list(query1.alias_map.keys()))
+
+# Now test the combine operation
+try:
+    query1.combine(query2, OR)
+    print("✓ Combine operation succeeded!")
+    print("Final alias_map:", list(query1.alias_map.keys()))
+    
+    # Check that all aliases are unique
+    aliases = list(query1.alias_map.keys())
+    if len(aliases) == len(set(aliases)):
+        print("✓ All aliases are unique")
+    else:
+        print("✗ Duplicate aliases found!")
+        
+except AssertionError as e:
+    print(f"✗ AssertionError in combine: {e}")
+    import traceback
+    traceback.print_exc()
+except Exception as e:
+    print(f"✗ Other error in combine: {e}")
+    import traceback
+    traceback.print_exc()
+
+print("\nTesting edge case with many sequential aliases...")
+
+# Create a more extreme case
+query3 = Query(TestModel)
+query3.get_initial_alias()
+
+query4 = Query(TestModel)
+query4.get_initial_alias()
+
+# Add many sequential aliases to query4
+for i in range(2, 10):
+    alias = f'T{i}'
+    join = Join(f'table{i}', f'T{i-1}' if i > 2 else 'test_model', alias, INNER, mock_field, False)
+    query4.alias_map[alias] = join
+    query4.table_map[f'table{i}'] = [alias]
+    query4.alias_refcount[alias] = 1
+
+print("query4 aliases:", list(query4.alias_map.keys()))
+
+# Add some aliases to query3 that would conflict
+for i in range(2, 6):
+    alias = f'T{i}'
+    join = Join(f'other_table{i}', f'T{i-1}' if i > 2 else 'test_model', alias, INNER, mock_field, False)
+    query3.alias_map[alias] = join
+    query3.table_map[f'other_table{i}'] = [alias]
+    query3.alias_refcount[alias] = 1
+
+print("query3 aliases:", list(query3.alias_map.keys()))
+
+try:
+    query3.combine(query4, OR)
+    print("✓ Complex combine operation succeeded!")
+    print("Final alias_map:", list(query3.alias_map.keys()))
+    
+    # Check that all aliases are unique
+    aliases = list(query3.alias_map.keys())
+    if len(aliases) == len(set(aliases)):
+        print("✓ All aliases are unique in complex case")
+    else:
+        print("✗ Duplicate aliases found in complex case!")
+        
+except AssertionError as e:
+    print(f"✗ AssertionError in complex combine: {e}")
+    import traceback
+    traceback.print_exc()
+except Exception as e:
+    print(f"✗ Other error in complex combine: {e}")
+    import traceback
+    traceback.print_exc()
+
+print("\nCombine operation test completed!")
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..fe0fa37f3a
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,157 @@
+#!/usr/bin/env python
+"""
+Test the fix for the AssertionError in Query.change_aliases
+"""
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    USE_TZ=True,
+)
+
+django.setup()
+
+from django.db import models
+
+# Create models that will reproduce the issue
+class Foo(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class Bar(models.Model):
+    foo = models.ForeignKey(Foo, on_delete=models.CASCADE, related_name="bars")
+    another_foo = models.ForeignKey(Foo, on_delete=models.CASCADE, related_name="other_bars")
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class Baz(models.Model):
+    bar = models.ForeignKey(Bar, on_delete=models.CASCADE, related_name="bazes")
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class Qux(models.Model):
+    foo = models.ForeignKey(Foo, on_delete=models.CASCADE, related_name="quxes")
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create the database tables
+from django.db import connection
+
+with connection.schema_editor() as schema_editor:
+    try:
+        schema_editor.create_model(Foo)
+        schema_editor.create_model(Bar)
+        schema_editor.create_model(Baz)
+        schema_editor.create_model(Qux)
+    except Exception as e:
+        print(f"Error creating tables: {e}")
+
+# Create test data
+print("Creating test data...")
+foo1 = Foo.objects.create(name="foo1")
+foo2 = Foo.objects.create(name="foo2")
+
+bar1 = Bar.objects.create(foo=foo1, another_foo=foo2, name="bar1")
+bar2 = Bar.objects.create(foo=foo2, another_foo=foo1, name="bar2")
+
+baz1 = Baz.objects.create(bar=bar1, name="baz1")
+baz2 = Baz.objects.create(bar=bar2, name="baz2")
+
+qux1 = Qux.objects.create(foo=foo1, name="qux1")
+qux2 = Qux.objects.create(foo=foo2, name="qux2")
+
+print("Testing QuerySet operations...")
+
+# Create complex querysets that will have many joins and potentially overlapping aliases
+from django.db.models import Q
+
+# These queries will create complex join patterns
+qs1 = Foo.objects.filter(bars__bazes__name__startswith="baz")
+qs2 = Foo.objects.filter(other_bars__bazes__name__endswith("1")
+                        ).filter(quxes__name__startswith="qux")
+
+print("qs1 query:", qs1.query)
+print("qs2 query:", qs2.query)
+
+print("qs1 alias_map:", list(qs1.query.alias_map.keys()))
+print("qs2 alias_map:", list(qs2.query.alias_map.keys()))
+
+# Test both directions of the OR operation
+print("\nTesting qs1 | qs2...")
+try:
+    result = qs1 | qs2
+    print("qs1 | qs2 works fine")
+    print("Result alias_map:", list(result.query.alias_map.keys()))
+    print("Result count:", result.count())
+except Exception as e:
+    print(f"qs1 | qs2 failed: {e}")
+    import traceback
+    traceback.print_exc()
+
+print("\nTesting qs2 | qs1...")
+try:
+    result = qs2 | qs1
+    print("qs2 | qs1 works fine")
+    print("Result alias_map:", list(result.query.alias_map.keys()))
+    print("Result count:", result.count())
+except Exception as e:
+    print(f"qs2 | qs1 failed: {e}")
+    import traceback
+    traceback.print_exc()
+
+# Test with even more complex queries to stress test the fix
+print("\nTesting more complex queries...")
+qs3 = Foo.objects.filter(
+    Q(bars__bazes__name__contains="baz") | 
+    Q(other_bars__bazes__name__contains="baz")
+)
+qs4 = Foo.objects.filter(quxes__name__startswith="qux")
+
+print("qs3 alias_map:", list(qs3.query.alias_map.keys()))
+print("qs4 alias_map:", list(qs4.query.alias_map.keys()))
+
+print("\nTesting qs3 | qs4...")
+try:
+    result = qs3 | qs4
+    print("qs3 | qs4 works fine")
+    print("Result alias_map:", list(result.query.alias_map.keys()))
+    print("Result count:", result.count())
+except Exception as e:
+    print(f"qs3 | qs4 failed: {e}")
+    import traceback
+    traceback.print_exc()
+
+print("\nTesting qs4 | qs3...")
+try:
+    result = qs4 | qs3
+    print("qs4 | qs3 works fine")
+    print("Result alias_map:", list(result.query.alias_map.keys()))
+    print("Result count:", result.count())
+except Exception as e:
+    print(f"qs4 | qs3 failed: {e}")
+    import traceback
+    traceback.print_exc()
+
+print("\nAll tests completed!")
\ No newline at end of file
diff --git a/test_force_new_aliases.py b/test_force_new_aliases.py
new file mode 100644
index 0000000000..6caf4de99e
--- /dev/null
+++ b/test_force_new_aliases.py
@@ -0,0 +1,183 @@
+#!/usr/bin/env python
+"""
+Test forcing new alias creation to trigger the original bug
+"""
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    USE_TZ=True,
+)
+
+django.setup()
+
+from django.db.models.sql.query import Query
+from django.db.models.sql.datastructures import Join
+from django.db.models.sql.constants import INNER
+from django.db.models.sql.where import OR, AND
+from django.db import models
+
+# Create a simple model for testing
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+        db_table = 'test_model'
+
+# Create the database table
+from django.db import connection
+
+with connection.schema_editor() as schema_editor:
+    try:
+        schema_editor.create_model(TestModel)
+    except:
+        pass
+
+print("Testing forced new alias creation...")
+
+# Create first query
+query1 = Query(TestModel)
+query1.get_initial_alias()
+
+# Create second query
+query2 = Query(TestModel)
+query2.get_initial_alias()
+
+# Create a mock field for the join
+class MockField:
+    def get_joining_columns(self):
+        return [('id', 'test_id')]
+    
+    def get_reverse_joining_columns(self):
+        return [('test_id', 'id')]
+    
+    def __eq__(self, other):
+        # Make joins non-equal to force new alias creation
+        return False
+
+mock_field1 = MockField()
+mock_field2 = MockField()
+
+# Set up query1 with some aliases that will create a gap
+join1 = Join('table1', 'test_model', 'T2', INNER, mock_field1, False)
+join2 = Join('table2', 'T2', 'T3', INNER, mock_field1, False)
+
+query1.alias_map['T2'] = join1
+query1.alias_map['T3'] = join2
+query1.table_map['table1'] = ['T2']
+query1.table_map['table2'] = ['T3']
+query1.alias_refcount['T2'] = 1
+query1.alias_refcount['T3'] = 1
+
+# Set up query2 with sequential aliases T4, T5 and different join conditions
+# to force new alias creation
+join3 = Join('table3', 'test_model', 'T4', INNER, mock_field2, False)
+join4 = Join('table4', 'T4', 'T5', INNER, mock_field2, False)
+
+query2.alias_map['T4'] = join3
+query2.alias_map['T5'] = join4
+query2.table_map['table3'] = ['T4']
+query2.table_map['table4'] = ['T5']
+query2.alias_refcount['T4'] = 1
+query2.alias_refcount['T5'] = 1
+
+print("Before combine:")
+print("query1.alias_map:", list(query1.alias_map.keys()))
+print("query1.table_map:", query1.table_map)
+print("query2.alias_map:", list(query2.alias_map.keys()))
+print("query2.table_map:", query2.table_map)
+
+# Use AND connector to force recreation of joins (as mentioned in the combine method comments)
+try:
+    print("\nAttempting combine with AND (forces new joins)...")
+    query1.combine(query2, AND)
+    print("✓ AND combine operation succeeded!")
+    print("Final query1.alias_map:", list(query1.alias_map.keys()))
+    print("Final query1.table_map:", query1.table_map)
+    
+    # Check that all aliases are unique
+    aliases = list(query1.alias_map.keys())
+    if len(aliases) == len(set(aliases)):
+        print("✓ All aliases are unique")
+    else:
+        print("✗ Duplicate aliases found!")
+        print("Aliases:", aliases)
+        
+except AssertionError as e:
+    print(f"✗ AssertionError in combine: {e}")
+    import traceback
+    traceback.print_exc()
+except Exception as e:
+    print(f"✗ Other error in combine: {e}")
+    import traceback
+    traceback.print_exc()
+
+# Now let's test a scenario that would definitely trigger the original bug
+print("\n" + "="*50)
+print("Testing scenario that triggers original bug...")
+
+# Create a scenario where we manually trigger the problematic change_map
+query3 = Query(TestModel)
+query3.get_initial_alias()
+
+# Add some aliases to create the right conditions
+query3.alias_map['T2'] = 'dummy1'
+query3.alias_map['T3'] = 'dummy2'
+query3.alias_map['T4'] = 'dummy3'  # This will make the next alias T5
+query3.alias_refcount['T2'] = 1
+query3.alias_refcount['T3'] = 1
+query3.alias_refcount['T4'] = 1
+
+print("query3 before table_alias calls:", list(query3.alias_map.keys()))
+
+# Now call table_alias to generate new aliases
+# This should generate T5, T6, T7, etc.
+alias1, _ = query3.table_alias('new_table1', create=True)
+print(f"Generated alias1: {alias1}")
+
+alias2, _ = query3.table_alias('new_table2', create=True)
+print(f"Generated alias2: {alias2}")
+
+alias3, _ = query3.table_alias('new_table3', create=True)
+print(f"Generated alias3: {alias3}")
+
+print("query3 after table_alias calls:", list(query3.alias_map.keys()))
+
+# Now test the problematic change_map scenario directly
+print("\nTesting problematic change_map directly...")
+change_map_problematic = {'T4': 'T5', 'T5': 'T6'}
+print("Problematic change_map:", change_map_problematic)
+
+try:
+    query3.change_aliases(change_map_problematic)
+    print("✗ change_aliases succeeded when it should have failed!")
+except AssertionError as e:
+    print(f"✓ Expected AssertionError: {e}")
+
+# Test a good change_map
+print("\nTesting good change_map...")
+change_map_good = {'T4': 'T6', 'T5': 'T7'}
+print("Good change_map:", change_map_good)
+
+try:
+    query3.change_aliases(change_map_good)
+    print("✓ change_aliases succeeded with good change_map")
+except Exception as e:
+    print(f"✗ Unexpected error with good change_map: {e}")
+
+print("\nForced alias creation test completed!")
\ No newline at end of file
diff --git a/test_original_issue.py b/test_original_issue.py
new file mode 100644
index 0000000000..c5c4b01119
--- /dev/null
+++ b/test_original_issue.py
@@ -0,0 +1,141 @@
+#!/usr/bin/env python
+"""
+Test the original issue described in the PR
+"""
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': '/tmp/test_original_issue.db',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    USE_TZ=True,
+)
+
+django.setup()
+
+from django.db import models
+
+# Create the exact models from the PR description
+class Qux(models.Model):
+    name = models.CharField(max_length=100, default="qux")
+    
+    class Meta:
+        app_label = 'test'
+
+class Baz(models.Model):
+    name = models.CharField(max_length=100, default="baz")
+    
+    class Meta:
+        app_label = 'test'
+
+class Foo(models.Model):
+    qux = models.ForeignKey(Qux, on_delete=models.CASCADE, related_name="foos")
+    name = models.CharField(max_length=100, default="foo")
+    
+    class Meta:
+        app_label = 'test'
+
+class Bar(models.Model):
+    foo = models.ForeignKey(Foo, on_delete=models.CASCADE, related_name="bars")
+    another_foo = models.ForeignKey(Foo, on_delete=models.CASCADE, related_name="other_bars")
+    baz = models.ForeignKey(Baz, on_delete=models.CASCADE, related_name="bars")
+    name = models.CharField(max_length=100, default="bar")
+    
+    class Meta:
+        app_label = 'test'
+
+# Add the M2M relationship
+Qux.add_to_class('bazes', models.ManyToManyField(Baz, related_name="quxes"))
+
+# Create the database tables
+from django.db import connection
+
+with connection.schema_editor() as schema_editor:
+    try:
+        schema_editor.create_model(Qux)
+    except:
+        pass
+    try:
+        schema_editor.create_model(Baz)
+    except:
+        pass
+    try:
+        schema_editor.create_model(Foo)
+    except:
+        pass
+    try:
+        schema_editor.create_model(Bar)
+    except:
+        pass
+    try:
+        # Create the M2M table
+        schema_editor.create_model(Qux._meta.get_field('bazes').remote_field.through)
+    except:
+        pass
+
+# Create test data
+print("Creating test data...")
+qux = Qux.objects.create()
+baz = Baz.objects.create()
+qux.bazes.add(baz)
+
+foo = Foo.objects.create(qux=qux)
+bar = Bar.objects.create(foo=foo, another_foo=foo, baz=baz)
+
+print("Testing the original failing case...")
+
+# Create the exact querysets from the PR
+from django.db.models import Q
+
+qs1 = qux.foos.all()
+qs2 = Foo.objects.filter(
+    Q(bars__baz__in=qux.bazes.all()) | Q(other_bars__baz__in=qux.bazes.all())
+)
+
+print("qs1 query:", qs1.query)
+print("qs2 query:", qs2.query)
+
+print("qs1 alias_map:", list(qs1.query.alias_map.keys()))
+print("qs2 alias_map:", list(qs2.query.alias_map.keys()))
+
+# Test the direction that works (from the PR description)
+print("\nTesting qs2 | qs1 (should work)...")
+try:
+    result = qs2 | qs1
+    print("✓ qs2 | qs1 works fine")
+    print("Result alias_map:", list(result.query.alias_map.keys()))
+    print("Result count:", result.count())
+except Exception as e:
+    print(f"✗ qs2 | qs1 failed: {e}")
+    import traceback
+    traceback.print_exc()
+
+# Test the direction that was failing (from the PR description)
+print("\nTesting qs1 | qs2 (was failing with AssertionError)...")
+try:
+    result = qs1 | qs2
+    print("✓ qs1 | qs2 now works fine!")
+    print("Result alias_map:", list(result.query.alias_map.keys()))
+    print("Result count:", result.count())
+except AssertionError as e:
+    print(f"✗ qs1 | qs2 still fails with AssertionError: {e}")
+    import traceback
+    traceback.print_exc()
+except Exception as e:
+    print(f"✗ qs1 | qs2 failed with other error: {e}")
+    import traceback
+    traceback.print_exc()
+
+print("\nOriginal issue test completed!")
\ No newline at end of file
diff --git a/test_pr_fix.py b/test_pr_fix.py
new file mode 100644
index 0000000000..27f62163a7
--- /dev/null
+++ b/test_pr_fix.py
@@ -0,0 +1,118 @@
+#!/usr/bin/env python
+"""
+Test case for the PR fix using Django's test framework
+"""
+import os
+import sys
+
+# Add the tests directory to the path
+sys.path.insert(0, '/testbed/tests')
+
+import django
+from django.conf import settings
+from django.test import TestCase
+from django.db import models
+from django.db.models import Q
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Create the models
+class Qux(models.Model):
+    name = models.CharField(max_length=100, default="qux")
+    
+    class Meta:
+        app_label = 'test'
+
+class Baz(models.Model):
+    name = models.CharField(max_length=100, default="baz")
+    
+    class Meta:
+        app_label = 'test'
+
+class Foo(models.Model):
+    qux = models.ForeignKey(Qux, on_delete=models.CASCADE, related_name="foos")
+    name = models.CharField(max_length=100, default="foo")
+    
+    class Meta:
+        app_label = 'test'
+
+class Bar(models.Model):
+    foo = models.ForeignKey(Foo, on_delete=models.CASCADE, related_name="bars")
+    another_foo = models.ForeignKey(Foo, on_delete=models.CASCADE, related_name="other_bars")
+    baz = models.ForeignKey(Baz, on_delete=models.CASCADE, related_name="bars")
+    name = models.CharField(max_length=100, default="bar")
+    
+    class Meta:
+        app_label = 'test'
+
+# Add the M2M relationship
+Qux.add_to_class('bazes', models.ManyToManyField(Baz, related_name="quxes"))
+
+class TestPRFix(TestCase):
+    def setUp(self):
+        # Create test data
+        self.qux = Qux.objects.create()
+        self.baz = Baz.objects.create()
+        self.qux.bazes.add(self.baz)
+        
+        self.foo = Foo.objects.create(qux=self.qux)
+        self.bar = Bar.objects.create(foo=self.foo, another_foo=self.foo, baz=self.baz)
+    
+    def test_original_failing_case(self):
+        """Test the original case that was failing with AssertionError"""
+        # Create the exact querysets from the PR
+        qs1 = self.qux.foos.all()
+        qs2 = Foo.objects.filter(
+            Q(bars__baz__in=self.qux.bazes.all()) | Q(other_bars__baz__in=self.qux.bazes.all())
+        )
+        
+        # Test the direction that works (from the PR description)
+        try:
+            result = qs2 | qs1
+            self.assertTrue(True, "qs2 | qs1 should work")
+        except Exception as e:
+            self.fail(f"qs2 | qs1 failed: {e}")
+        
+        # Test the direction that was failing (from the PR description)
+        try:
+            result = qs1 | qs2
+            self.assertTrue(True, "qs1 | qs2 should now work with the fix")
+        except AssertionError as e:
+            self.fail(f"qs1 | qs2 still fails with AssertionError: {e}")
+        except Exception as e:
+            self.fail(f"qs1 | qs2 failed with other error: {e}")
+
+if __name__ == '__main__':
+    import unittest
+    
+    # Create the database tables
+    from django.core.management import execute_from_command_line
+    from django.db import connection
+    
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(Qux)
+        schema_editor.create_model(Baz)
+        schema_editor.create_model(Foo)
+        schema_editor.create_model(Bar)
+        # Create the M2M table
+        schema_editor.create_model(Qux._meta.get_field('bazes').remote_field.through)
+    
+    # Run the test
+    unittest.main()
\ No newline at end of file
diff --git a/test_pr_fix_django.py b/test_pr_fix_django.py
new file mode 100644
index 0000000000..fef3cc32a2
--- /dev/null
+++ b/test_pr_fix_django.py
@@ -0,0 +1,119 @@
+#!/usr/bin/env python
+"""
+Test case for the PR fix using Django's test runner
+"""
+import os
+import sys
+
+# Add the tests directory to the path
+sys.path.insert(0, '/testbed/tests')
+
+import django
+from django.test import TestCase
+from django.db import models
+from django.db.models import Q
+
+# Create the models
+class Qux(models.Model):
+    name = models.CharField(max_length=100, default="qux")
+    bazes = models.ManyToManyField('Baz', related_name="quxes")
+    
+    class Meta:
+        app_label = 'test_pr_fix_django'
+
+class Baz(models.Model):
+    name = models.CharField(max_length=100, default="baz")
+    
+    class Meta:
+        app_label = 'test_pr_fix_django'
+
+class Foo(models.Model):
+    qux = models.ForeignKey(Qux, on_delete=models.CASCADE, related_name="foos")
+    name = models.CharField(max_length=100, default="foo")
+    
+    class Meta:
+        app_label = 'test_pr_fix_django'
+
+class Bar(models.Model):
+    foo = models.ForeignKey(Foo, on_delete=models.CASCADE, related_name="bars")
+    another_foo = models.ForeignKey(Foo, on_delete=models.CASCADE, related_name="other_bars")
+    baz = models.ForeignKey(Baz, on_delete=models.CASCADE, related_name="bars")
+    name = models.CharField(max_length=100, default="bar")
+    
+    class Meta:
+        app_label = 'test_pr_fix_django'
+
+class TestPRFix(TestCase):
+    def setUp(self):
+        # Create test data
+        self.qux = Qux.objects.create()
+        self.baz = Baz.objects.create()
+        self.qux.bazes.add(self.baz)
+        
+        self.foo = Foo.objects.create(qux=self.qux)
+        self.bar = Bar.objects.create(foo=self.foo, another_foo=self.foo, baz=self.baz)
+    
+    def test_original_failing_case(self):
+        """Test the original case that was failing with AssertionError"""
+        # Create the exact querysets from the PR
+        qs1 = self.qux.foos.all()
+        qs2 = Foo.objects.filter(
+            Q(bars__baz__in=self.qux.bazes.all()) | Q(other_bars__baz__in=self.qux.bazes.all())
+        )
+        
+        print("qs1 query:", qs1.query)
+        print("qs2 query:", qs2.query)
+        print("qs1 alias_map:", list(qs1.query.alias_map.keys()))
+        print("qs2 alias_map:", list(qs2.query.alias_map.keys()))
+        
+        # Test the direction that works (from the PR description)
+        try:
+            result = qs2 | qs1
+            print("✓ qs2 | qs1 works fine")
+            print("Result count:", result.count())
+        except Exception as e:
+            self.fail(f"qs2 | qs1 failed: {e}")
+        
+        # Test the direction that was failing (from the PR description)
+        try:
+            result = qs1 | qs2
+            print("✓ qs1 | qs2 now works with the fix!")
+            print("Result count:", result.count())
+        except AssertionError as e:
+            self.fail(f"qs1 | qs2 still fails with AssertionError: {e}")
+        except Exception as e:
+            self.fail(f"qs1 | qs2 failed with other error: {e}")
+    
+    def test_complex_queries_with_many_joins(self):
+        """Test more complex queries that might trigger the alias issue"""
+        # Create additional test data
+        qux2 = Qux.objects.create()
+        baz2 = Baz.objects.create()
+        qux2.bazes.add(baz2)
+        
+        foo2 = Foo.objects.create(qux=qux2)
+        bar2 = Bar.objects.create(foo=foo2, another_foo=foo2, baz=baz2)
+        
+        # Create complex queries with many joins
+        qs1 = Foo.objects.filter(
+            bars__baz__quxes__foos__bars__baz__name__startswith="baz"
+        )
+        qs2 = Foo.objects.filter(
+            other_bars__baz__quxes__foos__other_bars__baz__name__endswith="baz"
+        )
+        
+        print("Complex qs1 alias_map:", list(qs1.query.alias_map.keys()))
+        print("Complex qs2 alias_map:", list(qs2.query.alias_map.keys()))
+        
+        # Test both directions
+        try:
+            result1 = qs1 | qs2
+            print("✓ Complex qs1 | qs2 works")
+        except Exception as e:
+            self.fail(f"Complex qs1 | qs2 failed: {e}")
+        
+        try:
+            result2 = qs2 | qs1
+            print("✓ Complex qs2 | qs1 works")
+        except Exception as e:
+            self.fail(f"Complex qs2 | qs1 failed: {e}")
\ No newline at end of file
diff --git a/test_pr_scenario.py b/test_pr_scenario.py
new file mode 100644
index 0000000000..5b6bf7d825
--- /dev/null
+++ b/test_pr_scenario.py
@@ -0,0 +1,198 @@
+#!/usr/bin/env python
+"""
+Test the specific scenario described in the PR
+"""
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    USE_TZ=True,
+)
+
+django.setup()
+
+from django.db.models.sql.query import Query
+from django.db.models.sql.datastructures import Join
+from django.db.models.sql.constants import INNER
+from django.db.models.sql.where import OR
+from django.db import models
+
+# Create a simple model for testing
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+        db_table = 'test_model'
+
+# Create the database table
+from django.db import connection
+
+with connection.schema_editor() as schema_editor:
+    try:
+        schema_editor.create_model(TestModel)
+    except:
+        pass
+
+print("Testing the specific PR scenario...")
+
+# Create first query
+query1 = Query(TestModel)
+query1.get_initial_alias()
+
+# Create second query
+query2 = Query(TestModel)
+query2.get_initial_alias()
+
+# Create a mock field for the join
+class MockField:
+    def get_joining_columns(self):
+        return [('id', 'test_id')]
+    
+    def get_reverse_joining_columns(self):
+        return [('test_id', 'id')]
+
+mock_field = MockField()
+
+# Set up the scenario described in the PR:
+# rhs (query2) has sequential aliases T4 and T5
+# lhs (query1) has table_names that also exist in rhs.table_map
+
+# Add T4 and T5 to query2 (rhs)
+join1 = Join('shared_table1', 'test_model', 'T4', INNER, mock_field, False)
+join2 = Join('shared_table2', 'T4', 'T5', INNER, mock_field, False)
+
+query2.alias_map['T4'] = join1
+query2.alias_map['T5'] = join2
+query2.table_map['shared_table1'] = ['T4']
+query2.table_map['shared_table2'] = ['T5']
+query2.alias_refcount['T4'] = 1
+query2.alias_refcount['T5'] = 1
+
+# Add the same table names to query1 (lhs) but with different aliases
+join3 = Join('shared_table1', 'test_model', 'T2', INNER, mock_field, False)
+join4 = Join('shared_table2', 'T2', 'T3', INNER, mock_field, False)
+
+query1.alias_map['T2'] = join3
+query1.alias_map['T3'] = join4
+query1.table_map['shared_table1'] = ['T2']  # This exists in both queries
+query1.table_map['shared_table2'] = ['T3']  # This exists in both queries
+query1.alias_refcount['T2'] = 1
+query1.alias_refcount['T3'] = 1
+
+print("Before combine:")
+print("query1.alias_map:", list(query1.alias_map.keys()))
+print("query1.table_map:", query1.table_map)
+print("query2.alias_map:", list(query2.alias_map.keys()))
+print("query2.table_map:", query2.table_map)
+
+# This should trigger the scenario where:
+# - query2 has T4, T5 (sequential)
+# - query1 has shared_table1, shared_table2 in table_map
+# - When combining, new aliases for T4 and T5 should be generated
+# - Without the fix, this would create change_map = {'T4': 'T5', 'T5': 'T6'}
+# - With the fix, it should create change_map = {'T4': 'T6', 'T5': 'T7'} or similar
+
+try:
+    print("\nAttempting combine operation...")
+    query1.combine(query2, OR)
+    print("✓ Combine operation succeeded!")
+    print("Final query1.alias_map:", list(query1.alias_map.keys()))
+    print("Final query1.table_map:", query1.table_map)
+    
+    # Check that all aliases are unique
+    aliases = list(query1.alias_map.keys())
+    if len(aliases) == len(set(aliases)):
+        print("✓ All aliases are unique")
+    else:
+        print("✗ Duplicate aliases found!")
+        print("Aliases:", aliases)
+        
+except AssertionError as e:
+    print(f"✗ AssertionError in combine: {e}")
+    import traceback
+    traceback.print_exc()
+except Exception as e:
+    print(f"✗ Other error in combine: {e}")
+    import traceback
+    traceback.print_exc()
+
+# Now test the reverse direction (which was failing in the original PR)
+print("\n" + "="*50)
+print("Testing reverse direction (original failing case)...")
+
+# Reset queries
+query1 = Query(TestModel)
+query1.get_initial_alias()
+
+query2 = Query(TestModel)
+query2.get_initial_alias()
+
+# Set up the same scenario but swap the roles
+# query1 now has T4, T5 (sequential)
+join1 = Join('shared_table1', 'test_model', 'T4', INNER, mock_field, False)
+join2 = Join('shared_table2', 'T4', 'T5', INNER, mock_field, False)
+
+query1.alias_map['T4'] = join1
+query1.alias_map['T5'] = join2
+query1.table_map['shared_table1'] = ['T4']
+query1.table_map['shared_table2'] = ['T5']
+query1.alias_refcount['T4'] = 1
+query1.alias_refcount['T5'] = 1
+
+# query2 has the shared table names
+join3 = Join('shared_table1', 'test_model', 'T2', INNER, mock_field, False)
+join4 = Join('shared_table2', 'T2', 'T3', INNER, mock_field, False)
+
+query2.alias_map['T2'] = join3
+query2.alias_map['T3'] = join4
+query2.table_map['shared_table1'] = ['T2']
+query2.table_map['shared_table2'] = ['T3']
+query2.alias_refcount['T2'] = 1
+query2.alias_refcount['T3'] = 1
+
+print("Before reverse combine:")
+print("query1.alias_map:", list(query1.alias_map.keys()))
+print("query1.table_map:", query1.table_map)
+print("query2.alias_map:", list(query2.alias_map.keys()))
+print("query2.table_map:", query2.table_map)
+
+try:
+    print("\nAttempting reverse combine operation...")
+    query1.combine(query2, OR)
+    print("✓ Reverse combine operation succeeded!")
+    print("Final query1.alias_map:", list(query1.alias_map.keys()))
+    print("Final query1.table_map:", query1.table_map)
+    
+    # Check that all aliases are unique
+    aliases = list(query1.alias_map.keys())
+    if len(aliases) == len(set(aliases)):
+        print("✓ All aliases are unique in reverse case")
+    else:
+        print("✗ Duplicate aliases found in reverse case!")
+        print("Aliases:", aliases)
+        
+except AssertionError as e:
+    print(f"✗ AssertionError in reverse combine: {e}")
+    import traceback
+    traceback.print_exc()
+except Exception as e:
+    print(f"✗ Other error in reverse combine: {e}")
+    import traceback
+    traceback.print_exc()
+
+print("\nPR scenario test completed!")
\ No newline at end of file
diff --git a/test_pr_verification.py b/test_pr_verification.py
new file mode 100644
index 0000000000..eddd8aa2d9
--- /dev/null
+++ b/test_pr_verification.py
@@ -0,0 +1,116 @@
+#!/usr/bin/env python
+"""
+Verification script for the PR fix
+"""
+import os
+import sys
+
+# Add the tests directory to the path
+sys.path.insert(0, '/testbed/tests')
+
+import django
+from django.test import TestCase
+from django.db import models
+from django.db.models import Q
+
+# Configure Django settings
+from django.conf import settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Create the models from the PR
+class Qux(models.Model):
+    name = models.CharField(max_length=100, default="qux")
+    bazes = models.ManyToManyField('Baz', related_name="quxes")
+    
+    class Meta:
+        app_label = 'test_pr_verification'
+
+class Baz(models.Model):
+    name = models.CharField(max_length=100, default="baz")
+    
+    class Meta:
+        app_label = 'test_pr_verification'
+
+class Foo(models.Model):
+    qux = models.ForeignKey(Qux, on_delete=models.CASCADE, related_name="foos")
+    name = models.CharField(max_length=100, default="foo")
+    
+    class Meta:
+        app_label = 'test_pr_verification'
+
+class Bar(models.Model):
+    foo = models.ForeignKey(Foo, on_delete=models.CASCADE, related_name="bars")
+    another_foo = models.ForeignKey(Foo, on_delete=models.CASCADE, related_name="other_bars")
+    baz = models.ForeignKey(Baz, on_delete=models.CASCADE, related_name="bars")
+    name = models.CharField(max_length=100, default="bar")
+    
+    class Meta:
+        app_label = 'test_pr_verification'
+
+# Create the database tables
+from django.db import connection
+
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(Qux)
+    schema_editor.create_model(Baz)
+    schema_editor.create_model(Foo)
+    schema_editor.create_model(Bar)
+
+# Create test data
+print("Creating test data...")
+qux = Qux.objects.create()
+baz = Baz.objects.create()
+qux.bazes.add(baz)
+
+foo = Foo.objects.create(qux=qux)
+bar = Bar.objects.create(foo=foo, another_foo=foo, baz=baz)
+
+print("Testing the original failing case from the PR...")
+
+# Create the exact querysets from the PR
+qs1 = qux.foos.all()
+qs2 = Foo.objects.filter(
+    Q(bars__baz__in=qux.bazes.all()) | Q(other_bars__baz__in=qux.bazes.all())
+)
+
+print("qs1 query:", qs1.query)
+print("qs2 query:", qs2.query)
+
+# Test the direction that was working (from the PR description)
+print("\nTesting qs2 | qs1 (should work)...")
+try:
+    result = qs2 | qs1
+    print("✓ qs2 | qs1 works fine")
+    print("Result count:", result.count())
+except Exception as e:
+    print(f"✗ qs2 | qs1 failed: {e}")
+
+# Test the direction that was failing (from the PR description)
+print("\nTesting qs1 | qs2 (was failing with AssertionError)...")
+try:
+    result = qs1 | qs2
+    print("✓ qs1 | qs2 now works fine!")
+    print("Result count:", result.count())
+    print("🎉 The original issue has been fixed!")
+except AssertionError as e:
+    print(f"✗ qs1 | qs2 still fails with AssertionError: {e}")
+except Exception as e:
+    print(f"✗ qs1 | qs2 failed with other error: {e}")
+
+print("\nPR verification completed!")
\ No newline at end of file
diff --git a/test_reproduce_issue.py b/test_reproduce_issue.py
new file mode 100644
index 0000000000..6b8a10d681
--- /dev/null
+++ b/test_reproduce_issue.py
@@ -0,0 +1,98 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+        'queries',
+    ],
+    USE_TZ=True,
+)
+
+# Add the tests directory to the path
+sys.path.insert(0, '/testbed/tests')
+
+django.setup()
+
+# Import the models from the queries app
+from queries.models import Tag, Note, Annotation
+
+# Create the database tables
+from django.core.management import execute_from_command_line
+from django.db import connection
+
+with connection.schema_editor() as schema_editor:
+    try:
+        schema_editor.create_model(Tag)
+    except:
+        pass
+    try:
+        schema_editor.create_model(Note)
+    except:
+        pass
+    try:
+        schema_editor.create_model(Annotation)
+    except:
+        pass
+
+# Now test the failing case
+from django.db.models import Q
+
+print("Creating test data...")
+tag1 = Tag.objects.create(name="tag1")
+tag2 = Tag.objects.create(name="tag2")
+
+note1 = Note.objects.create(note="note1", misc="misc1", tag=tag1)
+note2 = Note.objects.create(note="note2", misc="misc2", tag=tag2)
+
+annotation1 = Annotation.objects.create(name="ann1", tag=tag1)
+annotation1.notes.add(note1)
+
+annotation2 = Annotation.objects.create(name="ann2", tag=tag2)
+annotation2.notes.add(note2)
+
+print("Testing QuerySet operations...")
+
+# Create complex querysets that might trigger the issue
+qs1 = Tag.objects.filter(annotation__notes__note__startswith="note")
+qs2 = Tag.objects.filter(annotation__notes__misc__startswith="misc")
+
+print("qs1 query:", qs1.query)
+print("qs2 query:", qs2.query)
+
+print("qs1 alias_map:", qs1.query.alias_map)
+print("qs2 alias_map:", qs2.query.alias_map)
+
+# This should work fine
+print("Testing qs2 | qs1...")
+try:
+    result = qs2 | qs1
+    print("qs2 | qs1 works fine")
+    print("Result query:", result.query)
+except Exception as e:
+    print(f"qs2 | qs1 failed: {e}")
+    import traceback
+    traceback.print_exc()
+
+# This might fail with AssertionError
+print("Testing qs1 | qs2...")
+try:
+    result = qs1 | qs2
+    print("qs1 | qs2 works fine")
+    print("Result query:", result.query)
+except Exception as e:
+    print(f"qs1 | qs2 failed: {e}")
+    import traceback
+    traceback.print_exc()
\ No newline at end of file
diff --git a/test_t_alias_generation.py b/test_t_alias_generation.py
new file mode 100644
index 0000000000..ee9696bd5e
--- /dev/null
+++ b/test_t_alias_generation.py
@@ -0,0 +1,132 @@
+#!/usr/bin/env python
+"""
+Test T-prefixed alias generation specifically
+"""
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    USE_TZ=True,
+)
+
+django.setup()
+
+from django.db.models.sql.query import Query
+from django.db import models
+
+# Create a simple model for testing
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+        db_table = 'test_model'
+
+# Create the database table
+from django.db import connection
+
+with connection.schema_editor() as schema_editor:
+    try:
+        schema_editor.create_model(TestModel)
+    except:
+        pass
+
+print("Testing T-prefixed alias generation...")
+
+# Create a query
+query = Query(TestModel)
+query.get_initial_alias()
+
+print("Initial state:")
+print("alias_map:", list(query.alias_map.keys()))
+print("table_map:", query.table_map)
+
+# First, create an alias for a table (this will use the table name)
+alias1, created1 = query.table_alias('shared_table', create=True)
+print(f"\nFirst alias for 'shared_table': {alias1} (created: {created1})")
+print("alias_map:", list(query.alias_map.keys()))
+print("table_map:", query.table_map)
+
+# Now create another alias for the same table (this should use T-prefixed)
+alias2, created2 = query.table_alias('shared_table', create=True)
+# Simulate what join() does - add the alias to alias_map
+query.alias_map[alias2] = f'dummy_join_for_{alias2}'
+query.alias_refcount[alias2] = 1
+print(f"\nSecond alias for 'shared_table': {alias2} (created: {created2})")
+print("alias_map:", list(query.alias_map.keys()))
+print("table_map:", query.table_map)
+
+# Add some more aliases to test the uniqueness logic
+query.alias_map['T4'] = 'dummy_join_1'
+query.alias_map['T5'] = 'dummy_join_2'
+query.alias_refcount['T4'] = 1
+query.alias_refcount['T5'] = 1
+
+print(f"\nAfter adding T4 and T5:")
+print("alias_map:", list(query.alias_map.keys()))
+
+# Now create another alias for the same table - this should skip T4 and T5
+alias3, created3 = query.table_alias('shared_table', create=True)
+# Simulate what join() does - add the alias to alias_map
+query.alias_map[alias3] = f'dummy_join_for_{alias3}'
+query.alias_refcount[alias3] = 1
+print(f"\nThird alias for 'shared_table': {alias3} (created: {created3})")
+print("alias_map:", list(query.alias_map.keys()))
+print("table_map:", query.table_map)
+
+# Create one more to test the increment logic
+alias4, created4 = query.table_alias('shared_table', create=True)
+# Simulate what join() does - add the alias to alias_map
+query.alias_map[alias4] = f'dummy_join_for_{alias4}'
+query.alias_refcount[alias4] = 1
+print(f"\nFourth alias for 'shared_table': {alias4} (created: {created4})")
+print("alias_map:", list(query.alias_map.keys()))
+print("table_map:", query.table_map)
+
+# Verify that the aliases are unique and follow the expected pattern
+expected_aliases = ['test_model', 'T2', 'T4', 'T5', 'T6', 'T7']
+actual_aliases = list(query.alias_map.keys())
+
+print(f"\nExpected aliases in alias_map: {expected_aliases}")
+print(f"Actual aliases in alias_map: {actual_aliases}")
+
+# Check the table_map for shared_table
+shared_table_aliases = query.table_map.get('shared_table', [])
+print(f"Aliases for 'shared_table': {shared_table_aliases}")
+
+# The expected pattern should be:
+# - First alias: 'shared_table' (table name)
+# - Second alias: 'T2' (first T-prefixed, skipping T1 which doesn't exist)
+# - Third alias: 'T6' (skipping T4, T5 which exist)
+# - Fourth alias: 'T7' (next available)
+
+expected_shared_aliases = ['shared_table', 'T2', 'T6', 'T7']
+print(f"Expected shared_table aliases: {expected_shared_aliases}")
+print(f"Actual shared_table aliases: {shared_table_aliases}")
+
+if shared_table_aliases == expected_shared_aliases:
+    print("✓ T-prefixed alias generation working correctly!")
+else:
+    print("✗ T-prefixed alias generation not working as expected")
+
+# Check that all aliases in alias_map are unique
+if len(actual_aliases) == len(set(actual_aliases)):
+    print("✓ All aliases in alias_map are unique!")
+else:
+    print("✗ Duplicate aliases found in alias_map!")
+
+print("\nT-prefixed alias generation test completed!")
\ No newline at end of file
diff --git a/tests/queries/test_alias_fix.py b/tests/queries/test_alias_fix.py
new file mode 100644
index 0000000000..b0da38c537
--- /dev/null
+++ b/tests/queries/test_alias_fix.py
@@ -0,0 +1,146 @@
+"""
+Test for the alias generation fix in Query.table_alias
+"""
+from django.db import models
+from django.db.models import Q
+from django.test import TestCase
+
+
+class Qux(models.Model):
+    name = models.CharField(max_length=100, default="qux")
+
+
+class Baz(models.Model):
+    name = models.CharField(max_length=100, default="baz")
+
+
+class Foo(models.Model):
+    qux = models.ForeignKey(Qux, on_delete=models.CASCADE, related_name="foos")
+    name = models.CharField(max_length=100, default="foo")
+
+
+class Bar(models.Model):
+    foo = models.ForeignKey(Foo, on_delete=models.CASCADE, related_name="bars")
+    another_foo = models.ForeignKey(Foo, on_delete=models.CASCADE, related_name="other_bars")
+    baz = models.ForeignKey(Baz, on_delete=models.CASCADE, related_name="bars")
+    name = models.CharField(max_length=100, default="bar")
+
+
+# Add M2M relationship
+Qux.add_to_class('bazes', models.ManyToManyField(Baz, related_name="quxes"))
+
+
+class AliasGenerationFixTests(TestCase):
+    """
+    Test for the fix to Query.change_aliases AssertionError.
+    
+    This tests the scenario described in the GitHub issue where
+    Query.change_aliases raises an AssertionError due to overlapping
+    keys and values in the change_map.
+    """
+    
+    def setUp(self):
+        # Create test data
+        self.qux = Qux.objects.create()
+        self.baz = Baz.objects.create()
+        self.qux.bazes.add(self.baz)
+        
+        self.foo = Foo.objects.create(qux=self.qux)
+        self.bar = Bar.objects.create(foo=self.foo, another_foo=self.foo, baz=self.baz)
+    
+    def test_original_failing_case(self):
+        """
+        Test the original case that was failing with AssertionError.
+        
+        The issue occurred when combining querysets where the RHS had
+        sequential aliases (T4, T5) and the LHS had table names that
+        would generate conflicting aliases during the combine operation.
+        """
+        # Create the exact querysets from the original issue
+        qs1 = self.qux.foos.all()
+        qs2 = Foo.objects.filter(
+            Q(bars__baz__in=self.qux.bazes.all()) | Q(other_bars__baz__in=self.qux.bazes.all())
+        )
+        
+        # Test the direction that was working (from the original issue)
+        result1 = qs2 | qs1
+        self.assertIsNotNone(result1)
+        
+        # Test the direction that was failing with AssertionError
+        # This should now work with the fix
+        result2 = qs1 | qs2
+        self.assertIsNotNone(result2)
+        
+        # Both should return the same results
+        self.assertEqual(list(result1), list(result2))
+    
+    def test_complex_queries_with_many_joins(self):
+        """
+        Test more complex queries that might trigger the alias issue.
+        """
+        # Create additional test data
+        qux2 = Qux.objects.create()
+        baz2 = Baz.objects.create()
+        qux2.bazes.add(baz2)
+        
+        foo2 = Foo.objects.create(qux=qux2)
+        bar2 = Bar.objects.create(foo=foo2, another_foo=foo2, baz=baz2)
+        
+        # Create complex queries with many joins that might create
+        # sequential aliases
+        qs1 = Foo.objects.filter(
+            bars__baz__quxes__foos__bars__baz__name__startswith="baz"
+        )
+        qs2 = Foo.objects.filter(
+            other_bars__baz__quxes__foos__other_bars__baz__name__endswith="baz"
+        )
+        
+        # Test both directions - these should not raise AssertionError
+        result1 = qs1 | qs2
+        result2 = qs2 | qs1
+        
+        # Both should be valid querysets
+        self.assertIsNotNone(result1)
+        self.assertIsNotNone(result2)
+    
+    def test_alias_uniqueness_in_table_alias_method(self):
+        """
+        Test that the table_alias method generates unique aliases.
+        """
+        from django.db.models.sql.query import Query
+        
+        # Create a query and test the table_alias method
+        query = Query(Foo)
+        query.get_initial_alias()
+        
+        # Add some aliases to simulate a complex query
+        query.alias_map['T4'] = 'dummy_join_1'
+        query.alias_map['T5'] = 'dummy_join_2'
+        query.table_map['table1'] = ['T4']
+        query.table_map['table2'] = ['T5']
+        query.alias_refcount['T4'] = 1
+        query.alias_refcount['T5'] = 1
+        
+        # Generate new aliases for the same table
+        alias1, created1 = query.table_alias('shared_table', create=True)
+        self.assertTrue(created1)
+        
+        # Simulate what join() does - add the alias to alias_map
+        query.alias_map[alias1] = f'dummy_join_for_{alias1}'
+        query.alias_refcount[alias1] = 1
+        
+        alias2, created2 = query.table_alias('shared_table', create=True)
+        self.assertTrue(created2)
+        query.alias_map[alias2] = f'dummy_join_for_{alias2}'
+        query.alias_refcount[alias2] = 1
+        
+        # The aliases should be unique and not conflict with existing ones
+        all_aliases = list(query.alias_map.keys())
+        self.assertEqual(len(all_aliases), len(set(all_aliases)), 
+                         "All aliases should be unique")
+        
+        # The new aliases should skip T4 and T5
+        shared_table_aliases = query.table_map.get('shared_table', [])
+        for alias in shared_table_aliases[1:]:  # Skip the first (table name)
+            self.assertNotIn(alias, ['T4', 'T5'], 
+                           f"Generated alias {alias} should not conflict with existing aliases")
\ No newline at end of file
