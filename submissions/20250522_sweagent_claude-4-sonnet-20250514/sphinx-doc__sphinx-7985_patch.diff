diff --git a/setup.py b/setup.py
index a404f1fa5..2c6848797 100644
--- a/setup.py
+++ b/setup.py
@@ -15,22 +15,22 @@ if sys.version_info < (3, 5):
     sys.exit(1)
 
 install_requires = [
-    'sphinxcontrib-applehelp',
-    'sphinxcontrib-devhelp',
+    'sphinxcontrib-applehelp<=1.0.7',
+    'sphinxcontrib-devhelp<=1.0.5',
     'sphinxcontrib-jsmath',
-    'sphinxcontrib-htmlhelp',
-    'sphinxcontrib-serializinghtml',
-    'sphinxcontrib-qthelp',
-    'Jinja2>=2.3',
+    'sphinxcontrib-htmlhelp<=2.0.4',
+    'sphinxcontrib-serializinghtml<=1.1.9',
+    'sphinxcontrib-qthelp<=1.0.6',
+    'Jinja2<3.0',
     'Pygments>=2.0',
     'docutils>=0.12',
     'snowballstemmer>=1.1',
     'babel>=1.3',
-    'alabaster>=0.7,<0.8',
+    'alabaster>=0.7,<0.7.12',
     'imagesize',
     'requests>=2.5.0',
     'setuptools',
-    'packaging',
+    'packaging', 'markupsafe<=2.0.1',
 ]
 
 extras_require = {
diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py
index dd5317087..4bcfd6fd7 100644
--- a/sphinx/builders/linkcheck.py
+++ b/sphinx/builders/linkcheck.py
@@ -77,7 +77,7 @@ def check_anchor(response: requests.requests.Response, anchor: str) -> bool:
 
 class CheckExternalLinksBuilder(Builder):
     """
-    Checks for broken external links.
+    Checks for broken external links and local (internal) links.
     """
     name = 'linkcheck'
     epilog = __('Look for any errors in the above output or in '
@@ -208,12 +208,99 @@ class CheckExternalLinksBuilder(Builder):
                 else:
                     return 'redirected', new_url, 0
 
+        def check_local_uri(uri: str) -> Tuple[str, str, int]:
+            """Check local URI for validity."""
+            # Parse the URI to separate document and anchor parts
+            if '#' in uri:
+                doc_part, anchor_part = uri.split('#', 1)
+            else:
+                doc_part, anchor_part = uri, None
+            
+            # Handle fragment-only links (like #anchor)
+            if not doc_part and anchor_part:
+                # This is a fragment-only link, check in current document
+                if self.app.config.linkcheck_anchors:
+                    # Check if anchor should be ignored
+                    for rex in self.anchors_ignore:
+                        if rex.match(anchor_part):
+                            return 'working', '', 0
+                    
+                    std_domain = self.env.get_domain('std')
+                    
+                    # Check in labels (explicit labels with titles)
+                    if anchor_part in std_domain.labels:
+                        return 'working', '', 0
+                    
+                    # Check in anonlabels (anonymous labels without titles)
+                    if anchor_part in std_domain.anonlabels:
+                        return 'working', '', 0
+                    
+                    return 'broken', f"Anchor '{anchor_part}' not found", 0
+                else:
+                    # If anchor checking is disabled, treat fragment-only links as working
+                    return 'working', '', 0
+            
+            # Convert HTML filename to docname (remove .html extension)
+            if doc_part.endswith('.html'):
+                docname = doc_part[:-5]  # Remove .html
+            elif doc_part.endswith('/'):
+                # Handle directory-style links
+                docname = doc_part.rstrip('/')
+            else:
+                docname = doc_part
+            
+            # Handle relative paths - normalize them
+            if docname.startswith('../') or '/../' in docname:
+                # For now, we'll treat relative paths as potentially valid
+                # A more sophisticated implementation could resolve them properly
+                pass
+            
+            # Check if the document exists (only if we have a non-empty docname)
+            if docname and docname not in self.env.found_docs:
+                return 'broken', f"Document '{docname}' not found", 0
+            
+            # If there's an anchor, check if it exists (only if anchor checking is enabled)
+            if anchor_part:
+                if self.app.config.linkcheck_anchors:
+                    # Check if anchor should be ignored
+                    for rex in self.anchors_ignore:
+                        if rex.match(anchor_part):
+                            anchor_part = None
+                            break
+                    
+                    if anchor_part:
+                        # Get the standard domain to check labels
+                        std_domain = self.env.get_domain('std')
+                        
+                        # Check in labels (explicit labels with titles)
+                        if anchor_part in std_domain.labels:
+                            label_docname, label_id, label_title = std_domain.labels[anchor_part]
+                            if docname and label_docname != docname:
+                                return 'broken', f"Anchor '{anchor_part}' not found in document '{docname}'", 0
+                            return 'working', '', 0
+                        
+                        # Check in anonlabels (anonymous labels without titles)
+                        if anchor_part in std_domain.anonlabels:
+                            label_docname, label_id = std_domain.anonlabels[anchor_part]
+                            if docname and label_docname != docname:
+                                return 'broken', f"Anchor '{anchor_part}' not found in document '{docname}'", 0
+                            return 'working', '', 0
+                        
+                        # If we have a docname but the anchor wasn't found in labels,
+                        # it might be a section heading or other implicit anchor
+                        # For now, we'll mark it as broken if we can't find it in the standard domain
+                        return 'broken', f"Anchor '{anchor_part}' not found", 0
+            
+            # If we get here, it's a valid document reference without anchor
+            return 'working', '', 0
+
         def check() -> Tuple[str, str, int]:
             # check for various conditions without bothering the network
             if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):
                 return 'unchecked', '', 0
             elif not uri.startswith(('http:', 'https:')):
-                return 'local', '', 0
+                # Check local URIs
+                return check_local_uri(uri)
             elif uri in self.good:
                 return 'working', 'old', 0
             elif uri in self.broken:
diff --git a/tox.ini b/tox.ini
index bddd822a6..34baee205 100644
--- a/tox.ini
+++ b/tox.ini
@@ -27,7 +27,7 @@ extras =
 setenv =
     PYTHONWARNINGS = all,ignore::ImportWarning:importlib._bootstrap_external,ignore::DeprecationWarning:site,ignore::DeprecationWarning:distutils
 commands=
-    pytest --durations 25 {posargs}
+    pytest -rA --durations 25 {posargs}
 
 [testenv:flake8]
 basepython = python3
