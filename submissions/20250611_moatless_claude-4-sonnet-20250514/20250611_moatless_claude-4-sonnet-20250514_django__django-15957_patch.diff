--- a/django/db/models/fields/related_descriptors.py
+++ b/django/db/models/fields/related_descriptors.py
@@ -70,6 +70,87 @@
 from django.db.models.query_utils import DeferredAttribute
 from django.db.models.utils import resolve_callables
 from django.utils.functional import cached_property
+
+
+def filter_prefetch_queryset(queryset, *args, **kwargs):
+    """
+    Apply filters to a queryset, handling sliced querysets appropriately.
+    
+    If the queryset is sliced, this function will:
+    1. Create an unsliced copy of the queryset
+    2. Apply the filter to get all matching results  
+    3. Apply the original slice limits to the filtered results
+    
+    This allows prefetch operations to work with sliced querysets.
+    
+    Accepts both Q objects as positional arguments and keyword arguments,
+    just like the regular filter() method.
+    """
+    if not queryset.query.is_sliced:
+        # Normal case - no slicing, apply filter directly
+        return queryset.filter(*args, **kwargs)
+    
+    # Handle sliced queryset case
+    # Store the original slice parameters
+    low_mark = queryset.query.low_mark
+    high_mark = queryset.query.high_mark
+    
+    # Create an unsliced copy of the queryset
+    unsliced_queryset = queryset._chain()
+    unsliced_queryset.query.clear_limits()
+    
+    # Apply the filter to the unsliced queryset
+    filtered_queryset = unsliced_queryset.filter(*args, **kwargs)
+    
+    # Re-apply the original slice
+    if high_mark is not None:
+        if low_mark:
+            filtered_queryset = filtered_queryset[low_mark:high_mark]
+        else:
+            filtered_queryset = filtered_queryset[:high_mark]
+    elif low_mark:
+        filtered_queryset = filtered_queryset[low_mark:]
+    
+    return filtered_queryset
+
+
+def extra_prefetch_queryset(queryset, **kwargs):
+    """
+    Apply extra() to a queryset, handling sliced querysets appropriately.
+    
+    If the queryset is sliced, this function will:
+    1. Create an unsliced copy of the queryset
+    2. Apply the extra() to get all matching results  
+    3. Apply the original slice limits to the modified results
+    
+    This allows prefetch operations to work with sliced querysets that need extra() calls.
+    """
+    if not queryset.query.is_sliced:
+        # Normal case - no slicing, apply extra directly
+        return queryset.extra(**kwargs)
+    
+    # Handle sliced queryset case
+    # Store the original slice parameters
+    low_mark = queryset.query.low_mark
+    high_mark = queryset.query.high_mark
+    
+    # Create an unsliced copy of the queryset
+    unsliced_queryset = queryset._chain()
+    unsliced_queryset.query.clear_limits()
+    
+    # Apply the extra to the unsliced queryset
+    extra_queryset = unsliced_queryset.extra(**kwargs)
+    
+    # Re-apply the original slice
+    if high_mark is not None:
+        if low_mark:
+            extra_queryset = extra_queryset[low_mark:high_mark]
+        else:
+            extra_queryset = extra_queryset[:high_mark]
+    elif low_mark:
+        extra_queryset = extra_queryset[low_mark:]
+    
+    return extra_queryset
 
 
 class ForeignKeyDeferredAttribute(DeferredAttribute):
@@ -145,7 +226,7 @@
             }
         else:
             query = {"%s__in" % self.field.related_query_name(): instances}
-        queryset = queryset.filter(**query)
+        queryset = filter_prefetch_queryset(queryset, **query)
 
         # Since we're going to assign directly in the cache,
         # we must manage the reverse relation cache manually.
@@ -404,7 +485,7 @@
         instance_attr = self.related.field.get_foreign_related_value
         instances_dict = {instance_attr(inst): inst for inst in instances}
         query = {"%s__in" % self.related.field.name: instances}
-        queryset = queryset.filter(**query)
+        queryset = filter_prefetch_queryset(queryset, **query)
 
         # Since we're going to assign directly in the cache,
         # we must manage the reverse relation cache manually.
@@ -719,7 +800,7 @@
             instance_attr = self.field.get_foreign_related_value
             instances_dict = {instance_attr(inst): inst for inst in instances}
             query = {"%s__in" % self.field.name: instances}
-            queryset = queryset.filter(**query)
+            queryset = filter_prefetch_queryset(queryset, **query)
 
             # Since we just bypassed this class' get_queryset(), we must manage
             # the reverse relation manually.
@@ -1052,7 +1133,7 @@
             queryset = queryset.using(queryset._db or self._db)
 
             query = {"%s__in" % self.query_field_name: instances}
-            queryset = queryset._next_is_sticky().filter(**query)
+            queryset = filter_prefetch_queryset(queryset._next_is_sticky(), **query)
 
             # M2M: need to annotate the query in order to get the primary model
             # that the secondary model was actually related to. We know that
@@ -1065,7 +1146,8 @@
             join_table = fk.model._meta.db_table
             connection = connections[queryset.db]
             qn = connection.ops.quote_name
-            queryset = queryset.extra(
+            queryset = extra_prefetch_queryset(
+                queryset,
                 select={
                     "_prefetch_related_val_%s"
                     % f.attname: "%s.%s"

--- a/django/contrib/contenttypes/fields.py
+++ b/django/contrib/contenttypes/fields.py
@@ -13,6 +13,7 @@
     ReverseManyToOneDescriptor,
     lazy_related_operation,
 )
+from django.db.models.fields.related_descriptors import filter_prefetch_queryset, extra_prefetch_queryset
 from django.db.models.query_utils import PathInfo
 from django.db.models.sql import AND
 from django.db.models.sql.where import WhereNode
@@ -645,7 +646,7 @@
             object_id_converter = instances[0]._meta.pk.to_python
             content_type_id_field_name = "%s_id" % self.content_type_field_name
             return (
-                queryset.filter(query),
+                filter_prefetch_queryset(queryset, query),
                 lambda relobj: (
                     object_id_converter(getattr(relobj, self.object_id_field_name)),
                     getattr(relobj, content_type_id_field_name),
