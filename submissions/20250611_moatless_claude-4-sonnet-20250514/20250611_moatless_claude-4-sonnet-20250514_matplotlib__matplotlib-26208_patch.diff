--- a/reproduce_issue.py
+++ b/reproduce_issue.py
@@ -0,0 +1,40 @@
+import matplotlib.pyplot as plt
+
+def print_datalim(*ax):
+    for ax_ in ax:
+        print(ax_.dataLim.intervaly, end=' / ')
+    print()
+
+df1_index = ['16 May', '17 May']  # == df2_index
+df1_values = [-22.717708333333402, 26.584999999999937]
+df2_values = [-0.08501399999999998, -2.9833019999999966]
+
+print("Reproducing the issue:")
+fig, ax1 = plt.subplots()
+
+ax1.stackplot(df1_index, df1_values)
+print("After stackplot on ax1:", end=' ')
+print_datalim(ax1)
+
+ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
+print("After twinx():", end=' ')
+print_datalim(ax1, ax2)
+
+ax2.plot(df1_index, df2_values)
+print("After plot on ax2:", end=' ')
+print_datalim(ax1, ax2)
+
+print("\nNow testing the reverse order:")
+fig2, ax3 = plt.subplots()
+
+ax3.plot(df1_index, df2_values)
+print("After plot on ax3:", end=' ')
+print_datalim(ax3)
+
+ax4 = ax3.twinx()
+print("After twinx():", end=' ')
+print_datalim(ax3, ax4)
+
+ax4.stackplot(df1_index, df1_values)
+print("After stackplot on ax4:", end=' ')
+print_datalim(ax3, ax4)

--- a/lib/matplotlib/axes/_base.py
+++ b/lib/matplotlib/axes/_base.py
@@ -2451,15 +2451,11 @@
         """
         Recompute the data limits based on current artists.
 
-        At present, `.Collection` instances are not supported.
-
         Parameters
         ----------
         visible_only : bool, default: False
             Whether to exclude invisible artists.
         """
-        # Collections are deliberately not supported (yet); see
-        # the TODO note in artists.py.
         self.dataLim.ignore(True)
         self.dataLim.set_points(mtransforms.Bbox.null().get_points())
         self.ignore_existing_data_limits = True
@@ -2472,6 +2468,8 @@
                     self._update_patch_limits(artist)
                 elif isinstance(artist, mimage.AxesImage):
                     self._update_image_limits(artist)
+                elif isinstance(artist, mcoll.Collection):
+                    self._update_collection_limits(artist)
 
     def update_datalim(self, xys, updatex=True, updatey=True):
         """

--- a/debug_siblings.py
+++ b/debug_siblings.py
@@ -0,0 +1,32 @@
+import matplotlib.pyplot as plt
+
+df1_index = ['16 May', '17 May']
+df1_values = [-22.717708333333402, 26.584999999999937]
+df2_values = [-0.08501399999999998, -2.9833019999999966]
+
+fig, ax1 = plt.subplots()
+ax1.stackplot(df1_index, df1_values)
+
+print("ax1 x-axis siblings:", [id(ax) for ax in ax1._shared_axes["x"].get_siblings(ax1)])
+print("ax1 y-axis siblings:", [id(ax) for ax in ax1._shared_axes["y"].get_siblings(ax1)])
+
+ax2 = ax1.twinx()
+
+print("After twinx():")
+print("ax1 x-axis siblings:", [id(ax) for ax in ax1._shared_axes["x"].get_siblings(ax1)])
+print("ax1 y-axis siblings:", [id(ax) for ax in ax1._shared_axes["y"].get_siblings(ax1)])
+print("ax2 x-axis siblings:", [id(ax) for ax in ax2._shared_axes["x"].get_siblings(ax2)])
+print("ax2 y-axis siblings:", [id(ax) for ax in ax2._shared_axes["y"].get_siblings(ax2)])
+
+print("ax1 id:", id(ax1), "ax2 id:", id(ax2))
+
+# Let's also check the sticky edges:
+print("ax1 children sticky edges y:")
+for child in ax1.get_children():
+    if hasattr(child, 'sticky_edges'):
+        print(f"  {type(child).__name__}: {child.sticky_edges.y}")
+
+print("ax2 children sticky edges y:")
+for child in ax2.get_children():
+    if hasattr(child, 'sticky_edges'):
+        print(f"  {type(child).__name__}: {child.sticky_edges.y}")

--- a/debug_autoscale.py
+++ b/debug_autoscale.py
@@ -0,0 +1,57 @@
+import matplotlib.pyplot as plt
+import numpy as np
+
+def print_datalim(*ax):
+    for ax_ in ax:
+        print(ax_.dataLim.intervaly, end=' / ')
+    print()
+
+df1_index = ['16 May', '17 May']
+df1_values = [-22.717708333333402, 26.584999999999937]
+df2_values = [-0.08501399999999998, -2.9833019999999966]
+
+fig, ax1 = plt.subplots()
+ax1.stackplot(df1_index, df1_values)
+print("After stackplot on ax1:", end=' ')
+print_datalim(ax1)
+
+ax2 = ax1.twinx()
+print("After twinx():", end=' ')
+print_datalim(ax1, ax2)
+
+# Let's monkey patch autoscale_view to see what's happening:
+original_autoscale = ax1.autoscale_view
+
+def debug_autoscale_view(*args, **kwargs):
+    print(f"autoscale_view called on ax1 with args={args}, kwargs={kwargs}")
+    print(f"  Before: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    
+    # Get y-axis shared siblings
+    y_siblings = ax1._shared_axes["y"].get_siblings(ax1)
+    print(f"  Y-axis siblings: {[id(ax) for ax in y_siblings]}")
+    
+    # Get y sticky edges
+    if ax1.use_sticky_edges and ax1._ymargin and kwargs.get('scaley', True) and ax1.get_autoscaley_on():
+        y_stickies = np.sort(np.concatenate([
+            artist.sticky_edges.y
+            for ax in y_siblings
+            for artist in ax.get_children()]))
+        print(f"  Y sticky edges: {y_stickies}")
+        
+        # Get y data limits values
+        values = [val for ax in y_siblings
+                  for val in getattr(ax.dataLim, "intervaly")
+                  if np.isfinite(val)]
+        print(f"  Y data values from siblings: {values}")
+    
+    result = original_autoscale(*args, **kwargs)
+    print(f"  After: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    return result
+
+ax1.autoscale_view = debug_autoscale_view
+
+# Now plot on ax2 and see what happens
+print("About to plot on ax2...")
+ax2.plot(df1_index, df2_values)
+print("After plot on ax2:", end=' ')
+print_datalim(ax1, ax2)

--- a/debug_viewlim.py
+++ b/debug_viewlim.py
@@ -0,0 +1,64 @@
+import matplotlib.pyplot as plt
+import numpy as np
+
+def print_datalim(*ax):
+    for ax_ in ax:
+        print(ax_.dataLim.intervaly, end=' / ')
+    print()
+
+df1_index = ['16 May', '17 May']
+df1_values = [-22.717708333333402, 26.584999999999937]
+df2_values = [-0.08501399999999998, -2.9833019999999966]
+
+fig, ax1 = plt.subplots()
+ax1.stackplot(df1_index, df1_values)
+print("After stackplot on ax1:", end=' ')
+print_datalim(ax1)
+
+ax2 = ax1.twinx()
+print("After twinx():", end=' ')
+print_datalim(ax1, ax2)
+
+# Let's monkey patch _unstale_viewLim to see what's happening:
+original_unstale = ax1._unstale_viewLim
+
+def debug_unstale_viewLim():
+    print("_unstale_viewLim called on ax1")
+    print(f"  Before: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    print(f"  ax1._stale_viewlims = {ax1._stale_viewlims}")
+    print(f"  ax2._stale_viewlims = {ax2._stale_viewlims}")
+    
+    # Check what need_scale will be
+    need_scale = {
+        name: any(ax._stale_viewlims[name]
+                  for ax in ax1._shared_axes[name].get_siblings(ax1))
+        for name in ax1._axis_names}
+    print(f"  need_scale = {need_scale}")
+    
+    result = original_unstale()
+    print(f"  After: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    return result
+
+ax1._unstale_viewLim = debug_unstale_viewLim
+
+# Let's also patch autoscale_view
+original_autoscale = ax1.autoscale_view
+
+def debug_autoscale_view(*args, **kwargs):
+    print(f"autoscale_view called on ax1 with args={args}, kwargs={kwargs}")
+    print(f"  Before: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    result = original_autoscale(*args, **kwargs)
+    print(f"  After: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    return result
+
+ax1.autoscale_view = debug_autoscale_view
+
+print("About to plot on ax2...")
+ax2.plot(df1_index, df2_values)
+print("After plot on ax2:", end=' ')
+print_datalim(ax1, ax2)
+
+print("Now accessing ax1.viewLim...")
+_ = ax1.viewLim
+print("After accessing ax1.viewLim:", end=' ')
+print_datalim(ax1, ax2)

--- a/debug_twinx_creation.py
+++ b/debug_twinx_creation.py
@@ -0,0 +1,19 @@
+import matplotlib.pyplot as plt
+
+def print_datalim(*ax):
+    for ax_ in ax:
+        print(ax_.dataLim.intervaly, end=' / ')
+    print()
+
+df1_index = ['16 May', '17 May']
+df1_values = [-22.717708333333402, 26.584999999999937]
+
+fig, ax1 = plt.subplots()
+ax1.stackplot(df1_index, df1_values)
+print("After stackplot on ax1:", end=' ')
+print_datalim(ax1)
+
+print("About to call twinx()...")
+ax2 = ax1.twinx()
+print("After twinx():", end=' ')
+print_datalim(ax1, ax2)

--- a/debug_datalim_modification.py
+++ b/debug_datalim_modification.py
@@ -0,0 +1,41 @@
+import matplotlib.pyplot as plt
+import numpy as np
+
+def print_datalim(*ax):
+    for i, ax_ in enumerate(ax, 1):
+        print(f"ax{i}: {ax_.dataLim.intervaly}", end=' / ')
+    print()
+
+df1_index = ['16 May', '17 May']
+df1_values = [-22.717708333333402, 26.584999999999937]
+df2_values = [-0.08501399999999998, -2.9833019999999966]
+
+fig, ax1 = plt.subplots()
+
+# Let's monkey patch the dataLim.intervaly setter to see when it changes
+original_intervaly_setter = ax1.dataLim.__class__.intervaly.fset
+
+def debug_intervaly_setter(self, interval):
+    import traceback
+    print(f"Setting dataLim.intervaly to {interval}")
+    print("Stack trace:")
+    traceback.print_stack(limit=10)
+    print("---")
+    return original_intervaly_setter(self, interval)
+
+ax1.dataLim.__class__.intervaly = ax1.dataLim.__class__.intervaly.setter(debug_intervaly_setter)
+
+print("Creating stackplot...")
+ax1.stackplot(df1_index, df1_values)
+print("After stackplot on ax1:", end=' ')
+print_datalim(ax1)
+
+print("Creating twinx...")
+ax2 = ax1.twinx()
+print("After twinx():", end=' ')
+print_datalim(ax1, ax2)
+
+print("Plotting on ax2...")
+ax2.plot(df1_index, df2_values)
+print("After plot on ax2:", end=' ')
+print_datalim(ax1, ax2)

--- a/debug_shared_datalim.py
+++ b/debug_shared_datalim.py
@@ -0,0 +1,23 @@
+import matplotlib.pyplot as plt
+
+def print_datalim(*ax):
+    for i, ax_ in enumerate(ax, 1):
+        print(f"ax{i}: {ax_.dataLim.intervaly} (id: {id(ax_.dataLim)})", end=' / ')
+    print()
+
+df1_index = ['16 May', '17 May']
+df1_values = [-22.717708333333402, 26.584999999999937]
+df2_values = [-0.08501399999999998, -2.9833019999999966]
+
+fig, ax1 = plt.subplots()
+ax1.stackplot(df1_index, df1_values)
+print("After stackplot on ax1:", end=' ')
+print_datalim(ax1)
+
+ax2 = ax1.twinx()
+print("After twinx():", end=' ')
+print_datalim(ax1, ax2)
+
+ax2.plot(df1_index, df2_values)
+print("After plot on ax2:", end=' ')
+print_datalim(ax1, ax2)

--- a/debug_autoscale_detail.py
+++ b/debug_autoscale_detail.py
@@ -0,0 +1,94 @@
+import matplotlib.pyplot as plt
+import numpy as np
+
+def print_datalim(*ax):
+    for i, ax_ in enumerate(ax, 1):
+        print(f"ax{i}: {ax_.dataLim.intervaly} (id: {id(ax_.dataLim)})", end=' / ')
+    print()
+
+df1_index = ['16 May', '17 May']
+df1_values = [-22.717708333333402, 26.584999999999937]
+df2_values = [-0.08501399999999998, -2.9833019999999966]
+
+fig, ax1 = plt.subplots()
+ax1.stackplot(df1_index, df1_values)
+print("After stackplot on ax1:", end=' ')
+print_datalim(ax1)
+
+ax2 = ax1.twinx()
+print("After twinx():", end=' ')
+print_datalim(ax1, ax2)
+
+# Patch the autoscale_view method to see what's happening in detail
+original_autoscale_view = ax1.autoscale_view
+
+def debug_autoscale_view(tight=None, scalex=True, scaley=True):
+    print(f"autoscale_view called on ax1: scalex={scalex}, scaley={scaley}")
+    print(f"  Before: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    print(f"  Before: ax2.dataLim.intervaly = {ax2.dataLim.intervaly}")
+    
+    # Let's manually run through the handle_single_axis logic for x and y
+    def debug_handle_single_axis(scale, shared_axes, name, axis, margin, stickies, set_bound):
+        print(f"  Processing {name}-axis: scale={scale}")
+        if not (scale and axis._get_autoscale_on()):
+            print(f"    Skipping {name}-axis (not scaling or autoscale off)")
+            return
+        
+        shared = shared_axes.get_siblings(ax1)
+        print(f"    Shared siblings for {name}: {[id(ax) for ax in shared]}")
+        
+        # Base autoscaling on finite data limits
+        values = [val for ax in shared
+                  for val in getattr(ax.dataLim, f"interval{name}")
+                  if np.isfinite(val)]
+        print(f"    Data values from all siblings: {values}")
+        
+        if values:
+            x0, x1 = (min(values), max(values))
+            print(f"    Computed range: [{x0}, {x1}]")
+        else:
+            print(f"    No finite values, using defaults")
+        
+        # Just call the original set_bound for now
+        if values:
+            print(f"    About to call set_bound with: {x0}, {x1}")
+            set_bound(x0, x1)
+    
+    # Get sticky edges first
+    x_stickies = y_stickies = np.array([])
+    if ax1.use_sticky_edges:
+        if ax1._xmargin and scalex and ax1.get_autoscalex_on():
+            x_stickies = np.sort(np.concatenate([
+                artist.sticky_edges.x
+                for ax in ax1._shared_axes["x"].get_siblings(ax1)
+                for artist in ax.get_children()]))
+        if ax1._ymargin and scaley and ax1.get_autoscaley_on():
+            y_stickies = np.sort(np.concatenate([
+                artist.sticky_edges.y
+                for ax in ax1._shared_axes["y"].get_siblings(ax1)
+                for artist in ax.get_children()]))
+    
+    print(f"  X sticky edges: {x_stickies}")
+    print(f"  Y sticky edges: {y_stickies}")
+    
+    debug_handle_single_axis(
+        scalex, ax1._shared_axes["x"], 'x', ax1.xaxis, ax1._xmargin,
+        x_stickies, ax1.set_xbound)
+    debug_handle_single_axis(
+        scaley, ax1._shared_axes["y"], 'y', ax1.yaxis, ax1._ymargin,
+        y_stickies, ax1.set_ybound)
+    
+    print(f"  After: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    print(f"  After: ax2.dataLim.intervaly = {ax2.dataLim.intervaly}")
+
+ax1.autoscale_view = debug_autoscale_view
+
+print("About to plot on ax2...")
+ax2.plot(df1_index, df2_values)
+print("After plot on ax2:", end=' ')
+print_datalim(ax1, ax2)
+
+print("Now accessing ax1.viewLim to trigger autoscaling...")
+_ = ax1.viewLim
+print("After accessing ax1.viewLim:", end=' ')
+print_datalim(ax1, ax2)

--- a/debug_update_from_data_xy.py
+++ b/debug_update_from_data_xy.py
@@ -0,0 +1,75 @@
+import matplotlib.pyplot as plt
+import traceback
+
+def print_datalim(*ax):
+    for i, ax_ in enumerate(ax, 1):
+        print(f"ax{i}: {ax_.dataLim.intervaly}", end=' / ')
+    print()
+
+df1_index = ['16 May', '17 May']
+df1_values = [-22.717708333333402, 26.584999999999937]
+df2_values = [-0.08501399999999998, -2.9833019999999966]
+
+fig, ax1 = plt.subplots()
+
+# Patch update_from_data_xy to track when it's called
+original_update_from_data_xy = ax1.dataLim.update_from_data_xy
+
+def debug_update_from_data_xy(xy, ignore_existing=False, updatex=True, updatey=True):
+    print(f"update_from_data_xy called on ax1.dataLim:")
+    print(f"  xy: {xy}")
+    print(f"  ignore_existing: {ignore_existing}")
+    print(f"  updatex: {updatex}, updatey: {updatey}")
+    print(f"  Before: {ax1.dataLim.intervaly}")
+    
+    result = original_update_from_data_xy(xy, ignore_existing, updatex, updatey)
+    
+    print(f"  After: {ax1.dataLim.intervaly}")
+    if list(ax1.dataLim.intervaly) == [float('inf'), float('-inf')]:
+        print("  *** DETECTED INF/-INF ***")
+        traceback.print_stack(limit=15)
+        print("  ---")
+    
+    return result
+
+ax1.dataLim.update_from_data_xy = debug_update_from_data_xy
+
+print("Creating stackplot...")
+ax1.stackplot(df1_index, df1_values)
+print("After stackplot on ax1:", end=' ')
+print_datalim(ax1)
+
+print("Creating twinx...")
+ax2 = ax1.twinx()
+
+# Also patch ax2's dataLim
+original_update_from_data_xy_ax2 = ax2.dataLim.update_from_data_xy
+
+def debug_update_from_data_xy_ax2(xy, ignore_existing=False, updatex=True, updatey=True):
+    print(f"update_from_data_xy called on ax2.dataLim:")
+    print(f"  xy: {xy}")
+    print(f"  ignore_existing: {ignore_existing}")
+    print(f"  updatex: {updatex}, updatey: {updatey}")
+    print(f"  Before ax2: {ax2.dataLim.intervaly}")
+    print(f"  Before ax1: {ax1.dataLim.intervaly}")
+    
+    result = original_update_from_data_xy_ax2(xy, ignore_existing, updatex, updatey)
+    
+    print(f"  After ax2: {ax2.dataLim.intervaly}")
+    print(f"  After ax1: {ax1.dataLim.intervaly}")
+    if list(ax1.dataLim.intervaly) == [float('inf'), float('-inf')]:
+        print("  *** ax1 CHANGED TO INF/-INF ***")
+        traceback.print_stack(limit=15)
+        print("  ---")
+    
+    return result
+
+ax2.dataLim.update_from_data_xy = debug_update_from_data_xy_ax2
+
+print("After twinx():", end=' ')
+print_datalim(ax1, ax2)
+
+print("Plotting on ax2...")
+ax2.plot(df1_index, df2_values)
+print("After plot on ax2:", end=' ')
+print_datalim(ax1, ax2)

--- a/debug_datalim_property.py
+++ b/debug_datalim_property.py
@@ -0,0 +1,83 @@
+import matplotlib.pyplot as plt
+import traceback
+
+def print_datalim(*ax):
+    for i, ax_ in enumerate(ax, 1):
+        print(f"ax{i}: {ax_.dataLim.intervaly} (id: {id(ax_.dataLim)})", end=' / ')
+    print()
+
+df1_index = ['16 May', '17 May']
+df1_values = [-22.717708333333402, 26.584999999999937]
+df2_values = [-0.08501399999999998, -2.9833019999999966]
+
+fig, ax1 = plt.subplots()
+
+# Monitor if the dataLim object itself gets replaced
+original_dataLim = ax1.dataLim
+print(f"Initial ax1.dataLim id: {id(ax1.dataLim)}")
+
+# Monitor direct property access to dataLim
+class DataLimProxy:
+    def __init__(self, original):
+        self._original = original
+    
+    def __getattr__(self, name):
+        return getattr(self._original, name)
+    
+    def __setattr__(self, name, value):
+        if name == '_original':
+            super().__setattr__(name, value)
+            return
+        print(f"DataLim.{name} set to {value}")
+        if name == 'intervaly' and str(value) == '[ inf -inf]':
+            print("*** DETECTED INF/-INF in intervaly setter ***")
+            traceback.print_stack(limit=15)
+            print("---")
+        setattr(self._original, name, value)
+
+# We can't easily proxy the dataLim since it's a complex object, 
+# so let's try a different approach - monitor the get/set of dataLim on the axis
+
+class AxesProxy:
+    def __init__(self, original_axes):
+        self._original = original_axes
+    
+    def __getattr__(self, name):
+        return getattr(self._original, name)
+    
+    def __setattr__(self, name, value):
+        if name == '_original':
+            super().__setattr__(name, value)
+            return
+        if name == 'dataLim':
+            print(f"ax1.dataLim being set to {value} (id: {id(value)})")
+            traceback.print_stack(limit=10)
+            print("---")
+        setattr(self._original, name, value)
+
+# This approach is getting complex. Let me try a simpler method:
+# Let's just check if ax1 and ax2 somehow share transforms or other objects
+
+print("Creating stackplot...")
+ax1.stackplot(df1_index, df1_values)
+print("After stackplot on ax1:", end=' ')
+print_datalim(ax1)
+
+print("Creating twinx...")
+ax2 = ax1.twinx()
+print("After twinx():", end=' ')
+print_datalim(ax1, ax2)
+
+# Check if they share any objects that could affect dataLim
+print("Checking shared objects:")
+print(f"Same figure: {ax1.figure is ax2.figure}")
+print(f"Same transData: {ax1.transData is ax2.transData}")
+print(f"Same transAxes: {ax1.transAxes is ax2.transAxes}")
+print(f"Same dataLim: {ax1.dataLim is ax2.dataLim}")
+
+print("Plotting on ax2...")
+ax2.plot(df1_index, df2_values)
+print("After plot on ax2:", end=' ')
+print_datalim(ax1, ax2)
+
+print(f"Final ax1.dataLim id: {id(ax1.dataLim)} (changed: {id(ax1.dataLim) != id(original_dataLim)})")

--- a/debug_plot_steps.py
+++ b/debug_plot_steps.py
@@ -0,0 +1,72 @@
+import matplotlib.pyplot as plt
+
+def print_datalim(*ax):
+    for i, ax_ in enumerate(ax, 1):
+        print(f"ax{i}: {ax_.dataLim.intervaly}", end=' / ')
+    print()
+
+df1_index = ['16 May', '17 May']
+df1_values = [-22.717708333333402, 26.584999999999937]
+df2_values = [-0.08501399999999998, -2.9833019999999966]
+
+fig, ax1 = plt.subplots()
+ax1.stackplot(df1_index, df1_values)
+print("After stackplot on ax1:", end=' ')
+print_datalim(ax1)
+
+ax2 = ax1.twinx()
+print("After twinx():", end=' ')
+print_datalim(ax1, ax2)
+
+# Let's wrap the plot method to see step by step what happens
+original_plot = ax2.plot
+
+def debug_plot(*args, **kwargs):
+    print("=== Starting ax2.plot() ===")
+    print("Before plot:", end=' ')
+    print_datalim(ax1, ax2)
+    
+    # Let's manually step through what plot does
+    import matplotlib.cbook as cbook
+    import matplotlib.lines as mlines
+    
+    print("Creating lines...")
+    # This is from the plot method
+    kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
+    lines = [*ax2._get_lines(*args, **kwargs)]
+    print("After _get_lines:", end=' ')
+    print_datalim(ax1, ax2)
+    
+    print("Adding lines to axes...")
+    for line in lines:
+        print(f"  Adding line: {line}")
+        ax2.add_line(line)
+        print(f"  After adding line:", end=' ')
+        print_datalim(ax1, ax2)
+    
+    print("Requesting autoscale...")
+    scalex = kwargs.get('scalex', True)
+    scaley = kwargs.get('scaley', True)
+    if scalex:
+        print("  Requesting autoscale for x")
+        ax2._request_autoscale_view("x")
+        print("  After x autoscale request:", end=' ')
+        print_datalim(ax1, ax2)
+    if scaley:
+        print("  Requesting autoscale for y")
+        ax2._request_autoscale_view("y")
+        print("  After y autoscale request:", end=' ')
+        print_datalim(ax1, ax2)
+    
+    print("=== Finished ax2.plot() ===")
+    print("Final result:", end=' ')
+    print_datalim(ax1, ax2)
+    
+    return lines
+
+ax2.plot = debug_plot
+
+print("About to call ax2.plot()...")
+ax2.plot(df1_index, df2_values)
+print("After plot on ax2:", end=' ')
+print_datalim(ax1, ax2)

--- a/debug_narrow_getlines.py
+++ b/debug_narrow_getlines.py
@@ -0,0 +1,61 @@
+import matplotlib.pyplot as plt
+import matplotlib.cbook as cbook
+import matplotlib.lines as mlines
+
+def print_datalim(*ax):
+    for i, ax_ in enumerate(ax, 1):
+        print(f"ax{i}: {ax_.dataLim.intervaly}", end=' / ')
+    print()
+
+df1_index = ['16 May', '17 May']
+df1_values = [-22.717708333333402, 26.584999999999937]
+df2_values = [-0.08501399999999998, -2.9833019999999966]
+
+fig, ax1 = plt.subplots()
+ax1.stackplot(df1_index, df1_values)
+print("After stackplot on ax1:", end=' ')
+print_datalim(ax1)
+
+ax2 = ax1.twinx()
+print("After twinx():", end=' ')
+print_datalim(ax1, ax2)
+
+# Let's manually step through _get_lines piece by piece
+print("About to simulate ax2.plot() step by step...")
+args = (df1_index, df2_values)
+kwargs = {}
+
+print("Step 1: _process_unit_info")
+ax2._process_unit_info(kwargs=kwargs)
+print("After _process_unit_info:", end=' ')
+print_datalim(ax1, ax2)
+
+print("Step 2: Normalize kwargs")
+kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
+print("After normalize_kwargs:", end=' ')
+print_datalim(ax1, ax2)
+
+print("Step 3: Starting to process args")
+# This would come from _process_plot_var_args.__call__ method
+
+print("Step 4: Processing units")
+# From _plot_args, this would call:
+x, y = args
+x = plt.matplotlib.axes._base._check_1d(x)
+y = plt.matplotlib.axes._base._check_1d(y)
+print("After _check_1d:", end=' ')
+print_datalim(ax1, ax2)
+
+print("Step 5: Updating units on xaxis")
+if ax2.xaxis is not None:
+    ax2.xaxis.update_units(x)
+print("After xaxis.update_units:", end=' ')
+print_datalim(ax1, ax2)
+
+print("Step 6: Updating units on yaxis")
+if ax2.yaxis is not None:
+    ax2.yaxis.update_units(y)
+print("After yaxis.update_units:", end=' ')
+print_datalim(ax1, ax2)
+
+print("Done with narrow testing")

--- a/debug_set_units.py
+++ b/debug_set_units.py
@@ -0,0 +1,69 @@
+import matplotlib.pyplot as plt
+
+def print_datalim(*ax):
+    for i, ax_ in enumerate(ax, 1):
+        print(f"ax{i}: {ax_.dataLim.intervaly}", end=' / ')
+    print()
+
+df1_index = ['16 May', '17 May']
+df1_values = [-22.717708333333402, 26.584999999999937]
+df2_values = [-0.08501399999999998, -2.9833019999999966]
+
+fig, ax1 = plt.subplots()
+ax1.stackplot(df1_index, df1_values)
+print("After stackplot on ax1:", end=' ')
+print_datalim(ax1)
+
+ax2 = ax1.twinx()
+print("After twinx():", end=' ')
+print_datalim(ax1, ax2)
+
+# Patch set_units to see what happens
+original_set_units = ax2.xaxis.set_units
+
+def debug_set_units(u):
+    print(f"ax2.xaxis.set_units called with: {u}")
+    print(f"  Before: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    print(f"  Before: ax2.dataLim.intervaly = {ax2.dataLim.intervaly}")
+    
+    # Check which axes are shared
+    shared_axes = ax2.xaxis._get_shared_axis()
+    print(f"  Shared x-axes: {[id(axis.axes) for axis in shared_axes]}")
+    
+    result = original_set_units(u)
+    
+    print(f"  After: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    print(f"  After: ax2.dataLim.intervaly = {ax2.dataLim.intervaly}")
+    
+    return result
+
+ax2.xaxis.set_units = debug_set_units
+
+# Also patch _update_axisinfo to see what happens there
+original_update_axisinfo = ax1.xaxis._update_axisinfo
+
+def debug_update_axisinfo():
+    print("ax1.xaxis._update_axisinfo called")
+    print(f"  Before: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    result = original_update_axisinfo()
+    print(f"  After: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    return result
+
+ax1.xaxis._update_axisinfo = debug_update_axisinfo
+
+original_update_axisinfo_ax2 = ax2.xaxis._update_axisinfo
+
+def debug_update_axisinfo_ax2():
+    print("ax2.xaxis._update_axisinfo called")
+    print(f"  Before: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    result = original_update_axisinfo_ax2()
+    print(f"  After: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    return result
+
+ax2.xaxis._update_axisinfo = debug_update_axisinfo_ax2
+
+print("About to call ax2.xaxis.update_units...")
+x = ['16 May', '17 May']
+ax2.xaxis.update_units(x)
+print("After update_units:", end=' ')
+print_datalim(ax1, ax2)

--- a/debug_update_axisinfo_detail.py
+++ b/debug_update_axisinfo_detail.py
@@ -0,0 +1,55 @@
+import matplotlib.pyplot as plt
+
+def print_datalim(*ax):
+    for i, ax_ in enumerate(ax, 1):
+        print(f"ax{i}: {ax_.dataLim.intervaly}", end=' / ')
+    print()
+
+df1_index = ['16 May', '17 May']
+df1_values = [-22.717708333333402, 26.584999999999937]
+
+fig, ax1 = plt.subplots()
+ax1.stackplot(df1_index, df1_values)
+print("After stackplot on ax1:", end=' ')
+print_datalim(ax1)
+
+ax2 = ax1.twinx()
+print("After twinx():", end=' ')
+print_datalim(ax1, ax2)
+
+# Let's manually run through _update_axisinfo step by step
+print("Simulating ax1.xaxis._update_axisinfo()...")
+
+axis = ax1.xaxis
+print(f"  axis.converter = {axis.converter}")
+print(f"  axis.units = {axis.units}")
+
+if axis.converter is None:
+    print("  Converter is None, returning early")
+else:
+    print("  Getting axisinfo...")
+    info = axis.converter.axisinfo(axis.units, axis)
+    print(f"  info = {info}")
+    
+    if info is None:
+        print("  Info is None, returning early")
+    else:
+        print(f"  info.majloc = {getattr(info, 'majloc', None)}")
+        print(f"  info.minloc = {getattr(info, 'minloc', None)}")
+        print(f"  info.majfmt = {getattr(info, 'majfmt', None)}")
+        print(f"  info.minfmt = {getattr(info, 'minfmt', None)}")
+        print(f"  info.label = {getattr(info, 'label', None)}")
+        
+        print("  About to call set_default_intervals()...")
+        print(f"  Before set_default_intervals: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+        axis.set_default_intervals()
+        print(f"  After set_default_intervals: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+
+print("Done with manual simulation")
+
+# Now actually trigger the real update
+print("Triggering real update_units...")
+x = ['16 May', '17 May']
+ax2.xaxis.update_units(x)
+print("After real update_units:", end=' ')
+print_datalim(ax1, ax2)

--- a/debug_axisinfo_steps.py
+++ b/debug_axisinfo_steps.py
@@ -0,0 +1,69 @@
+import matplotlib.pyplot as plt
+
+def print_datalim(*ax):
+    for i, ax_ in enumerate(ax, 1):
+        print(f"ax{i}: {ax_.dataLim.intervaly}", end=' / ')
+    print()
+
+df1_index = ['16 May', '17 May']
+df1_values = [-22.717708333333402, 26.584999999999937]
+
+fig, ax1 = plt.subplots()
+ax1.stackplot(df1_index, df1_values)
+print("After stackplot on ax1:", end=' ')
+print_datalim(ax1)
+
+ax2 = ax1.twinx()
+print("After twinx():", end=' ')
+print_datalim(ax1, ax2)
+
+# First, let's set up the units so we can trigger the axisinfo steps
+ax2.xaxis.update_units(['16 May', '17 May'])
+print("After update_units on ax2 (issue reproduced):", end=' ')
+print_datalim(ax1, ax2)
+
+# Now let's set up a fresh test to see each step
+fig2, ax3 = plt.subplots()
+ax3.stackplot(df1_index, df1_values)
+print("Fresh ax3 after stackplot:", end=' ')
+print_datalim(ax3)
+
+ax4 = ax3.twinx()
+print("Fresh ax4 after twinx:", end=' ')
+print_datalim(ax3, ax4)
+
+# Let's manually run through each step of _update_axisinfo on ax3.xaxis
+axis = ax3.xaxis
+
+print("Setting up converter and units...")
+# We need to set up the converter first 
+import matplotlib.units as munits
+converter = munits.registry.get_converter(['16 May', '17 May'])
+axis.converter = converter
+default = axis.converter.default_units(['16 May', '17 May'], axis)
+if default is not None and axis.units is None:
+    axis.units = default
+
+print(f"After setting up converter: ax3.dataLim.intervaly = {ax3.dataLim.intervaly}")
+
+info = axis.converter.axisinfo(axis.units, axis)
+
+print("Testing major locator...")
+if info.majloc is not None and axis.major.locator != info.majloc and axis.isDefault_majloc:
+    print("  Setting major locator...")
+    axis.set_major_locator(info.majloc)
+    print(f"  After major locator: ax3.dataLim.intervaly = {ax3.dataLim.intervaly}")
+    axis.isDefault_majloc = True
+
+print("Testing major formatter...")
+if info.majfmt is not None and axis.major.formatter != info.majfmt and axis.isDefault_majfmt:
+    print("  Setting major formatter...")
+    axis.set_major_formatter(info.majfmt)
+    print(f"  After major formatter: ax3.dataLim.intervaly = {ax3.dataLim.intervaly}")
+    axis.isDefault_majfmt = True
+
+print("Testing set_default_intervals...")
+axis.set_default_intervals()
+print(f"After set_default_intervals: ax3.dataLim.intervaly = {ax3.dataLim.intervaly}")
+
+print("Done with step-by-step testing")

--- a/debug_real_vs_manual.py
+++ b/debug_real_vs_manual.py
@@ -0,0 +1,87 @@
+import matplotlib.pyplot as plt
+
+def print_datalim(*ax):
+    for i, ax_ in enumerate(ax, 1):
+        print(f"ax{i}: {ax_.dataLim.intervaly}", end=' / ')
+    print()
+
+df1_index = ['16 May', '17 May']
+df1_values = [-22.717708333333402, 26.584999999999937]
+
+fig, ax1 = plt.subplots()
+ax1.stackplot(df1_index, df1_values)
+print("After stackplot on ax1:", end=' ')
+print_datalim(ax1)
+
+ax2 = ax1.twinx()
+print("After twinx():", end=' ')
+print_datalim(ax1, ax2)
+
+# Let's patch several methods to see the exact sequence in the real update_units call
+
+original_set_major_locator = ax1.xaxis.set_major_locator
+def debug_set_major_locator(locator):
+    print(f"ax1.xaxis.set_major_locator called with {locator}")
+    print(f"  Before: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    result = original_set_major_locator(locator)
+    print(f"  After: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    return result
+
+ax1.xaxis.set_major_locator = debug_set_major_locator
+
+original_set_major_formatter = ax1.xaxis.set_major_formatter
+def debug_set_major_formatter(formatter):
+    print(f"ax1.xaxis.set_major_formatter called with {formatter}")
+    print(f"  Before: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    result = original_set_major_formatter(formatter)
+    print(f"  After: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    return result
+
+ax1.xaxis.set_major_formatter = debug_set_major_formatter
+
+original_set_default_intervals = ax1.xaxis.set_default_intervals
+def debug_set_default_intervals():
+    print(f"ax1.xaxis.set_default_intervals called")
+    print(f"  Before: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    result = original_set_default_intervals()
+    print(f"  After: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    return result
+
+ax1.xaxis.set_default_intervals = debug_set_default_intervals
+
+# Also do the same for ax2
+original_set_major_locator_ax2 = ax2.xaxis.set_major_locator
+def debug_set_major_locator_ax2(locator):
+    print(f"ax2.xaxis.set_major_locator called with {locator}")
+    print(f"  Before: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    result = original_set_major_locator_ax2(locator)
+    print(f"  After: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    return result
+
+ax2.xaxis.set_major_locator = debug_set_major_locator_ax2
+
+original_set_major_formatter_ax2 = ax2.xaxis.set_major_formatter
+def debug_set_major_formatter_ax2(formatter):
+    print(f"ax2.xaxis.set_major_formatter called with {formatter}")
+    print(f"  Before: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    result = original_set_major_formatter_ax2(formatter)
+    print(f"  After: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    return result
+
+ax2.xaxis.set_major_formatter = debug_set_major_formatter_ax2
+
+original_set_default_intervals_ax2 = ax2.xaxis.set_default_intervals
+def debug_set_default_intervals_ax2():
+    print(f"ax2.xaxis.set_default_intervals called")
+    print(f"  Before: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    result = original_set_default_intervals_ax2()
+    print(f"  After: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    return result
+
+ax2.xaxis.set_default_intervals = debug_set_default_intervals_ax2
+
+print("About to call real update_units...")
+x = ['16 May', '17 May']
+ax2.xaxis.update_units(x)
+print("After real update_units:", end=' ')
+print_datalim(ax1, ax2)

--- a/debug_stale_property.py
+++ b/debug_stale_property.py
@@ -0,0 +1,89 @@
+import matplotlib.pyplot as plt
+
+def print_datalim(*ax):
+    for i, ax_ in enumerate(ax, 1):
+        print(f"ax{i}: {ax_.dataLim.intervaly}", end=' / ')
+    print()
+
+df1_index = ['16 May', '17 May']
+df1_values = [-22.717708333333402, 26.584999999999937]
+
+fig, ax1 = plt.subplots()
+ax1.stackplot(df1_index, df1_values)
+print("After stackplot on ax1:", end=' ')
+print_datalim(ax1)
+
+ax2 = ax1.twinx()
+print("After twinx():", end=' ')
+print_datalim(ax1, ax2)
+
+# Let's patch the stale setter for both axes to see what happens
+class StaleDebugger:
+    def __init__(self, axis, name):
+        self.axis = axis
+        self.name = name
+        self._stale = axis._stale
+        
+    def __get__(self, instance, owner):
+        return self._stale
+        
+    def __set__(self, instance, value):
+        print(f"{self.name}.stale set to {value}")
+        print(f"  Before: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+        self._stale = value
+        print(f"  After: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+
+# Actually, the stale property is probably not the issue. Let me try a different approach.
+
+# Let me check if there's any callback or observer pattern that might trigger 
+# when axis properties change
+
+# Let me patch the _update_axisinfo method more carefully to see the recursion
+original_update_axisinfo_ax1 = ax1.xaxis._update_axisinfo
+call_count_ax1 = 0
+
+def debug_update_axisinfo_ax1():
+    global call_count_ax1
+    call_count_ax1 += 1
+    print(f"ax1.xaxis._update_axisinfo called (#{call_count_ax1})")
+    print(f"  Before: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    
+    # Let's check if the dataLim gets corrupted inside this call
+    import traceback
+    if call_count_ax1 > 1:  # Only show stack trace for recursive calls
+        print("  RECURSIVE CALL - Stack trace:")
+        traceback.print_stack(limit=10)
+        print("  ---")
+    
+    result = original_update_axisinfo_ax1()
+    print(f"  After: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    return result
+
+ax1.xaxis._update_axisinfo = debug_update_axisinfo_ax1
+
+original_update_axisinfo_ax2 = ax2.xaxis._update_axisinfo
+call_count_ax2 = 0
+
+def debug_update_axisinfo_ax2():
+    global call_count_ax2
+    call_count_ax2 += 1
+    print(f"ax2.xaxis._update_axisinfo called (#{call_count_ax2})")
+    print(f"  Before: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    
+    import traceback
+    if call_count_ax2 > 1:  # Only show stack trace for recursive calls
+        print("  RECURSIVE CALL - Stack trace:")
+        traceback.print_stack(limit=10)
+        print("  ---")
+    
+    result = original_update_axisinfo_ax2()
+    print(f"  After: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    return result
+
+ax2.xaxis._update_axisinfo = debug_update_axisinfo_ax2
+
+print("About to call real update_units...")
+x = ['16 May', '17 May']
+ax2.xaxis.update_units(x)
+print("After real update_units:", end=' ')
+print_datalim(ax1, ax2)

--- a/debug_axisinfo_internal.py
+++ b/debug_axisinfo_internal.py
@@ -0,0 +1,79 @@
+import matplotlib.pyplot as plt
+
+def print_datalim(*ax):
+    for i, ax_ in enumerate(ax, 1):
+        print(f"ax{i}: {ax_.dataLim.intervaly}", end=' / ')
+    print()
+
+df1_index = ['16 May', '17 May']
+df1_values = [-22.717708333333402, 26.584999999999937]
+
+fig, ax1 = plt.subplots()
+ax1.stackplot(df1_index, df1_values)
+print("After stackplot on ax1:", end=' ')
+print_datalim(ax1)
+
+ax2 = ax1.twinx()
+print("After twinx():", end=' ')
+print_datalim(ax1, ax2)
+
+# Let's replace ax1.xaxis._update_axisinfo with a detailed step-by-step version
+def detailed_update_axisinfo_ax1():
+    axis = ax1.xaxis
+    print("=== Detailed ax1.xaxis._update_axisinfo ===")
+    print(f"Step 0: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    
+    if axis.converter is None:
+        print("Converter is None, returning")
+        return
+
+    info = axis.converter.axisinfo(axis.units, axis)
+    print(f"Step 1 (got axisinfo): ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+
+    if info is None:
+        print("Info is None, returning")
+        return
+        
+    if info.majloc is not None and axis.major.locator != info.majloc and axis.isDefault_majloc:
+        print("Setting major locator...")
+        axis.set_major_locator(info.majloc)
+        print(f"Step 2 (major locator): ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+        axis.isDefault_majloc = True
+        
+    if info.minloc is not None and axis.minor.locator != info.minloc and axis.isDefault_minloc:
+        print("Setting minor locator...")
+        axis.set_minor_locator(info.minloc)
+        print(f"Step 3 (minor locator): ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+        axis.isDefault_minloc = True
+        
+    if info.majfmt is not None and axis.major.formatter != info.majfmt and axis.isDefault_majfmt:
+        print("Setting major formatter...")
+        axis.set_major_formatter(info.majfmt)
+        print(f"Step 4 (major formatter): ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+        axis.isDefault_majfmt = True
+        
+    if info.minfmt is not None and axis.minor.formatter != info.minfmt and axis.isDefault_minfmt:
+        print("Setting minor formatter...")
+        axis.set_minor_formatter(info.minfmt)
+        print(f"Step 5 (minor formatter): ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+        axis.isDefault_minfmt = True
+        
+    if info.label is not None and axis.isDefault_label:
+        print("Setting label text...")
+        axis.set_label_text(info.label)
+        print(f"Step 6 (label): ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+        axis.isDefault_label = True
+
+    print("Calling set_default_intervals...")
+    axis.set_default_intervals()
+    print(f"Step 7 (set_default_intervals): ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    
+    print("=== End detailed ax1.xaxis._update_axisinfo ===")
+
+ax1.xaxis._update_axisinfo = detailed_update_axisinfo_ax1
+
+print("About to call real update_units...")
+x = ['16 May', '17 May']
+ax2.xaxis.update_units(x)
+print("After real update_units:", end=' ')
+print_datalim(ax1, ax2)

--- a/debug_callbacks.py
+++ b/debug_callbacks.py
@@ -0,0 +1,47 @@
+import matplotlib.pyplot as plt
+
+def print_datalim(*ax):
+    for i, ax_ in enumerate(ax, 1):
+        print(f"ax{i}: {ax_.dataLim.intervaly}", end=' / ')
+    print()
+
+df1_index = ['16 May', '17 May']
+df1_values = [-22.717708333333402, 26.584999999999937]
+
+fig, ax1 = plt.subplots()
+ax1.stackplot(df1_index, df1_values)
+print("After stackplot on ax1:", end=' ')
+print_datalim(ax1)
+
+ax2 = ax1.twinx()
+print("After twinx():", end=' ')
+print_datalim(ax1, ax2)
+
+# Let's patch the callbacks.process method for both axes
+original_process_ax1 = ax1.xaxis.callbacks.process
+
+def debug_process_ax1(signal, *args, **kwargs):
+    print(f"ax1.xaxis.callbacks.process('{signal}') called")
+    print(f"  Before: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    result = original_process_ax1(signal, *args, **kwargs)
+    print(f"  After: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    return result
+
+ax1.xaxis.callbacks.process = debug_process_ax1
+
+original_process_ax2 = ax2.xaxis.callbacks.process
+
+def debug_process_ax2(signal, *args, **kwargs):
+    print(f"ax2.xaxis.callbacks.process('{signal}') called")
+    print(f"  Before: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    result = original_process_ax2(signal, *args, **kwargs)
+    print(f"  After: ax1.dataLim.intervaly = {ax1.dataLim.intervaly}")
+    return result
+
+ax2.xaxis.callbacks.process = debug_process_ax2
+
+print("About to call real update_units...")
+x = ['16 May', '17 May']
+ax2.xaxis.update_units(x)
+print("After real update_units:", end=' ')
+print_datalim(ax1, ax2)

--- a/debug_children_types.py
+++ b/debug_children_types.py
@@ -0,0 +1,57 @@
+import matplotlib.pyplot as plt
+
+df1_index = ['16 May', '17 May']
+df1_values = [-22.717708333333402, 26.584999999999937]
+
+fig, ax1 = plt.subplots()
+result = ax1.stackplot(df1_index, df1_values)
+
+print("Type of stackplot result:", type(result))
+print("Type of first element:", type(result[0]))
+
+print("\nChildren of ax1:")
+for i, child in enumerate(ax1._children):
+    print(f"  {i}: {type(child).__name__}")
+
+print("\nLet's check what relim() would process:")
+import matplotlib.lines as mlines
+import matplotlib.patches as mpatches
+import matplotlib.image as mimage
+
+line_count = 0
+patch_count = 0
+image_count = 0
+other_count = 0
+
+for artist in ax1._children:
+    if isinstance(artist, mlines.Line2D):
+        line_count += 1
+        print(f"  Line2D: {artist}")
+    elif isinstance(artist, mpatches.Patch):
+        patch_count += 1
+        print(f"  Patch: {artist}")
+    elif isinstance(artist, mimage.AxesImage):
+        image_count += 1
+        print(f"  AxesImage: {artist}")
+    else:
+        other_count += 1
+        print(f"  Other ({type(artist).__name__}): {artist}")
+
+print(f"\nSummary:")
+print(f"  Line2D objects: {line_count}")
+print(f"  Patch objects: {patch_count}")
+print(f"  AxesImage objects: {image_count}")
+print(f"  Other objects: {other_count}")
+
+# Let's also check if PolyCollection has data limits
+from matplotlib.collections import PolyCollection
+for artist in ax1._children:
+    if isinstance(artist, PolyCollection):
+        print(f"\nPolyCollection found: {artist}")
+        print(f"  Has get_datalim method: {hasattr(artist, 'get_datalim')}")
+        if hasattr(artist, 'get_datalim'):
+            try:
+                datalim = artist.get_datalim(ax1.transData)
+                print(f"  Data limits: {datalim}")
+            except Exception as e:
+                print(f"  Error getting data limits: {e}")
