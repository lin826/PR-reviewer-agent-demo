--- a/sphinx/builders/html/transforms.py
+++ b/sphinx/builders/html/transforms.py
@@ -42,14 +42,21 @@
     def run(self, **kwargs: Any) -> None:
         matcher = NodeMatcher(nodes.literal, classes=["kbd"])
         for node in self.document.traverse(matcher):  # type: nodes.literal
-            parts = self.pattern.split(node[-1].astext())
+            text = node[-1].astext()
+            
+            # If the entire text is just a separator character, treat it as a single keystroke
+            if text in ('-', '+', '^'):
+                continue
+            
+            parts = self._parse_keystrokes(text)
             if len(parts) == 1:
                 continue
 
             node.pop()
             while parts:
                 key = parts.pop(0)
-                node += nodes.literal('', key, classes=["kbd"])
+                if key:  # Only add non-empty keys
+                    node += nodes.literal('', key, classes=["kbd"])
 
                 try:
                     # key separator (ex. -, +, ^)
@@ -57,6 +64,82 @@
                     node += nodes.Text(sep)
                 except IndexError:
                     pass
+
+    def _parse_keystrokes(self, text: str) -> list:
+        """Parse keystrokes, handling separators vs keystroke characters intelligently."""
+        # If text is a single separator character, don't split it
+        if text in ('-', '+', '^'):
+            return [text]
+        
+        # For compound keystrokes, we need to be more careful
+        # Split on separators, but be aware of edge cases
+        parts = []
+        current = ""
+        i = 0
+        
+        while i < len(text):
+            char = text[i]
+            
+            if char in ('-', '+', '^'):
+                # Check if this is a separator or part of a keystroke
+                if self._is_separator(text, i):
+                    # It's a separator
+                    if current:
+                        parts.append(current)
+                        current = ""
+                    parts.append(char)
+                else:
+                    # It's part of a keystroke
+                    current += char
+            elif char.isspace():
+                # Whitespace is always a separator
+                if current:
+                    parts.append(current)
+                    current = ""
+                # Collect all consecutive whitespace
+                ws = ""
+                while i < len(text) and text[i].isspace():
+                    ws += text[i]
+                    i += 1
+                parts.append(ws)
+                i -= 1  # Back up one since the loop will increment
+            else:
+                current += char
+            
+            i += 1
+        
+        # Add any remaining content
+        if current:
+            parts.append(current)
+        
+        return parts
+
+    def _is_separator(self, text: str, pos: int) -> bool:
+        """Determine if a character at given position is a separator or part of keystroke."""
+        char = text[pos]
+        
+        # Look at surrounding context to determine if this is a separator
+        before = text[:pos].strip()
+        after = text[pos + 1:].strip()
+        
+        # If there's nothing before or after, it's likely the keystroke itself
+        if not before or not after:
+            return False
+        
+        # If there are alphanumeric characters both before and after, it's likely a separator
+        if (before and before[-1].isalnum()) and (after and after[0].isalnum()):
+            return True
+        
+        # Special case: if before ends with a word and after starts with a word, it's a separator
+        if before and after:
+            # Check if we have word characters around the separator
+            before_word = before.split()[-1] if before.split() else ""
+            after_word = after.split()[0] if after.split() else ""
+            
+            if before_word and after_word:
+                return True
+        
+        return False
 
 
 def setup(app: Sphinx) -> Dict[str, Any]:
