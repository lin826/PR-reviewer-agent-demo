--- a/pylint/config/argument.py
+++ b/pylint/config/argument.py
@@ -114,9 +114,78 @@
 def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:
     """Transforms a comma separated list of regular expressions."""
     patterns: list[Pattern[str]] = []
-    for pattern in _csv_transformer(value):
+    for pattern in _smart_csv_transformer(value):
         patterns.append(_regex_transformer(pattern))
     return patterns
+
+
+def _smart_csv_transformer(value: str) -> Sequence[str]:
+    """Transform a comma separated string while preserving commas inside regex patterns.
+    
+    This handles commas that are part of regex syntax (inside braces {} or brackets [])
+    rather than actual CSV separators. For safety, it treats all braces and brackets
+    as depth-affecting, even if they are escaped, to avoid incorrectly splitting
+    regex patterns that contain literal braces/brackets with commas.
+    """
+    if not value:
+        return []
+    
+    parts = []
+    current_part = ""
+    brace_depth = 0
+    bracket_depth = 0
+    i = 0
+    
+    while i < len(value):
+        char = value[i]
+        
+        if char == '\\' and i + 1 < len(value):
+            # Handle escaped characters - add both the backslash and the next character
+            next_char = value[i + 1]
+            current_part += char + next_char
+            # Even escaped braces/brackets affect depth for conservative CSV parsing
+            if next_char == '{':
+                brace_depth += 1
+            elif next_char == '}':
+                brace_depth = max(0, brace_depth - 1)
+            elif next_char == '[':
+                bracket_depth += 1
+            elif next_char == ']':
+                bracket_depth = max(0, bracket_depth - 1)
+            i += 2  # Skip both the backslash and the escaped character
+        elif char == '{':
+            brace_depth += 1
+            current_part += char
+            i += 1
+        elif char == '}':
+            brace_depth = max(0, brace_depth - 1)
+            current_part += char
+            i += 1
+        elif char == '[':
+            bracket_depth += 1
+            current_part += char
+            i += 1
+        elif char == ']':
+            bracket_depth = max(0, bracket_depth - 1)
+            current_part += char
+            i += 1
+        elif char == ',' and brace_depth == 0 and bracket_depth == 0:
+            # This comma is a real CSV separator
+            stripped = current_part.strip()
+            if stripped:
+                parts.append(stripped)
+            current_part = ""
+            i += 1
+        else:
+            current_part += char
+            i += 1
+    
+    # Add the last part
+    stripped = current_part.strip()
+    if stripped:
+        parts.append(stripped)
+    
+    return parts
 
 
 def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:
