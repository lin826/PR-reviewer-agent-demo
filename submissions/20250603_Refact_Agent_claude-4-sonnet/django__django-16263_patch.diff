diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index 9735ce10c8..efb04d63e8 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -435,6 +435,119 @@ class Query(BaseExpression):
         annotation.set_source_expressions(new_exprs)
         return annotation, col_cnt
 
+    def _annotation_is_safe_to_remove_for_count(self, alias):
+        """
+        Check if an annotation can be safely removed for count() optimization.
+        
+        An annotation is safe to remove if:
+        1. It's not referenced in WHERE, ORDER BY, GROUP BY, HAVING, or other annotations
+        2. It doesn't involve complex expressions that might affect grouping
+        3. It's a simple aggregate that doesn't create joins or affect the result set
+        """
+        from django.db.models.expressions import Ref
+        from django.db.models.aggregates import Aggregate
+        
+        # Check if referenced in WHERE clause
+        if self.where:
+            for child in self.where.children:
+                if self._expression_references_annotation(child, alias):
+                    return False
+        
+        # Check if referenced in ORDER BY
+        if self.order_by:
+            for order_expr in self.order_by:
+                # Handle string ordering like 'field_name' or '-field_name'
+                if isinstance(order_expr, str):
+                    field_name = order_expr.lstrip('-')
+                    if field_name == alias:
+                        return False
+                # Handle expression ordering
+                elif hasattr(order_expr, 'expression'):
+                    if self._expression_references_annotation(order_expr.expression, alias):
+                        return False
+                elif self._expression_references_annotation(order_expr, alias):
+                    return False
+        
+        # Check if referenced in GROUP BY
+        if self.group_by and not isinstance(self.group_by, bool):
+            for group_expr in self.group_by:
+                if isinstance(group_expr, Ref) and group_expr.refs == alias:
+                    return False
+                elif self._expression_references_annotation(group_expr, alias):
+                    return False
+        
+        # Check if referenced in HAVING
+        if hasattr(self, 'having') and self.having:
+            for child in self.having.children:
+                if self._expression_references_annotation(child, alias):
+                    return False
+        
+        # Check if referenced in other annotations
+        for other_alias, annotation in self.annotations.items():
+            if other_alias != alias:
+                if self._expression_references_annotation(annotation, alias):
+                    return False
+        
+        # Additional safety checks for count() optimization
+        annotation = self.annotations[alias]
+        
+        # Only allow simple aggregates to be removed
+        if not isinstance(annotation, Aggregate):
+            return False
+            
+        # Check if the annotation involves joins or complex expressions
+        # that might affect the result set structure
+        if hasattr(annotation, 'get_source_expressions'):
+            source_expressions = annotation.get_source_expressions()
+            for expr in source_expressions:
+                # If the expression involves field lookups with LOOKUP_SEP,
+                # it might create joins that affect grouping
+                if hasattr(expr, 'name') and hasattr(expr.name, 'split'):
+                    if '__' in expr.name:
+                        return False
+                # If it's a complex expression, be conservative
+                if hasattr(expr, 'get_source_expressions') and expr.get_source_expressions():
+                    return False
+        
+        return True
+    
+    def _expression_references_annotation(self, expr, alias):
+        """
+        Recursively check if an expression references the given annotation alias.
+        """
+        from django.db.models.expressions import Ref
+        
+        if isinstance(expr, Ref):
+            return expr.refs == alias
+        
+        # Check if the expression has source expressions to traverse
+        if hasattr(expr, 'get_source_expressions'):
+            try:
+                source_expressions = expr.get_source_expressions()
+                if source_expressions:
+                    return any(
+                        self._expression_references_annotation(source_expr, alias)
+                        for source_expr in source_expressions
+                    )
+            except (AttributeError, TypeError):
+                pass
+        
+        # Check if it's a lookup that might reference the annotation
+        if hasattr(expr, 'lhs') and hasattr(expr, 'rhs'):
+            return (
+                self._expression_references_annotation(expr.lhs, alias) or
+                self._expression_references_annotation(expr.rhs, alias)
+            )
+        
+        # Check children for compound expressions
+        if hasattr(expr, 'children'):
+            return any(
+                self._expression_references_annotation(child, alias)
+                for child in expr.children
+            )
+        
+        return False
+
     def get_aggregation(self, using, added_aggregate_names):
         """
         Return the dictionary with the values of the existing aggregations.
@@ -446,12 +559,49 @@ class Query(BaseExpression):
             for alias, annotation in self.annotations.items()
             if alias not in added_aggregate_names
         ]
+        
+        # Filter out unused annotations to avoid unnecessary subqueries
+        # This optimization is specifically for count() queries where we only add a single
+        # __count annotation and want to exclude unused existing annotations
+        is_count_query = (
+            len(added_aggregate_names) == 1 and 
+            "__count" in added_aggregate_names
+        )
+        
+        if is_count_query:
+            # For count() queries, filter out annotations that are safe to remove
+            used_annotations = [
+                annotation
+                for alias, annotation in self.annotations.items()
+                if alias not in added_aggregate_names and not self._annotation_is_safe_to_remove_for_count(alias)
+            ]
+            
+            # Also filter the annotation select mask to exclude safe-to-remove annotations
+            # This prevents unused annotations from appearing in the SELECT clause
+            used_annotation_aliases = {
+                alias for alias in self.annotations.keys()
+                if alias in added_aggregate_names or not self._annotation_is_safe_to_remove_for_count(alias)
+            }
+            
+            if self.annotation_select_mask is not None:
+                # Keep only the annotations that are either being added or are not safe to remove
+                filtered_mask = self.annotation_select_mask.intersection(used_annotation_aliases)
+                # Add the new aggregate names to the mask
+                filtered_mask.update(added_aggregate_names)
+                self.set_annotation_mask(filtered_mask)
+            else:
+                # If mask is None (all annotations selected), create a mask with only used annotations
+                self.set_annotation_mask(used_annotation_aliases)
+        else:
+            # For other aggregation queries, keep the original behavior
+            used_annotations = existing_annotations
+        
         # Decide if we need to use a subquery.
         #
         # Existing annotations would cause incorrect results as get_aggregation()
         # must produce just one result and thus must not use GROUP BY. But we
-        # aren't smart enough to remove the existing annotations from the
-        # query, so those would force us to use GROUP BY.
+        # can now be smart enough to only consider annotations that are actually
+        # referenced in the query.
         #
         # If the query has limit or distinct, or uses set operations, then
         # those operations must be done in a subquery so that the query
@@ -460,7 +610,7 @@ class Query(BaseExpression):
         if (
             isinstance(self.group_by, tuple)
             or self.is_sliced
-            or existing_annotations
+            or used_annotations
             or self.distinct
             or self.combinator
         ):
@@ -484,7 +634,7 @@ class Query(BaseExpression):
                 # used.
                 has_existing_aggregate_annotations = any(
                     annotation
-                    for annotation in existing_annotations
+                    for annotation in used_annotations
                     if getattr(annotation, "contains_aggregate", True)
                 )
                 if inner_query.default_cols and has_existing_aggregate_annotations:
