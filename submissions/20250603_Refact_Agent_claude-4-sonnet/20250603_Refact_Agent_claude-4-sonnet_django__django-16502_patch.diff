diff --git a/django/core/servers/basehttp.py b/django/core/servers/basehttp.py
index fef5532e58..8b9967c757 100644
--- a/django/core/servers/basehttp.py
+++ b/django/core/servers/basehttp.py
@@ -224,6 +224,29 @@ class WSGIRequestHandler(simple_server.WSGIRequestHandler):
             self.rfile, self.wfile, self.get_stderr(), self.get_environ()
         )
         handler.request_handler = self  # backpointer for logging & connection closing
+        
+        # Override write method to handle HEAD requests properly
+        # RFC 2616 section 4.3: HEAD responses must not include a message body
+        if self.command == 'HEAD':
+            original_write = handler.write
+            
+            def head_aware_write(data):
+                # For HEAD requests, process headers normally but suppress body
+                assert type(data) is bytes, "write() argument must be a bytes instance"
+                
+                if not handler.status:
+                    raise AssertionError("write() before start_response()")
+                elif not handler.headers_sent:
+                    # Before the first output, send the stored headers
+                    handler.bytes_sent = len(data)  # Track bytes for Content-Length
+                    handler.send_headers()
+                else:
+                    # For subsequent writes (body data), just track bytes but don't write
+                    handler.bytes_sent += len(data)
+                # Don't call handler._write(data) for body data in HEAD requests
+                
+            handler.write = head_aware_write
+        
         handler.run(self.server.get_app())
 
 
diff --git a/tests/servers/test_basehttp.py b/tests/servers/test_basehttp.py
index a837505feb..30d52129bf 100644
--- a/tests/servers/test_basehttp.py
+++ b/tests/servers/test_basehttp.py
@@ -106,6 +106,95 @@ class WSGIRequestHandlerTestCase(SimpleTestCase):
 
         self.assertEqual(body, b"HTTP_SOME_HEADER:good")
 
+    def test_head_request_no_body(self):
+        """HEAD requests should return headers but no response body (RFC 2616)."""
+        
+        def test_app(environ, start_response):
+            """A WSGI app that returns a response with body."""
+            start_response("200 OK", [("Content-Type", "text/html")])
+            return [b"<html><body>Hello World</body></html>"]
+
+        # Test GET request first (should have body)
+        rfile_get = BytesIO()
+        rfile_get.write(b"GET / HTTP/1.1\r\n")
+        rfile_get.write(b"Host: testserver\r\n")
+        rfile_get.write(b"Connection: close\r\n\r\n")
+        rfile_get.seek(0)
+
+        class UnclosableBytesIO(BytesIO):
+            def close(self):
+                pass
+
+        wfile_get = UnclosableBytesIO()
+
+        def makefile_get(mode, *a, **kw):
+            if mode == "rb":
+                return rfile_get
+            elif mode == "wb":
+                return wfile_get
+
+        request_get = Stub(makefile=makefile_get)
+        server = Stub(base_environ={}, get_app=lambda: test_app)
+
+        with self.assertLogs("django.server", "INFO"):
+            WSGIRequestHandler(request_get, "192.168.0.2", server)
+
+        wfile_get.seek(0)
+        get_response = wfile_get.read().decode('utf-8', errors='replace')
+        
+        # Test HEAD request (should have same headers but no body)
+        rfile_head = BytesIO()
+        rfile_head.write(b"HEAD / HTTP/1.1\r\n")
+        rfile_head.write(b"Host: testserver\r\n")
+        rfile_head.write(b"Connection: close\r\n\r\n")
+        rfile_head.seek(0)
+
+        wfile_head = UnclosableBytesIO()
+
+        def makefile_head(mode, *a, **kw):
+            if mode == "rb":
+                return rfile_head
+            elif mode == "wb":
+                return wfile_head
+
+        request_head = Stub(makefile=makefile_head)
+
+        with self.assertLogs("django.server", "INFO"):
+            WSGIRequestHandler(request_head, "192.168.0.2", server)
+
+        wfile_head.seek(0)
+        head_response = wfile_head.read().decode('utf-8', errors='replace')
+
+        # Parse responses
+        self.assertIn('\r\n\r\n', get_response)
+        self.assertIn('\r\n\r\n', head_response)
+        
+        get_headers, get_body = get_response.split('\r\n\r\n', 1)
+        head_headers, head_body = head_response.split('\r\n\r\n', 1)
+
+        # GET should have body
+        self.assertIn('<html><body>Hello World</body></html>', get_body)
+        
+        # HEAD should have no body
+        self.assertEqual(head_body.strip(), '', 
+                        f"HEAD request returned body: {head_body!r}")
+        
+        # Headers should be similar (Content-Length should be the same)
+        self.assertIn('200 OK', get_headers)
+        self.assertIn('200 OK', head_headers)
+        self.assertIn('Content-Type: text/html', get_headers)
+        self.assertIn('Content-Type: text/html', head_headers)
+        
+        # Content-Length should be the same for both requests
+        import re
+        get_content_length = re.search(r'Content-Length: (\d+)', get_headers)
+        head_content_length = re.search(r'Content-Length: (\d+)', head_headers)
+        
+        self.assertIsNotNone(get_content_length, "GET response missing Content-Length")
+        self.assertIsNotNone(head_content_length, "HEAD response missing Content-Length")
+        self.assertEqual(get_content_length.group(1), head_content_length.group(1),
+                        "Content-Length differs between GET and HEAD")
+
 
 class WSGIServerTestCase(SimpleTestCase):
     request_factory = RequestFactory()
