diff --git a/django/utils/http.py b/django/utils/http.py
index 572cfb4347..6be2ebcd89 100644
--- a/django/utils/http.py
+++ b/django/utils/http.py
@@ -176,10 +176,24 @@ def parse_http_date(date):
     try:
         year = int(m.group('year'))
         if year < 100:
-            if year < 70:
-                year += 2000
+            # RFC 7231: two-digit year should be interpreted as the most recent
+            # year in the past that had the same last two digits, if the
+            # century-adjusted year would be more than 50 years in the future.
+            current_year = datetime.datetime.utcnow().year
+            current_century = (current_year // 100) * 100
+            
+            # Try current century first
+            candidate_year = current_century + year
+            
+            # If the candidate is in the past, try next century
+            if candidate_year < current_year:
+                candidate_year += 100
+            
+            # If more than 50 years in the future, use previous century
+            if candidate_year > current_year + 50:
+                year = candidate_year - 100
             else:
-                year += 1900
+                year = candidate_year
         month = MONTHS.index(m.group('mon').lower()) + 1
         day = int(m.group('day'))
         hour = int(m.group('hour'))
diff --git a/tests/utils_tests/test_http.py b/tests/utils_tests/test_http.py
index bc8bcfe977..24bad15707 100644
--- a/tests/utils_tests/test_http.py
+++ b/tests/utils_tests/test_http.py
@@ -328,6 +328,85 @@ class HttpDateProcessingTests(unittest.TestCase):
         parsed = parse_http_date('Sun Nov  6 08:49:37 0037')
         self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2037, 11, 6, 8, 49, 37))
 
+    def test_rfc7231_two_digit_year_compliance(self):
+        """
+        Test RFC 7231 compliance for two-digit years in RFC850 format.
+        Two-digit years should be interpreted as the most recent year in the past
+        that had the same last two digits, if the century-adjusted year would be
+        more than 50 years in the future.
+        """
+        # Mock the current year to make tests deterministic
+        import unittest.mock
+        
+        # Test with current year 2025
+        with unittest.mock.patch('django.utils.http.datetime') as mock_datetime:
+            mock_datetime.datetime.utcnow.return_value.year = 2025
+            mock_datetime.datetime.side_effect = lambda *args, **kw: datetime(*args, **kw)
+            
+            # Years that should be in 2000s (within 50 years of 2025)
+            test_cases_2000s = [
+                ('Sunday, 06-Nov-25 08:49:37 GMT', 2025),  # Current year
+                ('Sunday, 06-Nov-26 08:49:37 GMT', 2026),  # 1 year future
+                ('Sunday, 06-Nov-69 08:49:37 GMT', 2069),  # 44 years future
+                ('Sunday, 06-Nov-75 08:49:37 GMT', 2075),  # 50 years future (boundary)
+            ]
+            
+            for date_str, expected_year in test_cases_2000s:
+                with self.subTest(date=date_str, expected_year=expected_year):
+                    parsed = parse_http_date(date_str)
+                    result_date = datetime.utcfromtimestamp(parsed)
+                    self.assertEqual(result_date.year, expected_year)
+            
+            # Years that should be in 1900s (more than 50 years in future)
+            test_cases_1900s = [
+                ('Sunday, 06-Nov-76 08:49:37 GMT', 1976),  # 51 years future -> past
+                ('Sunday, 06-Nov-94 08:49:37 GMT', 1994),  # 69 years future -> past
+                ('Sunday, 06-Nov-99 08:49:37 GMT', 1999),  # 74 years future -> past
+                ('Sunday, 06-Nov-00 08:49:37 GMT', 2000),  # 75 years future -> past
+                ('Sunday, 06-Nov-24 08:49:37 GMT', 2024),  # 99 years future -> past
+            ]
+            
+            for date_str, expected_year in test_cases_1900s:
+                with self.subTest(date=date_str, expected_year=expected_year):
+                    parsed = parse_http_date(date_str)
+                    result_date = datetime.utcfromtimestamp(parsed)
+                    self.assertEqual(result_date.year, expected_year)
+
+    def test_rfc7231_different_current_years(self):
+        """
+        Test RFC 7231 compliance with different current years to ensure
+        the sliding window works correctly.
+        """
+        import unittest.mock
+        
+        # Test with current year 2070
+        with unittest.mock.patch('django.utils.http.datetime') as mock_datetime:
+            mock_datetime.datetime.utcnow.return_value.year = 2070
+            mock_datetime.datetime.side_effect = lambda *args, **kw: datetime(*args, **kw)
+            
+            # In 2070, year "25" should be 2125 (55 years future) -> 2025 (past)
+            parsed = parse_http_date('Sunday, 06-Nov-25 08:49:37 GMT')
+            result_date = datetime.utcfromtimestamp(parsed)
+            self.assertEqual(result_date.year, 2025)
+            
+            # In 2070, year "70" should be 2070 (current year)
+            parsed = parse_http_date('Sunday, 06-Nov-70 08:49:37 GMT')
+            result_date = datetime.utcfromtimestamp(parsed)
+            self.assertEqual(result_date.year, 2070)
+
+    def test_four_digit_years_unchanged(self):
+        """
+        Ensure that four-digit years in RFC1123 and ASCTIME formats
+        are not affected by the two-digit year logic.
+        """
+        # RFC1123 format with four-digit year
+        parsed = parse_http_date('Sun, 06 Nov 1994 08:49:37 GMT')
+        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))
+        
+        # ASCTIME format with four-digit year
+        parsed = parse_http_date('Sun Nov  6 08:49:37 1994')
+        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))
+
 
 class EscapeLeadingSlashesTests(unittest.TestCase):
     def test(self):
