diff --git a/django/db/models/enums.py b/django/db/models/enums.py
index f48143ddaf..1964cdcb1a 100644
--- a/django/db/models/enums.py
+++ b/django/db/models/enums.py
@@ -31,6 +31,8 @@ class ChoicesMeta(enum.EnumMeta):
         # that is passed in as "self" as the value to use when looking up the
         # label in the choices.
         cls.label = property(lambda self: cls._value2label_map_.get(self.value))
+        # Prevent Django templates from calling the enum class
+        cls.do_not_call_in_templates = True
         return enum.unique(cls)
 
     def __contains__(cls, member):
diff --git a/tests/model_enums/tests.py b/tests/model_enums/tests.py
index b9356479de..833e1cfb92 100644
--- a/tests/model_enums/tests.py
+++ b/tests/model_enums/tests.py
@@ -4,6 +4,7 @@ import ipaddress
 import uuid
 
 from django.db import models
+from django.template import Context, Engine
 from django.test import SimpleTestCase
 from django.utils.functional import Promise
 from django.utils.translation import gettext_lazy as _
@@ -149,6 +150,65 @@ class ChoicesTests(SimpleTestCase):
                 with self.subTest(member=member):
                     self.assertEqual(str(test[member.name]), str(member.value))
 
+    def test_do_not_call_in_templates(self):
+        """Test that enumeration classes have do_not_call_in_templates = True."""
+        for enum_class in [Gender, Suit, YearInSchool, Vehicle]:
+            with self.subTest(enum_class=enum_class):
+                self.assertTrue(hasattr(enum_class, 'do_not_call_in_templates'))
+                self.assertTrue(enum_class.do_not_call_in_templates)
+
+    def test_enum_in_templates(self):
+        """Test that enumeration types work correctly in Django templates."""
+        engine = Engine()
+        
+        # Test TextChoices
+        context = Context({'YearInSchool': YearInSchool})
+        
+        # Test direct enum member access
+        template = engine.from_string('{{ YearInSchool.FRESHMAN }}')
+        result = template.render(context)
+        self.assertEqual(result, 'FR')
+        
+        # Test enum member properties
+        template = engine.from_string('{{ YearInSchool.FRESHMAN.label }}')
+        result = template.render(context)
+        self.assertEqual(result, 'Freshman')
+        
+        template = engine.from_string('{{ YearInSchool.FRESHMAN.value }}')
+        result = template.render(context)
+        self.assertEqual(result, 'FR')
+        
+        # Test IntegerChoices
+        context = Context({'Suit': Suit})
+        
+        template = engine.from_string('{{ Suit.DIAMOND }}')
+        result = template.render(context)
+        self.assertEqual(result, '1')
+        
+        template = engine.from_string('{{ Suit.DIAMOND.label }}')
+        result = template.render(context)
+        self.assertEqual(result, 'Diamond')
+        
+        # Test enum comparison in templates
+        class Student:
+            def __init__(self, year):
+                self.year_in_school = year
+        
+        student = Student(YearInSchool.FRESHMAN)
+        context = Context({
+            'student': student,
+            'YearInSchool': YearInSchool,
+        })
+        
+        template = engine.from_string('{% if student.year_in_school == YearInSchool.FRESHMAN %}FRESHMAN{% else %}NOT_FRESHMAN{% endif %}')
+        result = template.render(context)
+        self.assertEqual(result, 'FRESHMAN')
+        
+        # Test negative comparison
+        template = engine.from_string('{% if student.year_in_school == YearInSchool.SENIOR %}SENIOR{% else %}NOT_SENIOR{% endif %}')
+        result = template.render(context)
+        self.assertEqual(result, 'NOT_SENIOR')
+
 
 class Separator(bytes, models.Choices):
     FS = b'\x1c', 'File Separator'
