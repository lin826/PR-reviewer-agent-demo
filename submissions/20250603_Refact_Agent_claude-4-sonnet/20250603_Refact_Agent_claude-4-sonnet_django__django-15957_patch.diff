diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py
index b192df4fbf..0ea594c6a0 100644
--- a/django/db/models/fields/related_descriptors.py
+++ b/django/db/models/fields/related_descriptors.py
@@ -132,6 +132,14 @@ class ForwardManyToOneDescriptor:
         related_field = self.field.foreign_related_fields[0]
         remote_field = self.field.remote_field
 
+        # If the queryset is sliced, we need to handle it specially to avoid
+        # the "Cannot filter a query once a slice has been taken" error.
+        slice_limits = None
+        if queryset.query.is_sliced:
+            slice_limits = (queryset.query.low_mark, queryset.query.high_mark)
+            queryset = queryset._chain()
+            queryset.query.clear_limits()
+
         # FIXME: This will need to be revisited when we introduce support for
         # composite fields. In the meantime we take this practical approach to
         # solve a regression on 1.6 when the reverse manager in hidden
@@ -147,6 +155,12 @@ class ForwardManyToOneDescriptor:
             query = {"%s__in" % self.field.related_query_name(): instances}
         queryset = queryset.filter(**query)
 
+        # Reapply the slice limits if they were originally present
+        if slice_limits is not None:
+            low_mark, high_mark = slice_limits
+            queryset.query.low_mark = low_mark
+            queryset.query.high_mark = high_mark
+
         # Since we're going to assign directly in the cache,
         # we must manage the reverse relation cache manually.
         if not remote_field.multiple:
@@ -400,12 +414,26 @@ class ReverseOneToOneDescriptor:
             queryset = self.get_queryset()
         queryset._add_hints(instance=instances[0])
 
+        # If the queryset is sliced, we need to handle it specially to avoid
+        # the "Cannot filter a query once a slice has been taken" error.
+        slice_limits = None
+        if queryset.query.is_sliced:
+            slice_limits = (queryset.query.low_mark, queryset.query.high_mark)
+            queryset = queryset._chain()
+            queryset.query.clear_limits()
+
         rel_obj_attr = self.related.field.get_local_related_value
         instance_attr = self.related.field.get_foreign_related_value
         instances_dict = {instance_attr(inst): inst for inst in instances}
         query = {"%s__in" % self.related.field.name: instances}
         queryset = queryset.filter(**query)
 
+        # Reapply the slice limits if they were originally present
+        if slice_limits is not None:
+            low_mark, high_mark = slice_limits
+            queryset.query.low_mark = low_mark
+            queryset.query.high_mark = high_mark
+
         # Since we're going to assign directly in the cache,
         # we must manage the reverse relation cache manually.
         for rel_obj in queryset:
@@ -715,12 +743,26 @@ def create_reverse_many_to_one_manager(superclass, rel):
             queryset._add_hints(instance=instances[0])
             queryset = queryset.using(queryset._db or self._db)
 
+            # If the queryset is sliced, we need to handle it specially to avoid
+            # the "Cannot filter a query once a slice has been taken" error.
+            slice_limits = None
+            if queryset.query.is_sliced:
+                slice_limits = (queryset.query.low_mark, queryset.query.high_mark)
+                queryset = queryset._chain()
+                queryset.query.clear_limits()
+
             rel_obj_attr = self.field.get_local_related_value
             instance_attr = self.field.get_foreign_related_value
             instances_dict = {instance_attr(inst): inst for inst in instances}
             query = {"%s__in" % self.field.name: instances}
             queryset = queryset.filter(**query)
 
+            # Reapply the slice limits if they were originally present
+            if slice_limits is not None:
+                low_mark, high_mark = slice_limits
+                queryset.query.low_mark = low_mark
+                queryset.query.high_mark = high_mark
+
             # Since we just bypassed this class' get_queryset(), we must manage
             # the reverse relation manually.
             for rel_obj in queryset:
@@ -1051,6 +1093,15 @@ def create_forward_many_to_many_manager(superclass, rel, reverse):
             queryset._add_hints(instance=instances[0])
             queryset = queryset.using(queryset._db or self._db)
 
+            # If the queryset is sliced, we need to handle it specially to avoid
+            # the "Cannot filter a query once a slice has been taken" error.
+            # We preserve the slice information and apply it after filtering.
+            slice_limits = None
+            if queryset.query.is_sliced:
+                slice_limits = (queryset.query.low_mark, queryset.query.high_mark)
+                queryset = queryset._chain()
+                queryset.query.clear_limits()
+
             query = {"%s__in" % self.query_field_name: instances}
             queryset = queryset._next_is_sticky().filter(**query)
 
@@ -1073,6 +1124,12 @@ def create_forward_many_to_many_manager(superclass, rel, reverse):
                     for f in fk.local_related_fields
                 }
             )
+
+            # Reapply the slice limits if they were originally present
+            if slice_limits is not None:
+                low_mark, high_mark = slice_limits
+                queryset.query.low_mark = low_mark
+                queryset.query.high_mark = high_mark
             return (
                 queryset,
                 lambda result: tuple(
diff --git a/tests/prefetch_related/tests.py b/tests/prefetch_related/tests.py
index 1ac17fde73..d9e6beb350 100644
--- a/tests/prefetch_related/tests.py
+++ b/tests/prefetch_related/tests.py
@@ -1908,3 +1908,95 @@ class NestedPrefetchTests(TestCase):
         self.assertIs(Room.house.is_cached(self.room), True)
         with self.assertNumQueries(0):
             house.rooms.first().house.address
+
+
+class PrefetchSliceTests(TestDataMixin, TestCase):
+    """
+    Tests for Prefetch objects with sliced querysets.
+    """
+
+    def test_prefetch_with_slice(self):
+        """
+        Test that Prefetch objects work correctly with sliced querysets.
+        """
+        # Test basic slice [0:2]
+        authors = Author.objects.prefetch_related(
+            Prefetch(
+                'books',
+                queryset=Book.objects.all()[:2],
+                to_attr='first_two_books',
+            )
+        ).all()
+        
+        # Force evaluation
+        list(authors)
+        
+        # Check that the slice was applied correctly
+        for author in authors:
+            self.assertLessEqual(len(author.first_two_books), 2)
+
+    def test_prefetch_with_slice_and_offset(self):
+        """
+        Test that Prefetch objects work with sliced querysets that have an offset.
+        """
+        authors = Author.objects.prefetch_related(
+            Prefetch(
+                'books',
+                queryset=Book.objects.all().order_by('id')[1:3],
+                to_attr='middle_books',
+            )
+        ).all()
+        
+        # Force evaluation
+        list(authors)
+        
+        # Check that the slice was applied correctly
+        for author in authors:
+            self.assertLessEqual(len(author.middle_books), 2)
+
+    def test_prefetch_with_slice_and_filtering(self):
+        """
+        Test that Prefetch objects work with sliced querysets that also have filtering.
+        """
+        authors = Author.objects.prefetch_related(
+            Prefetch(
+                'books',
+                queryset=Book.objects.filter(title__contains='e').order_by('id')[:1],
+                to_attr='filtered_books',
+            )
+        ).all()
+        
+        # Force evaluation
+        list(authors)
+        
+        # Check that the slice was applied correctly
+        for author in authors:
+            self.assertLessEqual(len(author.filtered_books), 1)
+            # Check that filtering was also applied
+            for book in author.filtered_books:
+                self.assertIn('e', book.title)
+
+    def test_multiple_prefetch_with_slices(self):
+        """
+        Test that multiple Prefetch objects with slices work correctly.
+        """
+        authors = Author.objects.prefetch_related(
+            Prefetch(
+                'books',
+                queryset=Book.objects.all()[:2],
+                to_attr='first_books',
+            ),
+            Prefetch(
+                'books',
+                queryset=Book.objects.all().order_by('-id')[:2],
+                to_attr='last_books',
+            )
+        ).all()
+        
+        # Force evaluation
+        list(authors)
+        
+        # Check that both slices were applied correctly
+        for author in authors:
+            self.assertLessEqual(len(author.first_books), 2)
+            self.assertLessEqual(len(author.last_books), 2)
