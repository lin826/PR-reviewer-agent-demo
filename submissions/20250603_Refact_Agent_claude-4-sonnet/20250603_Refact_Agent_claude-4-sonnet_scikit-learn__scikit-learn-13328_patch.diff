diff --git a/sklearn/linear_model/huber.py b/sklearn/linear_model/huber.py
index 65c686400..553b8f217 100644
--- a/sklearn/linear_model/huber.py
+++ b/sklearn/linear_model/huber.py
@@ -90,7 +90,7 @@ def _huber_loss_and_gradient(w, X, y, epsilon, alpha, sample_weight=None):
         grad = np.zeros(n_features + 1)
 
     # Gradient due to the squared loss.
-    X_non_outliers = -axis0_safe_slice(X, ~outliers_mask, n_non_outliers)
+    X_non_outliers = -axis0_safe_slice(X, ~outliers_mask, n_non_outliers).astype(float)
     grad[:n_features] = (
         2. / sigma * safe_sparse_dot(weighted_non_outliers, X_non_outliers))
 
diff --git a/sklearn/linear_model/tests/test_huber.py b/sklearn/linear_model/tests/test_huber.py
index 6a8b26133..510197b09 100644
--- a/sklearn/linear_model/tests/test_huber.py
+++ b/sklearn/linear_model/tests/test_huber.py
@@ -199,3 +199,41 @@ def test_huber_better_r2_score():
 
     # The huber model should also fit poorly on the outliers.
     assert_greater(ridge_outlier_score, huber_outlier_score)
+
+
+def test_huber_boolean_input():
+    # Test that HuberRegressor works with boolean input arrays
+    X, y = make_regression(n_samples=100, n_features=3, noise=2.0, random_state=42)
+    X_bool = X > 0
+    X_float = X_bool.astype(float)
+    
+    # Test that boolean input works without error
+    huber_bool = HuberRegressor()
+    huber_bool.fit(X_bool, y)
+    pred_bool = huber_bool.predict(X_bool)
+    
+    # Test that float input works (baseline)
+    huber_float = HuberRegressor()
+    huber_float.fit(X_float, y)
+    pred_float = huber_float.predict(X_float)
+    
+    # Results should be identical since boolean arrays are converted to float
+    assert_array_almost_equal(huber_bool.coef_, huber_float.coef_)
+    assert_almost_equal(huber_bool.intercept_, huber_float.intercept_)
+    assert_array_almost_equal(pred_bool, pred_float)
+    
+    # Test edge cases
+    # All True boolean array
+    X_all_true = np.ones((50, 2), dtype=bool)
+    y_simple = np.random.RandomState(0).randn(50)
+    huber_edge = HuberRegressor()
+    huber_edge.fit(X_all_true, y_simple)
+    
+    # All False boolean array
+    X_all_false = np.zeros((50, 2), dtype=bool)
+    huber_edge.fit(X_all_false, y_simple)
+    
+    # Mixed boolean array
+    rng = np.random.RandomState(0)
+    X_mixed = rng.choice([True, False], size=(50, 2))
+    huber_edge.fit(X_mixed, y_simple)
