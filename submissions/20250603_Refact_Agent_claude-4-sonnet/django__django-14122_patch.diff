diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py
index 850734709d..872d2ffe80 100644
--- a/django/db/models/sql/compiler.py
+++ b/django/db/models/sql/compiler.py
@@ -129,6 +129,11 @@ class SQLCompiler:
             # Skip References to the select clause, as all expressions in the
             # select clause are already part of the group by.
             if not is_ref:
+                # Skip ORDER BY expressions that come from Meta.ordering when
+                # _meta_ordering is set, as Meta.ordering should not affect
+                # GROUP BY clauses in aggregation queries.
+                if self._meta_ordering:
+                    continue
                 expressions.extend(expr.get_group_by_cols())
         having_group_by = self.having.get_group_by_cols() if self.having else ()
         for expr in having_group_by:
diff --git a/tests/aggregation/tests.py b/tests/aggregation/tests.py
index 49123396dd..f4a6574961 100644
--- a/tests/aggregation/tests.py
+++ b/tests/aggregation/tests.py
@@ -1340,3 +1340,47 @@ class AggregateTestCase(TestCase):
             ('Stuart Russell', 1),
             ('Peter Norvig', 2),
         ], lambda a: (a.name, a.contact_count), ordered=False)
+
+    def test_aggregation_meta_ordering_not_in_group_by(self):
+        """Meta.ordering fields should not be included in GROUP BY clauses."""
+        # Temporarily add Meta.ordering to the existing Author model
+        original_ordering = Author._meta.ordering
+        Author._meta.ordering = ['name']
+        
+        try:
+            # Test that Meta.ordering doesn't affect GROUP BY in aggregation
+            query = Author.objects.annotate(book_count=Count('book'))
+            compiler = query.query.get_compiler('default')
+            
+            # Get the GROUP BY and ORDER BY clauses
+            extra_select, order_by, group_by = compiler.pre_sql_setup()
+            
+            # Meta.ordering should create ORDER BY but not affect GROUP BY
+            self.assertGreater(len(order_by), 0, "Meta.ordering should create ORDER BY clause")
+            self.assertEqual(compiler._meta_ordering, ['name'], "Meta.ordering should be detected")
+            
+            # Compare with a query that has explicit order_by
+            query_explicit = Author.objects.annotate(book_count=Count('book')).order_by('name')
+            compiler_explicit = query_explicit.query.get_compiler('default')
+            _, order_by_explicit, group_by_explicit = compiler_explicit.pre_sql_setup()
+            
+            # GROUP BY should be the same regardless of Meta.ordering vs explicit ordering
+            self.assertEqual(len(group_by), len(group_by_explicit),
+                           "GROUP BY should be same for Meta.ordering vs explicit ordering")
+            
+            # But _meta_ordering should be None for explicit ordering
+            self.assertIsNone(compiler_explicit._meta_ordering,
+                            "Explicit order_by should override Meta.ordering")
+            
+            # Test with values() + annotate() - should also work correctly
+            query_values = Author.objects.values('name').annotate(book_count=Count('book'))
+            compiler_values = query_values.query.get_compiler('default')
+            _, order_by_values, group_by_values = compiler_values.pre_sql_setup()
+            
+            # Should have exactly 1 GROUP BY expression (the 'name' field)
+            self.assertEqual(len(group_by_values), 1, 
+                           "values() + annotate() should have exactly 1 GROUP BY expression")
+            
+        finally:
+            # Restore original ordering
+            Author._meta.ordering = original_ordering
