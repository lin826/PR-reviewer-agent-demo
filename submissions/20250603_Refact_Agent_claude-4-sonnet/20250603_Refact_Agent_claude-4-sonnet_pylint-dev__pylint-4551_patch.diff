diff --git a/Dockerfile b/Dockerfile
index aafe62a6a..35d66e942 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -1,7 +1,30 @@
-FROM python:3.9.0-alpine3.12
 
-COPY ./ /tmp/build
-WORKDIR /tmp/build
-RUN python setup.py install && rm -rf /tmp/build
+FROM swebench/sweb.eval.x86_64.pylint-dev_1776_pylint-4551:latest
 
-ENTRYPOINT ["pylint"]
+WORKDIR /install
+# Install docker cli
+# Add Docker's official GPG key:
+RUN apt-get update
+RUN apt-get install -y ca-certificates curl
+RUN install -m 0755 -d /etc/apt/keyrings
+RUN curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
+RUN chmod a+r /etc/apt/keyrings/docker.asc
+
+# Add the repository to Apt sources:
+RUN echo   "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu   $(. /etc/os-release && echo "${UBUNTU_CODENAME:-$VERSION_CODENAME}") stable" |   tee /etc/apt/sources.list.d/docker.list > /dev/null
+RUN apt-get update && apt-get install -y docker-ce-cli
+
+# Install required dependencies for SWE-bench (verification)
+RUN apt-get install -y -V ca-certificates lsb-release wget
+RUN wget https://apache.jfrog.io/artifactory/arrow/$(lsb_release --id --short | tr 'A-Z' 'a-z')/apache-arrow-apt-source-latest-$(lsb_release --codename --short).deb
+RUN apt-get update
+RUN apt-get install -y -V ./apache-arrow-apt-source-latest-$(lsb_release --codename --short).deb
+
+# Install SWE repo
+RUN git clone https://github.com/princeton-nlp/SWE-bench.git /SWE-bench
+WORKDIR /SWE-bench
+RUN apt-get install -y python3-venv
+RUN python3 -m venv .venv
+RUN . .venv/bin/activate      &&     pip install --upgrade pip &&     pip install . 
+
+WORKDIR /testbed
diff --git a/pylint/pyreverse/inspector.py b/pylint/pyreverse/inspector.py
index 8fa122022..f4a30db09 100644
--- a/pylint/pyreverse/inspector.py
+++ b/pylint/pyreverse/inspector.py
@@ -230,7 +230,42 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):
         handle instance_attrs_type
         """
         try:
-            values = set(node.infer())
+            # Check if this assignment is in a function (like __init__) and if the
+            # assigned value corresponds to a parameter with a type annotation
+            values = set()
+            
+            # Look for type annotations in the enclosing function
+            func_node = node.frame()
+            if isinstance(func_node, astroid.FunctionDef) and hasattr(func_node, 'args'):
+                # Find the assignment statement that contains this AssignAttr
+                assign_node = node.parent
+                while assign_node and not isinstance(assign_node, astroid.Assign):
+                    assign_node = assign_node.parent
+                
+                # Check if the assigned value is a parameter with type annotation
+                if assign_node and isinstance(assign_node.value, astroid.Name):
+                    param_name = assign_node.value.name
+                    # Find the parameter in the function arguments
+                    for i, arg in enumerate(func_node.args.args):
+                        if arg.name == param_name and func_node.args.annotations:
+                            # Check if this parameter has a type annotation
+                            if i < len(func_node.args.annotations) and func_node.args.annotations[i]:
+                                annotation = func_node.args.annotations[i]
+                                try:
+                                    # Try to infer the annotation to get the actual type
+                                    annotation_values = set(annotation.infer())
+                                    # Filter out Uninferable values and use annotation types
+                                    annotation_values = {v for v in annotation_values if v is not astroid.Uninferable}
+                                    if annotation_values:
+                                        values = annotation_values
+                                        break
+                                except astroid.InferenceError:
+                                    pass
+            
+            # If no type annotation found, fall back to inference
+            if not values:
+                values = set(node.infer())
+            
             current = set(parent.instance_attrs_type[node.attrname])
             parent.instance_attrs_type[node.attrname] = list(current | values)
         except astroid.InferenceError:
diff --git a/pylint/pyreverse/writer.py b/pylint/pyreverse/writer.py
index 0d80bb9ca..d486ee87a 100644
--- a/pylint/pyreverse/writer.py
+++ b/pylint/pyreverse/writer.py
@@ -135,10 +135,37 @@ class DotWriter(DiagramWriter):
             label = r"{}|{}\l|".format(label, r"\l".join(obj.attrs))
             for func in obj.methods:
                 if func.args.args:
-                    args = [arg.name for arg in func.args.args if arg.name != "self"]
+                    args = []
+                    for i, arg in enumerate(func.args.args):
+                        if arg.name == "self":
+                            continue
+                        arg_str = arg.name
+                        # Add type annotation if available
+                        if func.args.annotations and i < len(func.args.annotations) and func.args.annotations[i]:
+                            try:
+                                annotation = func.args.annotations[i]
+                                if hasattr(annotation, 'name'):
+                                    arg_str = f"{arg.name}: {annotation.name}"
+                                elif hasattr(annotation, 'as_string'):
+                                    arg_str = f"{arg.name}: {annotation.as_string()}"
+                            except (AttributeError, TypeError):
+                                pass
+                        args.append(arg_str)
                 else:
                     args = []
-                label = r"{}{}({})\l".format(label, func.name, ", ".join(args))
+                
+                # Add return type annotation if available
+                method_signature = f"{func.name}({', '.join(args)})"
+                if func.returns:
+                    try:
+                        if hasattr(func.returns, 'name'):
+                            method_signature += f" -> {func.returns.name}"
+                        elif hasattr(func.returns, 'as_string'):
+                            method_signature += f" -> {func.returns.as_string()}"
+                    except (AttributeError, TypeError):
+                        pass
+                
+                label = r"{}{}\l".format(label, method_signature)
             label = "{%s}" % label
         if is_exception(obj.node):
             return dict(fontcolor="red", label=label, shape="record")
