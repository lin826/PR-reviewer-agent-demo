diff --git a/sympy/printing/codeprinter.py b/sympy/printing/codeprinter.py
index ba0e746f5d..61439f97f4 100644
--- a/sympy/printing/codeprinter.py
+++ b/sympy/printing/codeprinter.py
@@ -451,6 +451,64 @@ def _print_Not(self, expr):
         PREC = precedence(expr)
         return self._operators['not'] + self.parenthesize(expr.args[0], PREC)
 
+    def _needs_parentheses_for_unary_minus(self, expr_str):
+        """
+        Check if an expression string needs parentheses when preceded by unary minus.
+        
+        In Python, unary minus has higher precedence than most binary operators,
+        so expressions like "x % y" need to be parenthesized as "-(x % y)" 
+        rather than "-x % y" to preserve the intended semantics.
+        """
+        # Check for operators that have lower precedence than unary minus
+        # In Python, unary minus has higher precedence than:
+        # - % (modulo)
+        # - // (floor division) 
+        # - / (division)
+        # - * (multiplication) - but this is handled by the multiplication logic
+        # - + and - (binary addition/subtraction)
+        # - << >> (bit shifts)
+        # - & (bitwise and)
+        # - ^ (bitwise xor)
+        # - | (bitwise or)
+        # - comparison operators
+        # - logical operators (and, or, not)
+        
+        # For now, focus on the most common cases that cause issues
+        low_precedence_ops = ['%', '//', '/', '+', '-', '<<', '>>', '&', '^', '|', 
+                             '==', '!=', '<', '>', '<=', '>=', 'and', 'or']
+        
+        # Check if any of these operators appear in the expression
+        # We need to be careful about operators that might be part of larger tokens
+        for op in low_precedence_ops:
+            if op in expr_str:
+                # Simple heuristic: if the operator is surrounded by spaces or 
+                # at word boundaries, it's likely a binary operator
+                import re
+                # Look for the operator with word boundaries or spaces around it
+                pattern = r'(\s|^)' + re.escape(op) + r'(\s|$)'
+                if re.search(pattern, expr_str):
+                    return True
+        
+        return False
+
+    def _parenthesize_for_mul(self, expr, prec):
+        """
+        Parenthesize an expression for use in multiplication context.
+        
+        This handles special cases where the printed form of an expression
+        has different precedence than the original SymPy expression.
+        """
+        from sympy.core.mod import Mod
+        
+        # Special handling for Mod expressions
+        if isinstance(expr, Mod):
+            # Mod expressions need to be parenthesized in multiplication context
+            # because % has the same precedence as * in Python
+            return "(" + self._print(expr) + ")"
+        else:
+            # Use normal parenthesize logic
+            return self.parenthesize(expr, prec)
+
     def _print_Mul(self, expr):
 
         prec = precedence(expr)
@@ -487,8 +545,8 @@ def _print_Mul(self, expr):
 
         a = a or [S.One]
 
-        a_str = [self.parenthesize(x, prec) for x in a]
-        b_str = [self.parenthesize(x, prec) for x in b]
+        a_str = [self._parenthesize_for_mul(x, prec) for x in a]
+        b_str = [self._parenthesize_for_mul(x, prec) for x in b]
 
         # To parenthesize Pow with exp = -1 and having more than one Symbol
         for item in pow_paren:
@@ -496,11 +554,27 @@ def _print_Mul(self, expr):
                 b_str[b.index(item.base)] = "(%s)" % b_str[b.index(item.base)]
 
         if not b:
-            return sign + '*'.join(a_str)
+            result = '*'.join(a_str)
+            if sign == "-" and self._needs_parentheses_for_unary_minus(result):
+                # Remove outer parentheses if they're already there from _parenthesize_for_mul
+                if result.startswith("(") and result.endswith(")"):
+                    return sign + result
+                else:
+                    return sign + "(" + result + ")"
+            else:
+                return sign + result
         elif len(b) == 1:
-            return sign + '*'.join(a_str) + "/" + b_str[0]
+            result = '*'.join(a_str)
+            if sign == "-" and self._needs_parentheses_for_unary_minus(result):
+                return sign + "(" + result + ")" + "/" + b_str[0]
+            else:
+                return sign + result + "/" + b_str[0]
         else:
-            return sign + '*'.join(a_str) + "/(%s)" % '*'.join(b_str)
+            result = '*'.join(a_str)
+            if sign == "-" and self._needs_parentheses_for_unary_minus(result):
+                return sign + "(" + result + ")" + "/(%s)" % '*'.join(b_str)
+            else:
+                return sign + result + "/(%s)" % '*'.join(b_str)
 
     def _print_not_supported(self, expr):
         try:
diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py
index e25986b4a0..7d501e1435 100644
--- a/sympy/utilities/tests/test_lambdify.py
+++ b/sympy/utilities/tests/test_lambdify.py
@@ -10,7 +10,7 @@
     true, false, And, Or, Not, ITE, Min, Max, floor, diff, IndexedBase, Sum,
     DotProduct, Eq, Dummy, sinc, erf, erfc, factorial, gamma, loggamma,
     digamma, RisingFactorial, besselj, bessely, besseli, besselk, S, beta,
-    betainc, betainc_regularized, fresnelc, fresnels)
+    betainc, betainc_regularized, fresnelc, fresnels, Mod)
 from sympy.codegen.cfunctions import expm1, log1p, exp2, log2, log10, hypot
 from sympy.codegen.numpy_nodes import logaddexp, logaddexp2
 from sympy.codegen.scipy_nodes import cosm1
@@ -1408,6 +1408,49 @@ def test_cupy_dotproduct():
         cupy.array([14])
 
 
+def test_lambdify_mod_precedence():
+    """
+    Test that lambdify correctly handles operator precedence with Mod expressions.
+    
+    This addresses the issue where expressions like -Mod(x, y) or x*Mod(y, z)
+    were incorrectly translated to -x % y or x*y % z instead of -(x % y) or x*(y % z).
+    """
+    # Test case 1: Unary minus with Mod
+    # -Mod(x, y) should become -(x % y), not -x % y
+    expr1 = -Mod(x, y)
+    f1 = lambdify([x, y], expr1, modules=[])
+    assert f1(3, 7) == -3  # -(3 % 7) = -3, not (-3) % 7 = 4
+    
+    # Test case 2: Multiplication with Mod
+    # x*Mod(y, 5) should become x*(y % 5), not x*y % 5
+    expr2 = x * Mod(y, 5)
+    f2 = lambdify([x, y], expr2, modules=[])
+    assert f2(3, 7) == 6  # 3*(7 % 5) = 3*2 = 6, not (3*7) % 5 = 1
+    
+    # Test case 3: Coefficient multiplication with Mod
+    # 4*Mod(x, 3) should become 4*(x % 3), not 4*x % 3
+    expr3 = 4 * Mod(x, 3)
+    f3 = lambdify([x], expr3, modules=[])
+    assert f3(5) == 8  # 4*(5 % 3) = 4*2 = 8, not (4*5) % 3 = 2
+    
+    # Test case 4: Negative coefficient with Mod
+    # -2*Mod(x, y) should become -(2*(x % y)), not -2*x % y
+    expr4 = -2 * Mod(x, y)
+    f4 = lambdify([x, y], expr4, modules=[])
+    assert f4(3, 7) == -6  # -(2*(3 % 7)) = -(2*3) = -6
+    
+    # Test with default modules too
+    f1_default = lambdify([x, y], expr1)
+    f2_default = lambdify([x, y], expr2)
+    f3_default = lambdify([x], expr3)
+    f4_default = lambdify([x, y], expr4)
+    
+    assert f1_default(3, 7) == -3
+    assert f2_default(3, 7) == 6
+    assert f3_default(5) == 8
+    assert f4_default(3, 7) == -6
+
+
 def test_lambdify_cse():
     def dummy_cse(exprs):
         return (), exprs
