diff --git a/sympy/physics/quantum/dagger.py b/sympy/physics/quantum/dagger.py
index 17da3cfd2c..95c2f97fb6 100644
--- a/sympy/physics/quantum/dagger.py
+++ b/sympy/physics/quantum/dagger.py
@@ -85,5 +85,19 @@ def __new__(cls, arg):
             return obj
         return Expr.__new__(cls, arg)
 
+    def __mul__(self, other):
+        """Multiplication of Dagger with other expressions.
+        
+        Special handling for IdentityOperator to ensure proper simplification:
+        Dagger(A) * I = Dagger(A)
+        """
+        # Import here to avoid circular imports - this is safe since we only 
+        # check the class name to avoid creating the import overhead on every call
+        if other.__class__.__name__ == 'IdentityOperator':
+            return self
+        
+        from sympy.core.mul import Mul
+        return Mul(self, other)
+
 adjoint.__name__ = "Dagger"
 adjoint._sympyrepr = lambda a, b: "Dagger(%s)" % b._print(a.args[0])
diff --git a/sympy/physics/quantum/operator.py b/sympy/physics/quantum/operator.py
index 306bfee64f..4baa35c4ec 100644
--- a/sympy/physics/quantum/operator.py
+++ b/sympy/physics/quantum/operator.py
@@ -309,9 +309,39 @@ def __mul__(self, other):
 
         if isinstance(other, Operator):
             return other
+        
+        # Handle Dagger objects which are quantum operators but don't inherit from Operator
+        # Use class name to avoid import overhead
+        if other.__class__.__name__ == 'Dagger':
+            return other
+        
+        # Handle Pow objects that represent operator inverses (e.g., U**(-1) from UnitaryOperator)
+        if (other.__class__.__name__ == 'Pow' and 
+            hasattr(other, 'base') and hasattr(other, 'exp') and
+            other.exp == -1 and isinstance(other.base, Operator)):
+            return other
 
         return Mul(self, other)
 
+    def __rmul__(self, other):
+        """Right multiplication: other * self"""
+        
+        if isinstance(other, Operator):
+            return other
+        
+        # Handle Dagger objects which are quantum operators but don't inherit from Operator
+        # Use class name to avoid import overhead
+        if other.__class__.__name__ == 'Dagger':
+            return other
+        
+        # Handle Pow objects that represent operator inverses (e.g., U**(-1) from UnitaryOperator)
+        if (other.__class__.__name__ == 'Pow' and 
+            hasattr(other, 'base') and hasattr(other, 'exp') and
+            other.exp == -1 and isinstance(other.base, Operator)):
+            return other
+
+        return Mul(other, self)
+
     def _represent_default_basis(self, **options):
         if not self.N or self.N == oo:
             raise NotImplementedError('Cannot represent infinite dimensional' +
