diff --git a/django/db/backends/postgresql/client.py b/django/db/backends/postgresql/client.py
index cf4df76882..210d579a8c 100644
--- a/django/db/backends/postgresql/client.py
+++ b/django/db/backends/postgresql/client.py
@@ -30,6 +30,21 @@ class DatabaseClient(BaseDatabaseClient):
         subprocess_env = os.environ.copy()
         if passwd:
             subprocess_env['PGPASSWORD'] = str(passwd)
+        
+        # Add SSL environment variables
+        ssl_options = {
+            'sslmode': 'PGSSLMODE',
+            'sslcert': 'PGSSLCERT',
+            'sslkey': 'PGSSLKEY',
+            'sslrootcert': 'PGSSLROOTCERT',
+            'sslcrl': 'PGSSLCRL',
+            'sslcompression': 'PGSSLCOMPRESSION',
+        }
+        
+        for conn_param, env_var in ssl_options.items():
+            if conn_param in conn_params:
+                subprocess_env[env_var] = str(conn_params[conn_param])
+        
         try:
             # Allow SIGINT to pass to psql to abort queries.
             signal.signal(signal.SIGINT, signal.SIG_IGN)
diff --git a/tests/dbshell/test_postgresql.py b/tests/dbshell/test_postgresql.py
index a33e7f6482..bb132e7a1c 100644
--- a/tests/dbshell/test_postgresql.py
+++ b/tests/dbshell/test_postgresql.py
@@ -94,3 +94,48 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):
             DatabaseClient.runshell_db({})
         # dbshell restores the original handler.
         self.assertEqual(sigint_handler, signal.getsignal(signal.SIGINT))
+
+    def test_ssl_certificate(self):
+        self.assertEqual(
+            self._run_it({
+                'database': 'dbname',
+                'user': 'someuser',
+                'password': 'somepassword',
+                'host': 'somehost',
+                'port': '444',
+                'sslmode': 'verify-ca',
+                'sslcert': '/path/to/client.crt',
+                'sslkey': '/path/to/client.key',
+                'sslrootcert': '/path/to/ca.crt',
+            }), (
+                ['psql', '-U', 'someuser', '-h', 'somehost', '-p', '444', 'dbname'],
+                'somepassword',
+            )
+        )
+
+    def test_ssl_certificate_env_vars(self):
+        """Test that SSL options are passed as environment variables."""
+        def _mock_subprocess_run(*args, env=os.environ, **kwargs):
+            self.subprocess_args = list(*args)
+            self.subprocess_env = env
+            return subprocess.CompletedProcess(self.subprocess_args, 0)
+        
+        with mock.patch('subprocess.run', new=_mock_subprocess_run):
+            DatabaseClient.runshell_db({
+                'database': 'dbname',
+                'user': 'someuser',
+                'password': 'somepassword',
+                'host': 'somehost',
+                'port': '444',
+                'sslmode': 'verify-ca',
+                'sslcert': '/path/to/client.crt',
+                'sslkey': '/path/to/client.key',
+                'sslrootcert': '/path/to/ca.crt',
+            })
+        
+        # Check that SSL environment variables are set
+        self.assertEqual(self.subprocess_env.get('PGSSLMODE'), 'verify-ca')
+        self.assertEqual(self.subprocess_env.get('PGSSLCERT'), '/path/to/client.crt')
+        self.assertEqual(self.subprocess_env.get('PGSSLKEY'), '/path/to/client.key')
+        self.assertEqual(self.subprocess_env.get('PGSSLROOTCERT'), '/path/to/ca.crt')
+        self.assertEqual(self.subprocess_env.get('PGPASSWORD'), 'somepassword')
