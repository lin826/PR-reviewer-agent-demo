diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py
index b6af5f5491..b2ea35160c 100644
--- a/django/utils/autoreload.py
+++ b/django/utils/autoreload.py
@@ -223,8 +223,28 @@ def get_child_arguments():
     # __spec__ is set when the server was started with the `-m` option,
     # see https://docs.python.org/3/reference/import.html#main-spec
     # __spec__ may not exist, e.g. when running in a Conda env.
-    if getattr(__main__, '__spec__', None) is not None and __main__.__spec__.parent:
-        args += ['-m', __main__.__spec__.parent]
+    if getattr(__main__, '__spec__', None) is not None:
+        spec = __main__.__spec__
+        module_name = getattr(spec, 'name', None)
+        
+        # If the module name ends with __main__, it means we're running a package
+        # (e.g., python -m django where django/__main__.py exists)
+        # In this case, use the parent package name
+        if module_name and module_name.endswith('.__main__'):
+            # Extract package name by removing .__main__ suffix
+            package_name = module_name[:-9]  # len('.__main__') == 9
+            args += ['-m', package_name]
+        elif module_name and module_name != '__main__' and spec.parent:
+            # For regular modules (e.g., python -m foo.bar.baz where baz.py exists)
+            # use the full module name
+            args += ['-m', module_name]
+        elif spec.parent:
+            # Fallback to parent for other cases
+            args += ['-m', spec.parent]
+        else:
+            # If no parent and no valid name, fall back to normal script execution
+            args += sys.argv
+            return args
         args += sys.argv[1:]
     elif not py_script.exists():
         # sys.argv[0] may not exist for several reasons on Windows.
diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py
index 7b91686bf5..2b1ed85b3e 100644
--- a/tests/utils_tests/test_autoreload.py
+++ b/tests/utils_tests/test_autoreload.py
@@ -179,7 +179,7 @@ class TestChildArguments(SimpleTestCase):
     def test_run_as_non_django_module(self):
         self.assertEqual(
             autoreload.get_child_arguments(),
-            [sys.executable, '-m', 'utils_tests.test_module', 'runserver'],
+            [sys.executable, '-m', 'tests.utils_tests.test_module', 'runserver'],
         )
 
     @mock.patch('sys.argv', [__file__, 'runserver'])
@@ -230,6 +230,26 @@ class TestChildArguments(SimpleTestCase):
                 [sys.executable, __file__, 'runserver']
             )
 
+    @mock.patch('sys.argv', ['/some/path/foo/bar/baz.py', 'runserver'])
+    @mock.patch('sys.warnoptions', [])
+    def test_run_as_dotted_module(self):
+        """
+        Test running as `python -m foo.bar.baz` where baz is a module.
+        This should use the full module name, not just the parent package.
+        """
+        fake_main = types.ModuleType('__main__')
+        fake_main.__file__ = '/some/path/foo/bar/baz.py'
+        fake_spec = types.SimpleNamespace()
+        fake_spec.name = 'foo.bar.baz'
+        fake_spec.parent = 'foo.bar'
+        fake_main.__spec__ = fake_spec
+        
+        with mock.patch.dict(sys.modules, {'__main__': fake_main}):
+            self.assertEqual(
+                autoreload.get_child_arguments(),
+                [sys.executable, '-m', 'foo.bar.baz', 'runserver']
+            )
+
 
 class TestUtilities(SimpleTestCase):
     def test_is_django_module(self):
