diff --git a/xarray/core/duck_array_ops.py b/xarray/core/duck_array_ops.py
index e64fea2c..e21095d3 100644
--- a/xarray/core/duck_array_ops.py
+++ b/xarray/core/duck_array_ops.py
@@ -325,7 +325,8 @@ def _create_nan_agg_method(name, dask_module=dask_array, coerce_strings=False):
             values = values.astype(object)
 
         func = None
-        if skipna or (skipna is None and values.dtype.kind in "cfO"):
+        # Use nanops version if skipna is True, or if dtype needs NaN handling, or if min_count is provided
+        if skipna or (skipna is None and values.dtype.kind in "cfO") or "min_count" in kwargs:
             nanname = "nan" + name
             func = getattr(nanops, nanname)
         else:
diff --git a/xarray/core/nanops.py b/xarray/core/nanops.py
index 41c8d258..e711f67b 100644
--- a/xarray/core/nanops.py
+++ b/xarray/core/nanops.py
@@ -27,9 +27,15 @@ def _maybe_null_out(result, axis, mask, min_count=1):
     xarray version of pandas.core.nanops._maybe_null_out
     """
     if hasattr(axis, "__len__"):  # if tuple or list
-        raise ValueError(
-            "min_count is not available for reduction with more than one dimensions."
-        )
+        # For multiple dimensions, use same logic as scalar case
+        # since we're reducing to a scalar result
+        dtype = getattr(result, "dtype", None)
+        # Skip processing for datetime/timedelta types (NAT_TYPES)
+        if dtype is None or dtype.kind not in ['M', 'm']:
+            null_mask = mask.size - mask.sum()
+            if null_mask < min_count:
+                result = np.nan
+        return result
 
     if axis is not None and getattr(result, "ndim", False):
         null_mask = (mask.shape[axis] - mask.sum(axis) - min_count) < 0
