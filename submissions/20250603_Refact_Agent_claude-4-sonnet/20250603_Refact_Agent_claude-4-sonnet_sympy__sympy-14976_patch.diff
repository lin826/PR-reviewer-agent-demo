diff --git a/sympy/printing/pycode.py b/sympy/printing/pycode.py
index d06901425d..8953841df6 100644
--- a/sympy/printing/pycode.py
+++ b/sympy/printing/pycode.py
@@ -331,6 +331,24 @@ def _print_Float(self, e):
         args = str(tuple(map(int, e._mpf_)))
         return '{func}({args})'.format(func=self._module_format('mpmath.mpf'), args=args)
 
+    def _print_Rational(self, expr):
+        """
+        Print Rational as mpmath expressions to maintain precision.
+        """
+        if expr.q == 1:
+            # Integer case: just use mpmath.mpf
+            return '{func}({arg})'.format(
+                func=self._module_format('mpmath.mpf'),
+                arg=repr(str(expr.p))
+            )
+        else:
+            # Rational case: use mpmath division
+            return '{func}({num})/{func}({den})'.format(
+                func=self._module_format('mpmath.mpf'),
+                num=repr(str(expr.p)),
+                den=repr(str(expr.q))
+            )
+
 
     def _print_uppergamma(self, e):
         return "{0}({1}, {2}, {3})".format(
@@ -353,6 +371,24 @@ def _print_log1p(self, e):
         return '{0}({1}+1)'.format(
             self._module_format('mpmath.log'), self._print(e.args[0]))
 
+    def _print_Rational(self, expr):
+        """
+        Print Rational as mpmath expressions to maintain precision.
+        """
+        if expr.q == 1:
+            # Integer case: just use mpmath.mpf
+            return '{func}({arg})'.format(
+                func=self._module_format('mpmath.mpf'),
+                arg=repr(str(expr.p))
+            )
+        else:
+            # Rational case: use mpmath division
+            return '{func}({num})/{func}({den})'.format(
+                func=self._module_format('mpmath.mpf'),
+                num=repr(str(expr.p)),
+                den=repr(str(expr.q))
+            )
+
 for k in MpmathPrinter._kf:
     setattr(MpmathPrinter, '_print_%s' % k, _print_known_func)
 
diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py
index 149a7e3136..064ba46f20 100644
--- a/sympy/utilities/tests/test_lambdify.py
+++ b/sympy/utilities/tests/test_lambdify.py
@@ -787,6 +787,51 @@ def intervalrepr(expr):
     assert isinstance(func1(), mpi)
     assert isinstance(func2(), mpi)
 
+
+def test_mpmath_rational_precision():
+    """Test that lambdify with mpmath properly wraps rationals for precision"""
+    import inspect
+    
+    # Test basic rational wrapping
+    x = sympy.Symbol('x')
+    expr = sympy.S(1)/3
+    f = lambdify(x, expr, 'mpmath')
+    
+    # Check that the generated code uses mpf wrapping
+    source = inspect.getsource(f)
+    assert 'mpf(' in source
+    assert 'mpf(\'1\')/mpf(\'3\')' in source
+    
+    # Test precision preservation
+    original_dps = mpmath.mp.dps
+    try:
+        mpmath.mp.dps = 50
+        result = f(0)  # x value doesn't matter for constant
+        
+        # Should have high precision
+        result_str = str(result)
+        assert len(result_str) > 20
+        
+        # Should be different from Python division
+        python_result = 1/3
+        assert str(result) != str(python_result)
+        
+    finally:
+        mpmath.mp.dps = original_dps
+    
+    # Test negative rationals
+    expr_neg = sympy.S(-5)/7
+    f_neg = lambdify(x, expr_neg, 'mpmath')
+    source_neg = inspect.getsource(f_neg)
+    assert 'mpf(\'-5\')/mpf(\'7\')' in source_neg
+    
+    # Test rationals in expressions
+    expr_complex = x**2 + sympy.S(1)/3 * x + sympy.S(5)/7
+    f_complex = lambdify(x, expr_complex, 'mpmath')
+    source_complex = inspect.getsource(f_complex)
+    assert 'mpf(\'1\')/mpf(\'3\')' in source_complex
+    assert 'mpf(\'5\')/mpf(\'7\')' in source_complex
+
 def test_true_false():
     # We want exact is comparison here, not just ==
     assert lambdify([], true)() is True
