diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py
index c957ffa564..5d4c7b03e0 100644
--- a/django/db/models/query_utils.py
+++ b/django/db/models/query_utils.py
@@ -41,6 +41,12 @@ class Q(tree.Node):
 
     def _combine(self, other, conn):
         if not isinstance(other, Q):
+            # Accept any boolean/conditional expression (Exists, Case, F(Boolean),
+            # â€¦) in addition to plain Q objects. The ORM marks those expressions
+            # with `conditional = True` (see django.db.models.expressions.Combinable).
+            if getattr(other, "conditional", False):
+                # Wrap both operands in Q() so they can be merged normally.
+                return (Q(self) & Q(other)) if conn == self.AND else (Q(self) | Q(other))
             raise TypeError(other)
 
         # If the other Q() is empty, ignore it and just use `self`.
@@ -63,6 +69,27 @@ class Q(tree.Node):
 
     def __and__(self, other):
         return self._combine(other, self.AND)
+        
+    def __rand__(self, other):
+        """
+        Symmetric counterpart to __and__. Called when a Q() instance is on the
+        right-hand side of '&'. Mirrors the logic of Combinable.__and__.
+        """
+        if isinstance(other, Q):
+            return other._combine(self, self.AND)
+        if getattr(other, "conditional", False):
+            return Q(other) & self
+        return NotImplemented
+        
+    def __ror__(self, other):
+        """
+        Symmetric counterpart to __or__. Provides commutativity for '|'.
+        """
+        if isinstance(other, Q):
+            return other._combine(self, self.OR)
+        if getattr(other, "conditional", False):
+            return Q(other) | self
+        return NotImplemented
 
     def __invert__(self):
         obj = type(self)()
