diff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py
index 8915616b..2198242a 100644
--- a/seaborn/_core/plot.py
+++ b/seaborn/_core/plot.py
@@ -1569,6 +1569,9 @@ class Plotter:
                         break
                 else:
                     title = self._resolve_label(p, var, data.names[var])
+                    # Add the suffix if it exists
+                    if hasattr(scales[var], '_legend_suffix'):
+                        title += scales[var]._legend_suffix
                     entry = (title, data.ids[var]), [var], (values, labels)
                     schema.append(entry)
 
diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py
index 55874bf2..98780edc 100644
--- a/seaborn/_core/scales.py
+++ b/seaborn/_core/scales.py
@@ -8,6 +8,54 @@ from typing import Any, Callable, Tuple, Optional, ClassVar
 
 import numpy as np
 import matplotlib as mpl
+
+def format_legend_for_large_values(values, labels=None):
+    """
+    Format legend values and labels for large numbers with appropriate scaling.
+    
+    Parameters:
+    -----------
+    values : list
+        The values to be displayed in the legend
+    labels : list, optional
+        Existing labels, if any
+    
+    Returns:
+    --------
+    values : list
+        The original values (unchanged)
+    labels : list
+        The formatted labels with appropriate scaling
+    scale_suffix : str
+        A suffix to add to the legend title indicating the scaling
+    """
+    if not values:
+        return values, labels or [], ""
+    
+    # Find the order of magnitude of the largest value
+    max_val = max(abs(v) for v in values if v is not None and not np.isnan(v))
+    if max_val == 0:
+        return values, labels or [str(v) for v in values], ""
+    
+    order = int(np.floor(np.log10(max_val)))
+    
+    # Only apply scaling for large numbers
+    if order >= 6:  # 1,000,000 or larger
+        scale_power = order // 3 * 3  # Round to nearest thousand, million, etc.
+        scale_factor = 10 ** scale_power
+        
+        # Format the labels with appropriate precision
+        scaled_values = [v / scale_factor for v in values]
+        if max(scaled_values) < 10:
+            labels = [f"{v:.1f}" for v in scaled_values]
+        else:
+            labels = [f"{v:.0f}" for v in scaled_values]
+        
+        # Return the values, labels, and a suffix for the legend title
+        return values, labels, f" (Ã—10^{scale_power})"
+    
+    # For smaller numbers, just use the values directly
+    return values, labels or [str(int(v)) for v in values], ""
 from matplotlib.ticker import (
     Locator,
     Formatter,
@@ -379,6 +427,13 @@ class ContinuousBase(Scale):
             locs = axis.major.locator()
             locs = locs[(vmin <= locs) & (locs <= vmax)]
             labels = axis.major.formatter.format_ticks(locs)
+            
+            # Apply our fix for large values
+            locs, labels, suffix = format_legend_for_large_values(list(locs), list(labels))
+            
+            # Store the suffix for later use
+            new._legend_suffix = suffix
+            
             new._legend = list(locs), list(labels)
 
         return new
