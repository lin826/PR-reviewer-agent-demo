diff --git a/django/core/serializers/python.py b/django/core/serializers/python.py
index 36048601af..5e576183c6 100644
--- a/django/core/serializers/python.py
+++ b/django/core/serializers/python.py
@@ -79,12 +79,30 @@ class Serializer(base.Serializer):
                     return self._value_from_field(value, value._meta.pk)
 
                 def queryset_iterator(obj, field):
-                    return getattr(obj, field.name).only("pk").iterator()
-
-            m2m_iter = getattr(obj, "_prefetched_objects_cache", {}).get(
-                field.name,
-                queryset_iterator(obj, field),
-            )
+                    # If the relation is already prefetched, use the cached
+                    # objects â€“ no query, no conflict.
+                    prefetched = getattr(
+                        obj, "_prefetched_objects_cache", {}
+                    ).get(field.name)
+                    if prefetched is not None:
+                        return prefetched
+
+                    # Build a clean queryset for the serializer:
+                    # - start with manager.all() so we have a real QuerySet
+                    # - strip any select_related() imposed by a custom
+                    #   default manager
+                    # - keep the 5.0 optimisation of fetching only the PK
+                    try:
+                        qs = getattr(obj, field.name).all()
+                        if qs.query.select_related:
+                            qs = qs.select_related(None)
+                        return qs.only("pk").iterator()
+                    except (AttributeError, ValueError):
+                        # If we can't get a queryset, return an empty list
+                        return []
+
+            # queryset_iterator now handles prefetched objects internally
+            m2m_iter = queryset_iterator(obj, field)
             self._current[field.name] = [m2m_value(related) for related in m2m_iter]
 
     def getvalue(self):
