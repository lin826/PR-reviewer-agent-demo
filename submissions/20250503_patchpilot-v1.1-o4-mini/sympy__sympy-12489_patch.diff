diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py
index 007fa70..6e594b0 100644
--- a/sympy/combinatorics/permutations.py
+++ b/sympy/combinatorics/permutations.py
@@ -924,31 +924,53 @@ class Permutation(Basic):
         obj._size = size
         return obj
 
-    @staticmethod
-    def _af_new(perm):
-        """A method to produce a Permutation object from a list;
-        the list is bound to the _array_form attribute, so it must
-        not be modified; this method is meant for internal use only;
-        the list ``a`` is supposed to be generated as a temporary value
-        in a method, so p = Perm._af_new(a) is the only object
-        to hold a reference to ``a``::
-
-        Examples
-        ========
 
-        >>> from sympy.combinatorics.permutations import Perm
-        >>> Perm.print_cyclic = False
-        >>> a = [2,1,3,0]
-        >>> p = Perm._af_new(a)
-        >>> p
-        Permutation([2, 1, 3, 0])
+    @classmethod
+    def _af_new(cls, perm):
+        """
+        Create a Permutation (or subclass) instance from the given array-form
+        list ``perm``.
 
+        The method is now a classmethod so that subclasses of ``Permutation``
+        propagate correctly through all helper routines that rely on
+        ``_af_new``.  When called directly on a subclass, that subclass is
+        used.  When invoked via the global alias or the base class we attempt
+        to discover an appropriate subclass by inspecting the caller's frame.
         """
-        p = Basic.__new__(Perm, perm)
+        import inspect
+
+        target_cls = cls
+        # If invoked via the base class (or its global alias), try to infer
+        # the intended subclass from the caller's local scope.
+        if target_cls is Perm:
+            frame = inspect.currentframe()
+            try:
+                frame = frame.f_back  # one level up
+                while frame:
+                    for val in frame.f_locals.values():
+                        # If a Permutation instance is found, use its type.
+                        if isinstance(val, Perm):
+                            cand = type(val)
+                            if issubclass(cand, Perm):
+                                target_cls = cand
+                                break
+                        # Or if a subclass object itself is found, use that.
+                        if isinstance(val, type) and issubclass(val, Perm):
+                            target_cls = val
+                            break
+                    if target_cls is not Perm:
+                        break
+                    frame = frame.f_back
+            finally:
+                # Avoid reference cycles (see inspect.currentframe docs).
+                del frame
+
+        p = Basic.__new__(target_cls, perm)
         p._array_form = perm
         p._size = len(perm)
         return p
 
+
     def _hashable_content(self):
         # the array_form (a list) is the Permutation arg, so we need to
         # return a tuple, instead
