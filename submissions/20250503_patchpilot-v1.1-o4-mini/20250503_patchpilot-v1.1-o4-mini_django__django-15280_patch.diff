diff --git a/django/db/models/query.py b/django/db/models/query.py
index 1013471..24e1416 100644
--- a/django/db/models/query.py
+++ b/django/db/models/query.py
@@ -23,8 +23,36 @@ from django.db.models.query_utils import FilteredRelation, Q
 from django.db.models.sql.constants import CURSOR, GET_ITERATOR_CHUNK_SIZE
 from django.db.models.utils import create_namedtuple_class, resolve_callables
 from django.utils import timezone
+
 from django.utils.functional import cached_property, partition
 
+# ----------------------------------------------------------------------
+# Internal helper utilities
+# ----------------------------------------------------------------------
+def _merge_loaded_values(target, source):
+    """
+    Merge attribute values and relation caches from `source` into `target`
+    without overwriting any data already present on `target`.
+
+    This is used when two instances referring to the same database row are
+    created with different sets of deferred fields (e.g. due to a combination
+    of only()/defer() and prefetch_related()). By copying the alreadyâ€‘loaded
+    values from the discarded instance onto the instance that is kept, Django
+    avoids issuing additional SELECTs when accessing those attributes later.
+    """
+    # Copy simple attribute values.
+    for attr_name, attr_value in source.__dict__.items():
+        if attr_name not in target.__dict__:
+            target.__dict__[attr_name] = attr_value
+
+    # Copy caches for related objects.
+    source_cache = getattr(source._state, 'fields_cache', {})
+    target_cache = getattr(target._state, 'fields_cache', {})
+    for cache_key, cache_value in source_cache.items():
+        if cache_key not in target_cache:
+            target_cache[cache_key] = cache_value
+
+
 # The maximum number of results to fetch in a get() query.
 MAX_GET_RESULTS = 21
 
