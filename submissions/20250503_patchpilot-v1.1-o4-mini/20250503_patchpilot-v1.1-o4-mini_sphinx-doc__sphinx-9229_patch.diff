diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py
index 8cd9189..a8b0e7e 100644
--- a/sphinx/ext/autodoc/__init__.py
+++ b/sphinx/ext/autodoc/__init__.py
@@ -10,8 +10,11 @@
     :license: BSD, see LICENSE for details.
 """
 
+
+import ast
 import re
 import warnings
+
 from inspect import Parameter, Signature
 from types import ModuleType
 from typing import (TYPE_CHECKING, Any, Callable, Dict, Iterator, List, Optional, Sequence,
@@ -1986,6 +1989,7 @@ class DataDocumenter(GenericAliasMixin, NewTypeMixin, TypeVarMixin,
         real_modname = self.get_attr(self.parent or self.object, '__module__', None)
         return real_modname or self.modname
 
+
     def get_module_comment(self, attrname: str) -> Optional[List[str]]:
         try:
             analyzer = ModuleAnalyzer.for_module(self.modname)
@@ -1996,8 +2000,38 @@ class DataDocumenter(GenericAliasMixin, NewTypeMixin, TypeVarMixin,
         except PycodeError:
             pass
 
+        # AST‑based fall‑back: inspect the module’s source to find a string
+        # literal placed immediately after the variable assignment.
+        try:
+            analyzer = ModuleAnalyzer.for_module(self.modname)
+            module_path = analyzer.srcname
+            with open(module_path, 'r', encoding='utf-8') as f:
+                source = f.read()
+            module_ast = ast.parse(source)
+            body = module_ast.body
+            for index, node in enumerate(body):
+                if isinstance(node, (ast.Assign, ast.AnnAssign)):
+                    target: Optional[str] = None
+                    if isinstance(node, ast.Assign):
+                        if node.targets and isinstance(node.targets[0], ast.Name):
+                            target = node.targets[0].id
+                    else:  # AnnAssign
+                        if isinstance(node.target, ast.Name):
+                            target = node.target.id
+                    if target == attrname and index + 1 < len(body):
+                        next_node = body[index + 1]
+                        if (isinstance(next_node, ast.Expr) and
+                                isinstance(next_node.value, ast.Constant) and
+                                isinstance(next_node.value.value, str)):
+                            docstring = next_node.value.value
+                            return docstring.splitlines()
+        except Exception:
+            # Silently ignore any failure in the fall‑back mechanism.
+            pass
+
         return None
 
+
     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:
         # Check the variable has a docstring-comment
         comment = self.get_module_comment(self.objpath[-1])
