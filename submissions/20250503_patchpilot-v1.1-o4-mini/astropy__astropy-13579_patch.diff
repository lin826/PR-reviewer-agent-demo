diff --git a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py
index ecc3c31..08746b3 100644
--- a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py
+++ b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py
@@ -146,10 +146,34 @@ class SlicedLowLevelWCS(BaseWCSWrapper):
                                        for ip in range(self._wcs.pixel_n_dim)])[0]
 
         # axis_correlation_matrix[world, pixel]
+
         self._world_keep = np.nonzero(
             self._wcs.axis_correlation_matrix[:, self._pixel_keep].any(axis=1))[0]
 
+        # ------------------------------------------------------------------
+        # Cache the reference world values for any world axes that are being
+        # dropped by this slice.  We build a reference pixel position where
+        # every sliced‑away axis is set to the integer index provided in the
+        # slice, while the retained axes are set to zero.  Converting this
+        # position to world coordinates provides physically consistent default
+        # values that will later be re‑used when calling ``world_to_pixel``.
+        # ------------------------------------------------------------------
+        pixel_reference = []
+        for ipix in range(self._wcs.pixel_n_dim):
+            if isinstance(self._slices_pixel[ipix], numbers.Integral):
+                pixel_reference.append(self._slices_pixel[ipix])
+            else:
+                pixel_reference.append(0)
+        world_reference = self._wcs.pixel_to_world_values(*pixel_reference)
+        # Ensure the reference is always a tuple of length ``world_n_dim``
+        if self._wcs.world_n_dim == 1:
+            world_reference = (world_reference,)
+        self._dropped_world_values = {iw: world_reference[iw]
+                                      for iw in range(self._wcs.world_n_dim)
+                                      if iw not in self._world_keep}
+
         if len(self._pixel_keep) == 0 or len(self._world_keep) == 0:
+
             raise ValueError("Cannot slice WCS: the resulting WCS should have "
                              "at least one pixel and one world dimension.")
 
@@ -250,8 +274,12 @@ class SlicedLowLevelWCS(BaseWCSWrapper):
             if iworld in self._world_keep:
                 iworld_curr += 1
                 world_arrays_new.append(world_arrays[iworld_curr])
+
             else:
-                world_arrays_new.append(1.)
+                world_arrays_new.append(
+                    np.broadcast_to(self._dropped_world_values[iworld], world_arrays[0].shape)
+                )
+
 
         world_arrays_new = np.broadcast_arrays(*world_arrays_new)
         pixel_arrays = list(self._wcs.world_to_pixel_values(*world_arrays_new))
@@ -305,4 +333,4 @@ class SlicedLowLevelWCS(BaseWCSWrapper):
 
     @property
     def axis_correlation_matrix(self):
-        return self._wcs.axis_correlation_matrix[self._world_keep][:, self._pixel_keep]
+        return self._wcs.axis_correlation_matrix[self._world_keep][:, self._pixel_keep]
