diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py
index d3cef15..f166995 100644
--- a/sphinx/ext/autodoc/__init__.py
+++ b/sphinx/ext/autodoc/__init__.py
@@ -593,8 +593,15 @@ class Documenter:
             attr_docs = {}
 
         # process members and determine which to skip
+
         for (membername, member) in members:
+            include_private = (
+                self.options.private_members in (True, ALL) or
+                isinstance(self.options.private_members, (list, tuple, set)) and
+                membername in self.options.private_members
+            )
             # if isattr is True, the member is documented as an attribute
+
             if member is INSTANCEATTR:
                 isattr = True
             else:
@@ -649,15 +656,19 @@ class Documenter:
             elif (namespace, membername) in attr_docs:
                 if want_all and isprivate:
                     # ignore members whose name starts with _ by default
-                    keep = self.options.private_members
+
+                    keep = include_private
+
                 else:
                     # keep documented attributes
                     keep = True
                 isattr = True
             elif want_all and isprivate:
                 # ignore members whose name starts with _ by default
-                keep = self.options.private_members and \
+
+                keep = include_private and \
                     (has_doc or self.options.undoc_members)
+
             else:
                 if self.options.members is ALL and is_filtered_inherited_member(membername):
                     keep = False
@@ -1549,9 +1560,43 @@ class DataDocumenter(ModuleLevelDocumenter):
 
     @classmethod
     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
+
                             ) -> bool:
         return isinstance(parent, ModuleDocumenter) and isattr
 
+
+# ---------------------------------------------------------------------------
+# Enhanced :private-members: option handling
+# ---------------------------------------------------------------------------
+
+def private_members_option(arg: Any) -> Any:
+    """
+    Converter for the ``:private-members:`` option.
+
+    - If *arg* is None or empty/whitespace, return the sentinel ``ALL`` which
+      signals that every private member should be documented.
+    - Otherwise, interpret *arg* as a comma or whitespace separated list of
+      member names and return it as a list.
+    """
+    if arg is None:
+        return ALL
+
+    arg = str(arg).strip()
+    if not arg:
+        return ALL
+
+    # Split by commas or whitespace and drop empty fragments
+    parts = re.split(r'[\\s,]+', arg)
+    return [name for name in (p.strip() for p in parts) if name]
+
+
+# Register the new converter for the base Documenter and all of its subclasses
+Documenter.option_spec['private-members'] = private_members_option
+for _sub in list(Documenter.__subclasses__()):
+    if _sub.option_spec.get('private-members') is bool_option:
+        _sub.option_spec['private-members'] = private_members_option
+
+
     def add_directive_header(self, sig: str) -> None:
         super().add_directive_header(sig)
         sourcename = self.get_sourcename()
