diff --git a/sympy/core/relational.py b/sympy/core/relational.py
index 4fbe5d9..99452e5 100644
--- a/sympy/core/relational.py
+++ b/sympy/core/relational.py
@@ -304,8 +304,16 @@ class Relational(Boolean, EvalfMixin):
         from .add import Add
         r = self
         r = r.func(*[i.simplify(**kwargs) for i in r.args])
+
         if r.is_Relational:
+            # Only perform numeric-difference simplification when both
+            # sides are Expr instances.  For non‑Expr operands (e.g.,
+            # Sets), skip the numeric-difference analysis and proceed
+            # directly to canonicalisation.
+            if not (isinstance(r.lhs, Expr) and isinstance(r.rhs, Expr)):
+                return r.canonical
             dif = r.lhs - r.rhs
+
             # replace dif with a valid Number that will
             # allow a definitive comparison with 0
             v = None
diff --git a/sympy/sets/sets.py b/sympy/sets/sets.py
index d2cbd5e..2138ac5 100644
--- a/sympy/sets/sets.py
+++ b/sympy/sets/sets.py
@@ -799,9 +799,27 @@ class ProductSet(Set):
         if not isinstance(element, Tuple) or len(element) != len(self.sets):
             return False
 
+
         return fuzzy_and(s._contains(e) for s, e in zip(self.sets, element))
 
+    def _eval_is_subset(self, other):
+        """
+        Returns a fuzzy boolean indicating whether this ProductSet is a subset
+        of ``other`` when the comparison can be decided from finite data.
+
+        If ``other`` is a FiniteSet and this ProductSet itself is finite,
+        the result is obtained by checking that every element of ``self`` is
+        contained in ``other``.  In all other cases this method returns
+        ``None`` so that other subset‑handling mechanisms can take over.
+        """
+        from sympy.sets.sets import FiniteSet
+        from sympy.core.logic import fuzzy_and, fuzzy_bool
+        if isinstance(other, FiniteSet) and self.is_finite_set:
+            return fuzzy_and(fuzzy_bool(other._contains(e)) for e in self)
+        return None
+
     def as_relational(self, *symbols):
+
         symbols = [_sympify(s) for s in symbols]
         if len(symbols) != len(self.sets) or not all(
                 i.is_Symbol for i in symbols):
