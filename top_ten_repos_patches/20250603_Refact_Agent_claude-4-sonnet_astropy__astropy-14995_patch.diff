diff --git a/astropy/nddata/mixins/ndarithmetic.py b/astropy/nddata/mixins/ndarithmetic.py
index 4153dfccb2..17d81f4031 100644
--- a/astropy/nddata/mixins/ndarithmetic.py
+++ b/astropy/nddata/mixins/ndarithmetic.py
@@ -522,6 +522,9 @@ class NDArithmeticMixin:
             return deepcopy(operand.mask)
         elif operand is None:
             return deepcopy(self.mask)
+        elif operand is not None and operand.mask is None:
+            # operand has no mask, just return a copy of self.mask
+            return deepcopy(self.mask)
         else:
             # Now lets calculate the resulting mask (operation enforces copy)
             return handle_mask(self.mask, operand.mask, **kwds)
diff --git a/astropy/nddata/mixins/tests/test_ndarithmetic.py b/astropy/nddata/mixins/tests/test_ndarithmetic.py
index 8c461155ab..3f7c51b102 100644
--- a/astropy/nddata/mixins/tests/test_ndarithmetic.py
+++ b/astropy/nddata/mixins/tests/test_ndarithmetic.py
@@ -1226,6 +1226,51 @@ def test_arithmetics_mask_func():
         nd1.add(nd2, handle_mask=mask_sad_func, fun=1)
 
 
+def test_arithmetics_mask_bitwise_or_with_none():
+    """Test mask propagation with np.bitwise_or when one operand has no mask.
+    
+    This tests the fix for issue where np.bitwise_or would fail when trying
+    to operate on an integer array and None.
+    """
+    array = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
+    mask = np.array([[0, 1, 64], [8, 0, 1], [2, 1, 0]])
+
+    # Test with mask and scalar (no mask)
+    nd_mask = NDDataArithmetic(array, mask=mask)
+    result = nd_mask.multiply(2., handle_mask=np.bitwise_or)
+    assert_array_equal(result.mask, mask)
+
+    # Test with mask and NDData without mask
+    nd_nomask = NDDataArithmetic(array)
+    result = nd_mask.multiply(nd_nomask, handle_mask=np.bitwise_or)
+    assert_array_equal(result.mask, mask)
+
+    # Test reverse order (no mask * mask)
+    result = nd_nomask.multiply(nd_mask, handle_mask=np.bitwise_or)
+    assert_array_equal(result.mask, mask)
+
+    # Test specific arithmetic operations that are safe
+    for op_name in ['add', 'subtract', 'multiply']:
+        op_method = getattr(nd_mask, op_name)
+        result = op_method(2., handle_mask=np.bitwise_or)
+        assert_array_equal(result.mask, mask, 
+                          f"Failed for {op_name} with scalar")
+        
+        result = op_method(nd_nomask, handle_mask=np.bitwise_or)
+        assert_array_equal(result.mask, mask, 
+                          f"Failed for {op_name} with no-mask operand")
+    
+    # Test divide separately with safe values
+    result = nd_mask.divide(2., handle_mask=np.bitwise_or)
+    assert_array_equal(result.mask, mask)
+    
+    # Create a safe array for division (no zeros)
+    safe_array = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
+    nd_safe = NDDataArithmetic(safe_array)
+    result = nd_mask.divide(nd_safe, handle_mask=np.bitwise_or)
+    assert_array_equal(result.mask, mask)
+
+
 @pytest.mark.parametrize("meth", ["add", "subtract", "divide", "multiply"])
 def test_two_argument_useage(meth):
     ndd1 = NDDataArithmetic(np.ones((3, 3)))
