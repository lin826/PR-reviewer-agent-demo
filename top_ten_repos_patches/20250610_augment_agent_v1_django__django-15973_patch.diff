diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py
index 09785e8586..ae78e13f57 100644
--- a/django/db/backends/base/schema.py
+++ b/django/db/backends/base/schema.py
@@ -1,9 +1,10 @@
 import logging
 import operator
 from datetime import datetime
 
+from django.apps import apps
 from django.conf import settings
 from django.db.backends.ddl_references import (
     Columns,
     Expressions,
     ForeignKeyName,
@@ -18,10 +19,54 @@ from django.db.transaction import TransactionManagementError, atomic
 from django.utils import timezone
 
 logger = logging.getLogger("django.db.backends.schema")
 
 
+def _resolve_through_model(field):
+    """
+    Resolve the through model for a ManyToManyField.
+    
+    During migrations, field.remote_field.through might be a string reference
+    that hasn't been resolved to a model class yet. This function handles both
+    cases: when through is already a model class and when it's a string reference.
+    
+    Returns the resolved model class or None if it can't be resolved.
+    """
+    # Only ManyToManyFields have through models
+    if not field.many_to_many:
+        return None
+        
+    # Check if field has remote_field and through
+    if not hasattr(field, 'remote_field') or not field.remote_field or not hasattr(field.remote_field, 'through') or not field.remote_field.through:
+        return None
+        
+    through = field.remote_field.through
+    
+    # If through already has _meta, it's a resolved model class
+    if hasattr(through, '_meta'):
+        return through
+    
+    # If through is a string, try to resolve it
+    if isinstance(through, str):
+        try:
+            # Parse the string to get app_label and model_name
+            if '.' in through:
+                app_label, model_name = through.split('.', 1)
+            else:
+                # If no app_label specified, use the field's model app
+                app_label = field.model._meta.app_label
+                model_name = through
+            
+            # Try to get the model from the apps registry
+            return apps.get_model(app_label, model_name)
+        except (LookupError, ValueError):
+            # Model not found or invalid format
+            return None
+    
+    return None
+
+
 def _is_relevant_relation(relation, altered_field):
     """
     When altering the given field, must constraints on its model from the given
     relation be temporarily dropped?
     """
@@ -448,19 +493,21 @@ class BaseDatabaseSchemaEditor:
         # _remake_table needs it).
         self.deferred_sql.extend(self._model_indexes_sql(model))
 
         # Make M2M tables
         for field in model._meta.local_many_to_many:
-            if field.remote_field.through._meta.auto_created:
-                self.create_model(field.remote_field.through)
+            through_model = _resolve_through_model(field)
+            if through_model and through_model._meta.auto_created:
+                self.create_model(through_model)
 
     def delete_model(self, model):
         """Delete a model from the database."""
         # Handle auto-created intermediary models
         for field in model._meta.local_many_to_many:
-            if field.remote_field.through._meta.auto_created:
-                self.delete_model(field.remote_field.through)
+            through_model = _resolve_through_model(field)
+            if through_model and through_model._meta.auto_created:
+                self.delete_model(through_model)
 
         # Delete the table
         self.execute(
             self.sql_delete_table
             % {
@@ -628,12 +675,14 @@ class BaseDatabaseSchemaEditor:
         """
         Create a field on a model. Usually involves adding a column, but may
         involve adding a table instead (for M2M fields).
         """
         # Special-case implicit M2M tables
-        if field.many_to_many and field.remote_field.through._meta.auto_created:
-            return self.create_model(field.remote_field.through)
+        if field.many_to_many:
+            through_model = _resolve_through_model(field)
+            if through_model and through_model._meta.auto_created:
+                return self.create_model(through_model)
         # Get the column's definition
         definition, params = self.column_sql(model, field, include_default=True)
         # It might not actually have a column behind it
         if definition is None:
             return
@@ -702,12 +751,14 @@ class BaseDatabaseSchemaEditor:
         """
         Remove a field from a model. Usually involves deleting a column,
         but for M2Ms may involve deleting a table.
         """
         # Special-case implicit M2M tables
-        if field.many_to_many and field.remote_field.through._meta.auto_created:
-            return self.delete_model(field.remote_field.through)
+        if field.many_to_many:
+            through_model = _resolve_through_model(field)
+            if through_model and through_model._meta.auto_created:
+                return self.delete_model(through_model)
         # It might not actually have a column behind it
         if field.db_parameters(connection=self.connection)["type"] is None:
             return
         # Drop any FK constraints, MySQL requires explicit deletion
         if field.remote_field:
@@ -751,29 +802,33 @@ class BaseDatabaseSchemaEditor:
             raise ValueError(
                 "Cannot alter field %s into %s - they do not properly define "
                 "db_type (are you using a badly-written custom field?)"
                 % (old_field, new_field),
             )
-        elif (
+        # Resolve through models for comparison
+        old_through = _resolve_through_model(old_field)
+        new_through = _resolve_through_model(new_field)
+        
+        if (
             old_type is None
             and new_type is None
             and (
-                old_field.remote_field.through
-                and new_field.remote_field.through
-                and old_field.remote_field.through._meta.auto_created
-                and new_field.remote_field.through._meta.auto_created
+                old_through
+                and new_through
+                and old_through._meta.auto_created
+                and new_through._meta.auto_created
             )
         ):
             return self._alter_many_to_many(model, old_field, new_field, strict)
         elif (
             old_type is None
             and new_type is None
             and (
-                old_field.remote_field.through
-                and new_field.remote_field.through
-                and not old_field.remote_field.through._meta.auto_created
-                and not new_field.remote_field.through._meta.auto_created
+                old_through
+                and new_through
+                and not old_through._meta.auto_created
+                and not new_through._meta.auto_created
             )
         ):
             # Both sides have through models; this is a no-op.
             return
         elif old_type is None or new_type is None:
@@ -1244,38 +1299,43 @@ class BaseDatabaseSchemaEditor:
             [],
         )
 
     def _alter_many_to_many(self, model, old_field, new_field, strict):
         """Alter M2Ms to repoint their to= endpoints."""
+        # Resolve through models
+        old_through = _resolve_through_model(old_field)
+        new_through = _resolve_through_model(new_field)
+        
+        if not old_through or not new_through:
+            # If we can't resolve the through models, we can't proceed
+            return
+            
         # Rename the through table
-        if (
-            old_field.remote_field.through._meta.db_table
-            != new_field.remote_field.through._meta.db_table
-        ):
+        if old_through._meta.db_table != new_through._meta.db_table:
             self.alter_db_table(
-                old_field.remote_field.through,
-                old_field.remote_field.through._meta.db_table,
-                new_field.remote_field.through._meta.db_table,
+                old_through,
+                old_through._meta.db_table,
+                new_through._meta.db_table,
             )
         # Repoint the FK to the other side
         self.alter_field(
-            new_field.remote_field.through,
+            new_through,
             # The field that points to the target model is needed, so we can
             # tell alter_field to change it - this is m2m_reverse_field_name()
             # (as opposed to m2m_field_name(), which points to our model).
-            old_field.remote_field.through._meta.get_field(
+            old_through._meta.get_field(
                 old_field.m2m_reverse_field_name()
             ),
-            new_field.remote_field.through._meta.get_field(
+            new_through._meta.get_field(
                 new_field.m2m_reverse_field_name()
             ),
         )
         self.alter_field(
-            new_field.remote_field.through,
+            new_through,
             # for self-referential models we need to alter field from the other end too
-            old_field.remote_field.through._meta.get_field(old_field.m2m_field_name()),
-            new_field.remote_field.through._meta.get_field(new_field.m2m_field_name()),
+            old_through._meta.get_field(old_field.m2m_field_name()),
+            new_through._meta.get_field(new_field.m2m_field_name()),
         )
 
     def _create_index_name(self, table_name, column_names, suffix=""):
         """
         Generate a unique name for an index/unique constraint.
