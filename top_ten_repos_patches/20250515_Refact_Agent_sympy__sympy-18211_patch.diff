diff --git a/sympy/core/relational.py b/sympy/core/relational.py
index f581bfa3c4..a8bc5a8c9e 100644
--- a/sympy/core/relational.py
+++ b/sympy/core/relational.py
@@ -629,6 +629,48 @@ def binary_symbols(self):
             elif self.rhs.is_Symbol:
                 return set([self.rhs])
         return set()
+        
+    def _eval_as_set(self):
+        """
+        Rewrite Equality in set form.
+        
+        Examples
+        ========
+        
+        >>> from sympy import Symbol, Eq
+        >>> x = Symbol('x', real=True)
+        >>> Eq(x, 0).as_set()
+        FiniteSet(0)
+        >>> Eq(x**2, 1).as_set()
+        FiniteSet(-1, 1)
+        
+        For transcendental equations that cannot be solved explicitly,
+        a ConditionSet is returned:
+        
+        >>> from sympy import cos, sin
+        >>> n = Symbol('n')
+        >>> Eq(n*cos(n) - 3*sin(n), 0).as_set()
+        ConditionSet(n, Eq(n*cos(n) - 3*sin(n), 0), Reals)
+        """
+        from sympy.solvers.inequalities import solve_univariate_inequality
+        from sympy.sets import ConditionSet
+        from sympy.calculus.util import periodicity
+        
+        syms = self.free_symbols
+        if len(syms) == 1:
+            sym = syms.pop()
+            
+            # Check for periodicity
+            period = periodicity(self.lhs - self.rhs, sym)
+            
+            try:
+                return solve_univariate_inequality(self, sym, relational=False)
+            except NotImplementedError:
+                # For equations that cannot be solved explicitly (like transcendental equations),
+                # return a ConditionSet instead of raising an exception
+                return ConditionSet(sym, self, S.Reals)
+        else:
+            raise NotImplementedError("Only univariate expressions are supported")
 
     def _eval_simplify(self, **kwargs):
         from sympy.solvers.solveset import linear_coeffs
@@ -734,6 +776,48 @@ def binary_symbols(self):
             elif self.rhs.is_Symbol:
                 return set([self.rhs])
         return set()
+        
+    def _eval_as_set(self):
+        """
+        Rewrite Equality in set form.
+        
+        Examples
+        ========
+        
+        >>> from sympy import Symbol, Eq
+        >>> x = Symbol('x', real=True)
+        >>> Eq(x, 0).as_set()
+        FiniteSet(0)
+        >>> Eq(x**2, 1).as_set()
+        FiniteSet(-1, 1)
+        
+        For transcendental equations that cannot be solved explicitly,
+        a ConditionSet is returned:
+        
+        >>> from sympy import cos, sin
+        >>> n = Symbol('n')
+        >>> Eq(n*cos(n) - 3*sin(n), 0).as_set()
+        ConditionSet(n, Eq(n*cos(n) - 3*sin(n), 0), Reals)
+        """
+        from sympy.solvers.inequalities import solve_univariate_inequality
+        from sympy.sets import ConditionSet
+        from sympy.calculus.util import periodicity
+        
+        syms = self.free_symbols
+        if len(syms) == 1:
+            sym = syms.pop()
+            
+            # Check for periodicity
+            period = periodicity(self.lhs - self.rhs, sym)
+            
+            try:
+                return solve_univariate_inequality(self, sym, relational=False)
+            except NotImplementedError:
+                # For equations that cannot be solved explicitly (like transcendental equations),
+                # return a ConditionSet instead of raising an exception
+                return ConditionSet(sym, self, S.Reals)
+        else:
+            raise NotImplementedError("Only univariate expressions are supported")
 
     def _eval_simplify(self, **kwargs):
         # simplify as an equality
diff --git a/sympy/logic/boolalg.py b/sympy/logic/boolalg.py
index c3664a1055..52ea6083be 100644
--- a/sympy/logic/boolalg.py
+++ b/sympy/logic/boolalg.py
@@ -141,22 +141,36 @@ def as_set(self):
 
         """
         from sympy.calculus.util import periodicity
-        from sympy.core.relational import Relational
+        from sympy.core.relational import Relational, Equality
+        from sympy.sets import ConditionSet
+        
         free = self.free_symbols
         if len(free) == 1:
             x = free.pop()
             reps = {}
             for r in self.atoms(Relational):
-                if periodicity(r, x) not in (0, None):
+                period = periodicity(r, x)
+                if period not in (0, None):
+                    # For periodic equations, use ConditionSet instead of raising an error
+                    if isinstance(r, Equality):
+                        reps[r] = ConditionSet(x, r, S.Reals)
+                        continue
+                    
                     s = r._eval_as_set()
                     if s in (S.EmptySet, S.UniversalSet, S.Reals):
                         reps[r] = s.as_relational(x)
                         continue
+                    
+                    # For other periodic relationals that we can't handle yet
                     raise NotImplementedError(filldedent('''
                         as_set is not implemented for relationals
                         with periodic solutions
                         '''))
-            return self.subs(reps)._eval_as_set()
+            result = self.subs(reps)
+            # If the substitution resulted in a ConditionSet, return it directly
+            if isinstance(result, ConditionSet):
+                return result
+            return result._eval_as_set()
         else:
             raise NotImplementedError("Sorry, as_set has not yet been"
                                       " implemented for multivariate"
