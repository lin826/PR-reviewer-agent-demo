diff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py
index 8915616b..2a89401d 100644
--- a/seaborn/_core/plot.py
+++ b/seaborn/_core/plot.py
@@ -193,10 +193,11 @@ class Plot:
     _pair_spec: PairSpec
 
     _figure_spec: dict[str, Any]
     _subplot_spec: dict[str, Any]
     _layout_spec: dict[str, Any]
+    _semantic_label_offset: dict[str, str]
 
     def __init__(
         self,
         *args: DataSource | VariableSpec,
         data: DataSource = None,
@@ -225,10 +226,11 @@ class Plot:
         self._pair_spec = {}
 
         self._figure_spec = {}
         self._subplot_spec = {}
         self._layout_spec = {}
+        self._semantic_label_offset = {}
 
         self._target = None
 
     def _resolve_positionals(
         self,
@@ -877,10 +879,11 @@ class Plotter:
         self._theme = theme
         self._legend_contents: list[tuple[
             tuple[str, str | int], list[Artist], list[str],
         ]] = []
         self._scales: dict[str, Scale] = {}
+        self._semantic_label_offset: dict[str, str] = {}
 
     def save(self, loc, **kwargs) -> Plotter:  # TODO type args
         kwargs.setdefault("dpi", 96)
         try:
             loc = os.path.expanduser(loc)
@@ -1559,11 +1562,19 @@ class Plotter:
         ]] = []
         schema = []
         for var in legend_vars:
             var_legend = scales[var]._legend
             if var_legend is not None:
-                values, labels = var_legend
+                # Check if legend includes offset information
+                if len(var_legend) == 3:
+                    values, labels, offset = var_legend
+                    # If there's an offset, add it to the variable name
+                    # This will be used later when creating the legend title
+                    if offset and offset.strip():
+                        p._semantic_label_offset[var] = offset
+                else:
+                    values, labels = var_legend
                 for (_, part_id), part_vars, _ in schema:
                     if data.ids[var] == part_id:
                         # Allow multiple plot semantics to represent same data variable
                         part_vars.append(var)
                         break
@@ -1611,16 +1622,22 @@ class Plotter:
         # TODO explain
         loc = "center right" if self._pyplot else "center left"
 
         base_legend = None
         for (name, _), (handles, labels) in merged_contents.items():
-
+            
+            # Check if we have an offset for this variable
+            title = name
+            if name in p._semantic_label_offset:
+                # Add the offset to the title
+                title = f"{name} ({p._semantic_label_offset[name]})"
+                
             legend = mpl.legend.Legend(
                 self._figure,
                 handles,
                 labels,
-                title=name,
+                title=title,
                 loc=loc,
                 bbox_to_anchor=(.98, .55),
             )
 
             if base_legend:
diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py
index 55874bf2..3d037be1 100644
--- a/seaborn/_core/scales.py
+++ b/seaborn/_core/scales.py
@@ -376,12 +376,24 @@ class ContinuousBase(Scale):
         # besides allowing Scale.legend(False)?
         if prop.legend:
             axis.set_view_interval(vmin, vmax)
             locs = axis.major.locator()
             locs = locs[(vmin <= locs) & (locs <= vmax)]
-            labels = axis.major.formatter.format_ticks(locs)
-            new._legend = list(locs), list(labels)
+            formatter = axis.major.formatter
+            labels = formatter.format_ticks(locs)
+            
+            # Force drawing to ensure the offset is calculated
+            import matplotlib.pyplot as plt
+            plt.draw()
+            
+            # Check if the formatter has an offset
+            offset = formatter.get_offset()
+            if offset and offset.strip():
+                # If there's an offset, store it with the legend information
+                new._legend = list(locs), list(labels), offset
+            else:
+                new._legend = list(locs), list(labels)
 
         return new
 
     def _get_transform(self):
 
diff --git a/seaborn/relational.py b/seaborn/relational.py
index 18e18bb6..3bffaaf1 100644
--- a/seaborn/relational.py
+++ b/seaborn/relational.py
@@ -241,22 +241,35 @@ class _RelationalPlotter(VectorPlotter):
             if isinstance(self._hue_map.norm, mpl.colors.LogNorm):
                 locator = mpl.ticker.LogLocator(numticks=brief_ticks)
             else:
                 locator = mpl.ticker.MaxNLocator(nbins=brief_ticks)
             limits = min(self._hue_map.levels), max(self._hue_map.levels)
-            hue_levels, hue_formatted_levels = locator_to_legend_entries(
+            legend_entries = locator_to_legend_entries(
                 locator, limits, self.plot_data["hue"].infer_objects().dtype
             )
+            
+            # Check if we have an offset
+            if len(legend_entries) == 3:
+                hue_levels, hue_formatted_levels, hue_offset = legend_entries
+                # Store the offset for later use
+                self._hue_offset = hue_offset
+            else:
+                hue_levels, hue_formatted_levels = legend_entries
+                self._hue_offset = None
         elif self._hue_map.levels is None:
             hue_levels = hue_formatted_levels = []
         else:
             hue_levels = hue_formatted_levels = self._hue_map.levels
 
         # Add the hue semantic subtitle
         if not legend_title and self.variables.get("hue", None) is not None:
+            hue_title = self.variables["hue"]
+            # Add the offset to the title if it exists
+            if self._hue_offset:
+                hue_title = f"{hue_title} ({self._hue_offset})"
             update((self.variables["hue"], "title"),
-                   self.variables["hue"], **title_kws)
+                   hue_title, **title_kws)
 
         # Add the hue semantic labels
         for level, formatted_level in zip(hue_levels, hue_formatted_levels):
             if level is not None:
                 color = self._hue_map(level)
@@ -273,22 +286,35 @@ class _RelationalPlotter(VectorPlotter):
                 locator = mpl.ticker.LogLocator(numticks=brief_ticks)
             else:
                 locator = mpl.ticker.MaxNLocator(nbins=brief_ticks)
             # Define the min/max data values
             limits = min(self._size_map.levels), max(self._size_map.levels)
-            size_levels, size_formatted_levels = locator_to_legend_entries(
+            legend_entries = locator_to_legend_entries(
                 locator, limits, self.plot_data["size"].infer_objects().dtype
             )
+            
+            # Check if we have an offset
+            if len(legend_entries) == 3:
+                size_levels, size_formatted_levels, size_offset = legend_entries
+                # Store the offset for later use
+                self._size_offset = size_offset
+            else:
+                size_levels, size_formatted_levels = legend_entries
+                self._size_offset = None
         elif self._size_map.levels is None:
             size_levels = size_formatted_levels = []
         else:
             size_levels = size_formatted_levels = self._size_map.levels
 
         # Add the size semantic subtitle
         if not legend_title and self.variables.get("size", None) is not None:
+            size_title = self.variables["size"]
+            # Add the offset to the title if it exists
+            if self._size_offset:
+                size_title = f"{size_title} ({self._size_offset})"
             update((self.variables["size"], "title"),
-                   self.variables["size"], **title_kws)
+                   size_title, **title_kws)
 
         # Add the size semantic labels
         for level, formatted_level in zip(size_levels, size_formatted_levels):
             if level is not None:
                 size = self._size_map(level)
@@ -372,10 +398,12 @@ class _LinePlotter(_RelationalPlotter):
         self.orient = orient
         self.err_style = err_style
         self.err_kws = {} if err_kws is None else err_kws
 
         self.legend = legend
+        self._hue_offset = None
+        self._size_offset = None
 
     def plot(self, ax, kws):
         """Draw the plot onto an axes, passing matplotlib kwargs."""
 
         # Draw a test plot, using the passed in kwargs. The goal here is to
@@ -536,10 +564,12 @@ class _ScatterPlotter(_RelationalPlotter):
         )
 
         super().__init__(data=data, variables=variables)
 
         self.legend = legend
+        self._hue_offset = None
+        self._size_offset = None
 
     def plot(self, ax, kws):
 
         # --- Determine the visual attributes of the plot
 
diff --git a/seaborn/utils.py b/seaborn/utils.py
index 2407853c..2eba85ff 100644
--- a/seaborn/utils.py
+++ b/seaborn/utils.py
@@ -704,11 +704,21 @@ def locator_to_legend_entries(locator, limits, dtype):
     # TODO: The following two lines should be replaced
     # once pinned matplotlib>=3.1.0 with:
     # formatted_levels = formatter.format_ticks(raw_levels)
     formatter.set_locs(raw_levels)
     formatted_levels = [formatter(x) for x in raw_levels]
-
+    
+    # Check if the formatter has an offset
+    # Force drawing to ensure the offset is calculated
+    import matplotlib.pyplot as plt
+    plt.draw()
+    
+    offset = formatter.get_offset()
+    if offset and offset.strip():
+        # Return the offset as a third element
+        return raw_levels, formatted_levels, offset
+    
     return raw_levels, formatted_levels
 
 
 def relative_luminance(color):
     """Calculate the relative luminance of a color according to W3C standards
