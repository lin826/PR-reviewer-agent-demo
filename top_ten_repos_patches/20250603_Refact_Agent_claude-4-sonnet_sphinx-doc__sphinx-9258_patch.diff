diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py
index 7d39d80ed..864551f2f 100644
--- a/sphinx/domains/python.py
+++ b/sphinx/domains/python.py
@@ -304,24 +304,101 @@ class PyXrefMixin:
     def make_xrefs(self, rolename: str, domain: str, target: str,
                    innernode: Type[TextlikeNode] = nodes.emphasis,
                    contnode: Node = None, env: BuildEnvironment = None) -> List[Node]:
-        delims = r'(\s*[\[\]\(\),](?:\s*or\s)?\s*|\s+or\s+|\.\.\.)'
-        delims_re = re.compile(delims)
-        sub_targets = re.split(delims, target)
+        # Check if this is a union type (contains | or ' or ' at top level)
+        def has_union_operators(text: str) -> bool:
+            """Check if text contains union operators at top level (not inside brackets/parens)."""
+            depth = 0
+            i = 0
+            while i < len(text):
+                char = text[i]
+                if char in '([':
+                    depth += 1
+                elif char in ')]':
+                    depth -= 1
+                elif char == '|' and depth == 0:
+                    return True
+                elif text[i:i+4] == ' or ' and depth == 0:
+                    return True
+                i += 1
+            return False
+
+        # If this is a union type, use bracket-aware splitting
+        if has_union_operators(target):
+            def split_union_types(text: str) -> List[str]:
+                """Split union types while preserving complex generic types."""
+                parts = []
+                current = ""
+                depth = 0
+                i = 0
+                
+                while i < len(text):
+                    char = text[i]
+                    
+                    if char in '([':
+                        depth += 1
+                        current += char
+                    elif char in ')]':
+                        depth -= 1
+                        current += char
+                    elif char == '|' and depth == 0:
+                        # Found a top-level union operator
+                        if current.strip():
+                            parts.append(current.strip())
+                        parts.append(' | ')
+                        current = ""
+                    elif text[i:i+4] == ' or ' and depth == 0:
+                        # Found a top-level 'or' operator
+                        if current.strip():
+                            parts.append(current.strip())
+                        parts.append(' or ')
+                        current = ""
+                        i += 3  # Skip the rest of ' or '
+                    else:
+                        current += char
+                    i += 1
+                
+                if current.strip():
+                    parts.append(current.strip())
+                
+                return parts
+
+            sub_targets = split_union_types(target)
+            split_contnode = bool(contnode and contnode.astext() == target)
+
+            results = []
+            for sub_target in sub_targets:
+                if split_contnode:
+                    contnode = nodes.Text(sub_target)
+
+                # Check if this is a union operator
+                if sub_target.strip() in ('|', 'or', ' | ', ' or '):
+                    results.append(contnode or innernode(sub_target, sub_target))
+                else:
+                    # For individual type parts, create a single cross-reference
+                    # Don't split further to preserve complex generic types
+                    results.append(self.make_xref(rolename, domain, sub_target,
+                                                  innernode, contnode, env))
+            return results
+        else:
+            # Not a union type, use original logic for backwards compatibility
+            delims = r'(\s*[\[\]\(\),](?:\s*or\s)?\s*|\s+or\s+|\.\.\.)'
+            delims_re = re.compile(delims)
+            sub_targets = re.split(delims, target)
 
-        split_contnode = bool(contnode and contnode.astext() == target)
+            split_contnode = bool(contnode and contnode.astext() == target)
 
-        results = []
-        for sub_target in filter(None, sub_targets):
-            if split_contnode:
-                contnode = nodes.Text(sub_target)
+            results = []
+            for sub_target in filter(None, sub_targets):
+                if split_contnode:
+                    contnode = nodes.Text(sub_target)
 
-            if delims_re.match(sub_target):
-                results.append(contnode or innernode(sub_target, sub_target))
-            else:
-                results.append(self.make_xref(rolename, domain, sub_target,
-                                              innernode, contnode, env))
+                if delims_re.match(sub_target):
+                    results.append(contnode or innernode(sub_target, sub_target))
+                else:
+                    results.append(self.make_xref(rolename, domain, sub_target,
+                                                  innernode, contnode, env))
 
-        return results
+            return results
 
 
 class PyField(PyXrefMixin, Field):
diff --git a/tests/test_domain_py.py b/tests/test_domain_py.py
index 2614c8ff6..1e888ad4f 100644
--- a/tests/test_domain_py.py
+++ b/tests/test_domain_py.py
@@ -541,6 +541,47 @@ def test_pydata_with_union_type_operator(app):
                                     [pending_xref, "str"])]))
 
 
+def test_docfield_union_types_complex(app):
+    """Test complex union types with generics in docfields."""
+    text = (".. py:function:: foo(items)\n"
+            "\n"
+            "   :param items: items parameter\n"
+            "   :type items: List[int] | Dict[str, MyClass] | Tuple[str, ...]\n")
+    doctree = restructuredtext.parse(app, text)
+    
+    # Check that complex generic types are preserved in the field body
+    field_body = doctree[1][1][0][0][1]  # Navigate to the field body
+    field_str = str(field_body)
+    # The complex types should be preserved as units, not split at brackets
+    assert 'List[int]' in field_str
+    assert 'Dict[str, MyClass]' in field_str
+    assert 'Tuple[str, ...]' in field_str
+
+
+def test_docfield_union_types_with_xrefs(app):
+    """Test union types with cross-references in docfields."""
+    text = (".. py:class:: MyClass\n"
+            "\n"
+            ".. py:function:: foo(data)\n"
+            "\n"
+            "   :param data: data parameter\n"
+            "   :type data: MyClass | str | None\n")
+    doctree = restructuredtext.parse(app, text)
+    
+    # Check that cross-references are created for custom classes
+    # The correct navigation path is doctree[3][1][0][0][1] based on our exploration:
+    # doctree[3] = desc node for function foo
+    # [1] = desc_content 
+    # [0] = field_list
+    # [0] = field (Parameters field)
+    # [1] = field_body
+    field_body = doctree[3][1][0][0][1]  # Navigate to the field body
+    field_str = str(field_body)
+    assert 'MyClass' in field_str
+    assert 'str' in field_str
+    assert 'None' in field_str
+
+
 def test_pyobject_prefix(app):
     text = (".. py:class:: Foo\n"
             "\n"
