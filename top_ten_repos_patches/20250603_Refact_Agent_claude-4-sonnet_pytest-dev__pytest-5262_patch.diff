diff --git a/src/_pytest/capture.py b/src/_pytest/capture.py
index 25eab7fdf..94f72ee64 100644
--- a/src/_pytest/capture.py
+++ b/src/_pytest/capture.py
@@ -447,6 +447,15 @@ class EncodedFile(object):
         """Ensure that file.name is a string."""
         return repr(self.buffer)
 
+    @property
+    def mode(self):
+        """Return the mode of the underlying buffer, but without 'b' since this is a text wrapper."""
+        buffer_mode = getattr(self.buffer, "mode", "")
+        # Remove 'b' from mode since this is a text wrapper around a binary stream
+        text_mode = buffer_mode.replace("b", "")
+        # If mode becomes empty after removing 'b', default to 'r'
+        return text_mode if text_mode else "r"
+
     def __getattr__(self, name):
         return getattr(object.__getattribute__(self, "buffer"), name)
 
diff --git a/testing/test_capture.py b/testing/test_capture.py
index 5d80eb63d..f277faa42 100644
--- a/testing/test_capture.py
+++ b/testing/test_capture.py
@@ -1574,3 +1574,77 @@ def test_typeerror_encodedfile_write(testdir):
         )
     else:
         assert result_with_capture.ret == 0
+
+
+def test_encodedfile_mode_removes_binary_flag():
+    """Test that EncodedFile.mode removes 'b' from underlying buffer mode (#5262)."""
+    import tempfile
+    import io
+    
+    # Test with mock buffer to avoid NamedTemporaryFile mode quirks
+    class MockBuffer:
+        def __init__(self, mode):
+            self.mode = mode
+        def write(self, data):
+            pass
+    
+    test_cases = [
+        ('rb', 'r'),
+        ('wb', 'w'), 
+        ('ab', 'a'),
+        ('rb+', 'r+'),
+        ('wb+', 'w+'),
+        ('ab+', 'a+'),
+        ('r+b', 'r+'),
+        ('w+b', 'w+'),
+        ('a+b', 'a+'),
+    ]
+    
+    for binary_mode, expected_text_mode in test_cases:
+        buffer = MockBuffer(binary_mode)
+        encoded_file = capture.EncodedFile(buffer, 'utf-8')
+        assert encoded_file.mode == expected_text_mode
+        assert 'b' not in encoded_file.mode
+    
+    # Test edge cases
+    buffer = MockBuffer('b')
+    encoded_file = capture.EncodedFile(buffer, 'utf-8')
+    assert encoded_file.mode == 'r'
+    
+    buffer = MockBuffer('')
+    encoded_file = capture.EncodedFile(buffer, 'utf-8')
+    assert encoded_file.mode == 'r'
+    
+    # Test with BytesIO (no mode attribute)
+    bio = io.BytesIO()
+    encoded_file = capture.EncodedFile(bio, 'utf-8')
+    assert encoded_file.mode == 'r'
+
+
+def test_encodedfile_youtube_dl_compatibility():
+    """Test that EncodedFile mode fix resolves youtube-dl compatibility issue (#5262)."""
+    import tempfile
+    
+    def simulate_youtube_dl_behavior(out_file):
+        """Simulate how youtube-dl decides whether to write bytes or str."""
+        mode = getattr(out_file, 'mode', '')
+        
+        if 'b' in mode:
+            # youtube-dl would write bytes
+            data = b'test message\n'
+            out_file.write(data)  # This should fail with old EncodedFile
+            return 'bytes'
+        else:
+            # youtube-dl would write string
+            data = 'test message\n'
+            out_file.write(data)  # This should work
+            return 'string'
+    
+    # Test with safe_text_dupfile (like pytest uses internally)
+    with tempfile.NamedTemporaryFile() as f:
+        captured_output = capture.safe_text_dupfile(f, mode="wb+")
+        
+        # This should work now - youtube-dl writes string, not bytes
+        write_type = simulate_youtube_dl_behavior(captured_output)
+        assert write_type == 'string'
+        assert 'b' not in captured_output.mode
