diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py
index 982816be3a..5f6c62f50d 100644
--- a/django/db/migrations/operations/models.py
+++ b/django/db/migrations/operations/models.py
@@ -320,6 +320,9 @@ class RenameModel(ModelOperation):
         new_model = to_state.apps.get_model(app_label, self.new_name)
         if self.allow_migrate_model(schema_editor.connection.alias, new_model):
             old_model = from_state.apps.get_model(app_label, self.old_name)
+            # If the db_table is the same, this is a no-op at the database level
+            if old_model._meta.db_table == new_model._meta.db_table:
+                return
             # Move the main table
             schema_editor.alter_db_table(
                 new_model,
diff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py
index 11961a1f40..f33d08f5b8 100644
--- a/tests/migrations/test_operations.py
+++ b/tests/migrations/test_operations.py
@@ -3821,3 +3821,86 @@ class FieldOperationTests(SimpleTestCase):
         self.assertIs(operation.references_field('Through', 'whatever', 'migrations'), False)
         self.assertIs(operation.references_field('Through', 'first', 'migrations'), True)
         self.assertIs(operation.references_field('Through', 'second', 'migrations'), True)
+
+    def test_rename_model_with_same_db_table_is_noop(self):
+        """
+        RenameModel with the same db_table in old and new models should be a no-op
+        at the database level.
+        """
+        # Mock schema editor to track operations
+        class MockSchemaEditor:
+            def __init__(self):
+                self.operations_called = []
+                self.connection = connection
+            
+            def alter_db_table(self, model, old_table, new_table):
+                self.operations_called.append(('alter_db_table', old_table, new_table))
+            
+            def alter_field(self, model, old_field, new_field):
+                self.operations_called.append(('alter_field', model._meta.label, old_field.name))
+
+        # Create initial state with a model that has db_table defined
+        from_state = ProjectState()
+        from_state.add_model(ModelState(
+            app_label='testapp',
+            name='Author',
+            fields=[
+                ('id', models.AutoField(primary_key=True)),
+                ('name', models.CharField(max_length=100)),
+            ],
+            options={'db_table': 'custom_author_table'}
+        ))
+        
+        # Add a related model to test foreign key handling
+        from_state.add_model(ModelState(
+            app_label='testapp',
+            name='Book',
+            fields=[
+                ('id', models.AutoField(primary_key=True)),
+                ('title', models.CharField(max_length=100)),
+                ('author', models.ForeignKey('testapp.Author', models.CASCADE)),
+            ],
+            options={}
+        ))
+        
+        # Create target state with renamed model but same db_table
+        to_state = ProjectState()
+        to_state.add_model(ModelState(
+            app_label='testapp',
+            name='Writer',  # Renamed from Author to Writer
+            fields=[
+                ('id', models.AutoField(primary_key=True)),
+                ('name', models.CharField(max_length=100)),
+            ],
+            options={'db_table': 'custom_author_table'}  # Same db_table!
+        ))
+        
+        # Add the related model with updated foreign key
+        to_state.add_model(ModelState(
+            app_label='testapp',
+            name='Book',
+            fields=[
+                ('id', models.AutoField(primary_key=True)),
+                ('title', models.CharField(max_length=100)),
+                ('author', models.ForeignKey('testapp.Writer', models.CASCADE)),
+            ],
+            options={}
+        ))
+        
+        # Create the RenameModel operation
+        operation = migrations.RenameModel(old_name='Author', new_name='Writer')
+        
+        # Get the models from both states
+        old_model = from_state.apps.get_model('testapp', 'Author')
+        new_model = to_state.apps.get_model('testapp', 'Writer')
+        
+        # Verify both models have the same db_table
+        self.assertEqual(old_model._meta.db_table, new_model._meta.db_table)
+        
+        # Test the database operation with mock schema editor
+        mock_editor = MockSchemaEditor()
+        operation.database_forwards('testapp', mock_editor, from_state, to_state)
+        
+        # Verify no operations were called (should be no-op)
+        self.assertEqual(len(mock_editor.operations_called), 0,
+                        "RenameModel with same db_table should not perform any database operations")
