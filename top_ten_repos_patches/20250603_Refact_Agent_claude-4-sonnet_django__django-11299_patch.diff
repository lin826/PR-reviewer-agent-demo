diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index b99f03cd88..d69c24419b 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -1338,7 +1338,7 @@ class Query(BaseExpression):
             if isinstance(child, Node):
                 child_clause, needed_inner = self._add_q(
                     child, used_aliases, branch_negated,
-                    current_negated, allow_joins, split_subq)
+                    current_negated, allow_joins, split_subq, simple_col)
                 joinpromoter.add_votes(needed_inner)
             else:
                 child_clause, needed_inner = self.build_filter(
diff --git a/tests/constraints/tests.py b/tests/constraints/tests.py
index b7aeb1e7f0..c4d37046b8 100644
--- a/tests/constraints/tests.py
+++ b/tests/constraints/tests.py
@@ -79,6 +79,72 @@ class CheckConstraintTests(TestCase):
         expected_name = 'price_gt_discounted_price'
         self.assertIn(expected_name, constraints)
 
+    def test_check_constraint_or_sql_consistency(self):
+        """
+        Test that CheckConstraint with OR generates consistent SQL without
+        table names, fixing the issue where mixed qualified/unqualified
+        column references caused SQLite migration failures.
+        """
+        from django.db.models.sql.query import Query
+        
+        # Test the original issue case: OR with AND
+        constraint = models.CheckConstraint(
+            check=models.Q(price__gt=0, discounted_price__isnull=False) |
+                  models.Q(price__exact=0),
+            name='test_or_constraint'
+        )
+        
+        # Test the build_where method directly which is used by _get_check_sql
+        query = Query(model=Product)
+        where = query.build_where(constraint.check)
+        compiler = query.get_compiler(connection=connection)
+        sql, params = where.as_sql(compiler, connection)
+        
+        # Ensure no table names appear in the constraint SQL
+        table_name = Product._meta.db_table
+        self.assertNotIn(table_name, sql)
+        self.assertNotIn(f'"{table_name}"', sql)
+        
+        # Verify the SQL contains expected elements
+        self.assertIn('price', sql)
+        self.assertIn('discounted_price', sql)
+        self.assertIn('OR', sql)
+        self.assertIn('AND', sql)
+
+    def test_check_constraint_migration_scenario(self):
+        """
+        Test the specific migration scenario where temporary table names
+        should not appear in constraint SQL.
+        """
+        from django.db.models.sql.query import Query
+        
+        constraint = models.CheckConstraint(
+            check=models.Q(price__gt=0) | models.Q(discounted_price__isnull=True),
+            name='test_migration_constraint'
+        )
+        
+        # Save original table name
+        original_table_name = Product._meta.db_table
+        
+        try:
+            # Simulate migration with temporary table name
+            temp_table_name = f"new__{original_table_name}"
+            Product._meta.db_table = temp_table_name
+            
+            # Test the build_where method directly
+            query = Query(model=Product)
+            where = query.build_where(constraint.check)
+            compiler = query.get_compiler(connection=connection)
+            sql, params = where.as_sql(compiler, connection)
+            
+            # Critical test: temp table name should not appear in constraint
+            self.assertNotIn(temp_table_name, sql)
+            self.assertNotIn('new__', sql)
+            
+        finally:
+            # Restore original table name
+            Product._meta.db_table = original_table_name
+
 
 class UniqueConstraintTests(TestCase):
     @classmethod
