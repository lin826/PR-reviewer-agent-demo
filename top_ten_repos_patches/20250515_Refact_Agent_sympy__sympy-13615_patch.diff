diff --git a/sympy/sets/sets.py b/sympy/sets/sets.py
index 917717bb74..a53a195664 100644
--- a/sympy/sets/sets.py
+++ b/sympy/sets/sets.py
@@ -999,9 +999,36 @@ def _complement(self, other):
             return Union(a, b)
 
         if isinstance(other, FiniteSet):
-            nums = [m for m in other.args if m.is_number]
-            if nums == []:
-                return None
+            nums = []
+            syms = []
+            
+            # Separate numeric and symbolic elements
+            for m in other.args:
+                if m.is_number:
+                    # For numbers, check if they're in the interval
+                    contains_result = self.contains(m)
+                    if contains_result is True:
+                        # Skip numbers that are definitely in the interval
+                        continue
+                    else:
+                        # Keep numbers that are definitely not in the interval
+                        nums.append(m)
+                else:
+                    # Keep all symbolic elements
+                    syms.append(m)
+            
+            # Handle the result based on what we have
+            if not nums and not syms:
+                return S.EmptySet
+            elif not syms:
+                return FiniteSet(*nums)
+            elif not nums:
+                # Only symbols remain, return a proper complement
+                return Complement(FiniteSet(*syms), self, evaluate=False)
+            else:
+                # Both numbers and symbols remain
+                return Union(FiniteSet(*nums), 
+                            Complement(FiniteSet(*syms), self, evaluate=False))
 
         return Set._complement(self, other)
 
@@ -1725,6 +1752,40 @@ def reduce(A, B):
         if isinstance(B, Union):
             return Intersection(s.complement(A) for s in B.args)
 
+        # For FiniteSet and Interval combinations, handle specially
+        if isinstance(A, FiniteSet) and isinstance(B, Interval):
+            nums = []
+            syms = []
+            
+            # Separate numeric and symbolic elements
+            for m in A.args:
+                if m.is_number:
+                    # For numbers, check if they're in the interval
+                    contains_result = B.contains(m)
+                    if contains_result == S.true:
+                        # Skip numbers that are definitely in the interval
+                        continue
+                    else:
+                        # Keep numbers that are definitely not in the interval
+                        nums.append(m)
+                else:
+                    # Keep all symbolic elements
+                    syms.append(m)
+            
+            # Handle the result based on what we have
+            if not nums and not syms:
+                return S.EmptySet
+            elif not syms:
+                return FiniteSet(*nums)
+            elif not nums:
+                # Only symbols remain, return a proper complement
+                return Complement(FiniteSet(*syms), B, evaluate=False)
+            else:
+                # Both numbers and symbols remain
+                return Union(FiniteSet(*nums), 
+                            Complement(FiniteSet(*syms), B, evaluate=False))
+        
+        # Try the original approach
         result = B._complement(A)
         if result != None:
             return result
