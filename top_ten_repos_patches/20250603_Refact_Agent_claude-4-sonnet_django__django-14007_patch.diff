diff --git a/django/db/models/base.py b/django/db/models/base.py
index 55b1691166..afaae4cc1a 100644
--- a/django/db/models/base.py
+++ b/django/db/models/base.py
@@ -872,6 +872,8 @@ class Model(metaclass=ModelBase):
             results = self._do_insert(cls._base_manager, using, fields, returning_fields, raw)
             if results:
                 for value, field in zip(results[0], returning_fields):
+                    if hasattr(field, 'from_db_value'):
+                        value = field.from_db_value(value, None, connections[using])
                     setattr(self, field.attname, value)
         return updated
 
diff --git a/django/db/models/query.py b/django/db/models/query.py
index 387deca527..6801d3ded6 100644
--- a/django/db/models/query.py
+++ b/django/db/models/query.py
@@ -505,6 +505,8 @@ class QuerySet:
                 for obj_with_pk, results in zip(objs_with_pk, returned_columns):
                     for result, field in zip(results, opts.db_returning_fields):
                         if field != opts.pk:
+                            if hasattr(field, 'from_db_value'):
+                                result = field.from_db_value(result, None, connections[self.db])
                             setattr(obj_with_pk, field.attname, result)
                 for obj_with_pk in objs_with_pk:
                     obj_with_pk._state.adding = False
@@ -518,6 +520,8 @@ class QuerySet:
                     assert len(returned_columns) == len(objs_without_pk)
                 for obj_without_pk, results in zip(objs_without_pk, returned_columns):
                     for result, field in zip(results, opts.db_returning_fields):
+                        if hasattr(field, 'from_db_value'):
+                            result = field.from_db_value(result, None, connections[self.db])
                         setattr(obj_without_pk, field.attname, result)
                     obj_without_pk._state.adding = False
                     obj_without_pk._state.db = self.db
diff --git a/tests/from_db_value/tests.py b/tests/from_db_value/tests.py
index ab92f37ccf..f5ccc526be 100644
--- a/tests/from_db_value/tests.py
+++ b/tests/from_db_value/tests.py
@@ -1,4 +1,4 @@
-from django.db import connection
+from django.db import connection, models
 from django.db.models import Max
 from django.test import TestCase
 
@@ -33,3 +33,74 @@ class FromDBValueTest(TestCase):
     def test_connection(self):
         instance = CashModel.objects.get()
         self.assertEqual(instance.cash.vendor, connection.vendor)
+
+
+class MyIntWrapper:
+    """A wrapper class for integers to test from_db_value on insert operations."""
+    def __init__(self, value):
+        self.value = int(value)
+    
+    def __str__(self):
+        return f"<MyIntWrapper: {self.value}>"
+    
+    def __repr__(self):
+        return f"<MyIntWrapper: {self.value}>"
+    
+    def __int__(self):
+        return self.value
+    
+    def __eq__(self, other):
+        if isinstance(other, MyIntWrapper):
+            return self.value == other.value
+        return self.value == other
+
+
+class MyAutoField(models.BigAutoField):
+    """Custom auto field that wraps returned values."""
+    
+    def from_db_value(self, value, expression, connection):
+        if value is None:
+            return None
+        return MyIntWrapper(value)
+    
+    def get_prep_value(self, value):
+        if value is None:
+            return None
+        return int(value)
+
+
+class AutoModel(models.Model):
+    """Test model using the custom auto field."""
+    id = MyAutoField(primary_key=True)
+    
+    class Meta:
+        app_label = 'from_db_value'
+
+
+class ReturningFieldsFromDBValueTest(TestCase):
+    """Test that from_db_value is called for returning fields on insert operations."""
+    
+    def test_create_calls_from_db_value(self):
+        """Test that create() calls from_db_value for returning fields."""
+        instance = AutoModel.objects.create()
+        self.assertIsInstance(instance.id, MyIntWrapper)
+    
+    def test_save_calls_from_db_value(self):
+        """Test that save() calls from_db_value for returning fields."""
+        instance = AutoModel()
+        instance.save()
+        self.assertIsInstance(instance.id, MyIntWrapper)
+    
+    def test_bulk_create_calls_from_db_value(self):
+        """Test that bulk_create() calls from_db_value for returning fields when supported."""
+        instances = [AutoModel(), AutoModel()]
+        AutoModel.objects.bulk_create(instances)
+        
+        # Only test if the database supports returning rows from bulk insert
+        if connection.features.can_return_rows_from_bulk_insert:
+            for instance in instances:
+                self.assertIsInstance(instance.id, MyIntWrapper)
+        else:
+            # On databases that don't support it (like SQLite), the id will be None
+            for instance in instances:
+                self.assertIsNone(instance.id)
