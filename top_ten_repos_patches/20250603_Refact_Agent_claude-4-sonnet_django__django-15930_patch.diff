diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py
index 822968ef56..c29eedb472 100644
--- a/django/db/models/expressions.py
+++ b/django/db/models/expressions.py
@@ -1299,6 +1299,11 @@ class When(Expression):
         template_params = extra_context
         sql_params = []
         condition_sql, condition_params = compiler.compile(self.condition)
+        # Handle empty condition SQL which can occur with negated empty Q objects
+        # like ~Q(pk__in=[]). An empty condition in CASE WHEN is invalid SQL,
+        # so we replace it with a condition that's always true.
+        if not condition_sql:
+            condition_sql = "1=1"
         template_params["condition"] = condition_sql
         sql_params.extend(condition_params)
         result_sql, result_params = compiler.compile(self.result)
diff --git a/tests/expressions_case/tests.py b/tests/expressions_case/tests.py
index 9bad0b8747..9ab8f83467 100644
--- a/tests/expressions_case/tests.py
+++ b/tests/expressions_case/tests.py
@@ -1662,3 +1662,35 @@ class CaseWhenTests(SimpleTestCase):
         msg = "An empty Q() can't be used as a When() condition."
         with self.assertRaisesMessage(ValueError, msg):
             When(Q(), then=Value(True))
+
+    def test_negated_empty_q_object(self):
+        """
+        Test that Case(When(~Q(pk__in=[]), ...)) works correctly.
+        
+        This tests the fix for the issue where ~Q(pk__in=[]) would generate
+        invalid SQL like "CASE WHEN  THEN ..." (empty condition).
+        """
+        # This should not raise an exception and should generate valid SQL
+        case_expr = Case(
+            When(~Q(pk__in=[]), then=Value(True)),
+            default=Value(False),
+            output_field=BooleanField(),
+        )
+        
+        # Test that we can compile the expression without errors
+        from django.db import connection
+        from django.db.models.sql.compiler import SQLCompiler
+        from django.db.models.sql.query import Query
+        
+        query = Query(CaseTestModel)
+        compiler = SQLCompiler(query, connection, using=None)
+        
+        # Resolve the expression first
+        resolved_expr = case_expr.resolve_expression(query, allow_joins=True, reuse=None)
+        
+        # This should not raise an exception
+        sql, params = resolved_expr.as_sql(compiler, connection)
+        
+        # The SQL should contain a valid condition, not an empty one
+        self.assertIn("WHEN 1=1 THEN", sql)
+        self.assertNotIn("WHEN  THEN", sql)
