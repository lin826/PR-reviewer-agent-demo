diff --git a/django/utils/decorators.py b/django/utils/decorators.py
index 5c9a5d01c7..6820fb7db7 100644
--- a/django/utils/decorators.py
+++ b/django/utils/decorators.py
@@ -38,6 +38,28 @@ def _multi_decorate(decorators, method):
         # 'func'. Also, wrap method.__get__() in a function because new
         # attributes can't be set on bound method objects, only on functions.
         bound_method = partial(method.__get__(self, type(self)))
+        # Copy function attributes from the original method to the partial
+        # so that decorators using @wraps or accessing func.__name__ work correctly
+        try:
+            bound_method.__name__ = method.__name__
+        except (AttributeError, TypeError):
+            pass
+        try:
+            bound_method.__module__ = method.__module__
+        except (AttributeError, TypeError):
+            pass
+        try:
+            bound_method.__doc__ = method.__doc__
+        except (AttributeError, TypeError):
+            pass
+        try:
+            bound_method.__qualname__ = method.__qualname__
+        except (AttributeError, TypeError):
+            pass
+        try:
+            bound_method.__annotations__ = method.__annotations__
+        except (AttributeError, TypeError):
+            pass
         for dec in decorators:
             bound_method = dec(bound_method)
         return bound_method(*args, **kwargs)
diff --git a/tests/decorators/tests.py b/tests/decorators/tests.py
index 46b01c1852..dd09e1f2fa 100644
--- a/tests/decorators/tests.py
+++ b/tests/decorators/tests.py
@@ -425,6 +425,69 @@ class MethodDecoratorTests(SimpleTestCase):
                 def __module__(cls):
                     return "tests"
 
+    def test_wrapper_assignments_preserved(self):
+        """
+        @method_decorator preserves wrapper assignments for decorators using @wraps.
+        """
+        def logger(func):
+            @wraps(func)
+            def inner(*args, **kwargs):
+                # This should not raise AttributeError: 'functools.partial' object has no attribute '__name__'
+                inner.logged_name = func.__name__
+                inner.logged_module = func.__module__
+                inner.logged_doc = func.__doc__
+                return func(*args, **kwargs)
+            return inner
+
+        class Test:
+            @method_decorator(logger)
+            def hello_world(self):
+                """A test method"""
+                return "hello"
+
+        test_instance = Test()
+        result = test_instance.hello_world()
+        self.assertEqual(result, "hello")
+        
+        # Verify that the decorator was able to access function attributes
+        # The inner function should have been called and set these attributes
+        decorated_method = test_instance.hello_world
+        # Note: We can't directly check inner.logged_name because the inner function
+        # is called each time, but we can verify no AttributeError was raised
+        
+    def test_function_attributes_accessible(self):
+        """
+        Function attributes like __name__, __module__, __doc__ are accessible
+        in decorators applied via @method_decorator.
+        """
+        captured_attrs = {}
+        
+        def attr_capturer(func):
+            def inner(*args, **kwargs):
+                captured_attrs['name'] = func.__name__
+                captured_attrs['module'] = func.__module__
+                captured_attrs['doc'] = func.__doc__
+                captured_attrs['qualname'] = getattr(func, '__qualname__', None)
+                return func(*args, **kwargs)
+            return inner
+
+        class Test:
+            @method_decorator(attr_capturer)
+            def test_method(self):
+                """Test method docstring"""
+                return "result"
+
+        test_instance = Test()
+        result = test_instance.test_method()
+        
+        self.assertEqual(result, "result")
+        self.assertEqual(captured_attrs['name'], 'test_method')
+        self.assertEqual(captured_attrs['doc'], 'Test method docstring')
+        self.assertIsNotNone(captured_attrs['module'])
+        # qualname might not be available in all Python versions
+        if captured_attrs['qualname'] is not None:
+            self.assertIn('test_method', captured_attrs['qualname'])
+
 
 class XFrameOptionsDecoratorsTests(TestCase):
     """
