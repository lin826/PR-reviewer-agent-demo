diff --git a/requests/adapters.py b/requests/adapters.py
index fe22ff45..52051211 100644
--- a/requests/adapters.py
+++ b/requests/adapters.py
@@ -26,10 +26,11 @@ from urllib3.exceptions import ProxyError as _ProxyError
 from urllib3.exceptions import ProtocolError
 from urllib3.exceptions import ReadTimeoutError
 from urllib3.exceptions import SSLError as _SSLError
 from urllib3.exceptions import ResponseError
 from urllib3.exceptions import LocationValueError
+from urllib3.exceptions import LocationParseError
 
 from .models import Response
 from .compat import urlparse, basestring
 from .utils import (DEFAULT_CA_BUNDLE_PATH, extract_zipped_paths,
                     get_encoding_from_headers, prepend_scheme_if_needed,
@@ -409,11 +410,11 @@ class HTTPAdapter(BaseAdapter):
         :rtype: requests.Response
         """
 
         try:
             conn = self.get_connection(request.url, proxies)
-        except LocationValueError as e:
+        except (LocationValueError, LocationParseError) as e:
             raise InvalidURL(e, request=request)
 
         self.cert_verify(conn, request.url, verify, cert)
         url = self.request_url(request, proxies)
         self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
diff --git a/requests/models.py b/requests/models.py
index e7d292d5..27650ce2 100644
--- a/requests/models.py
+++ b/requests/models.py
@@ -349,10 +349,16 @@ class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):
 
     @staticmethod
     def _get_idna_encoded_host(host):
         import idna
 
+        # Check for empty labels in the host
+        if '.' in host:
+            for label in host.split('.'):
+                if not label:
+                    raise UnicodeError('label empty or too long')
+
         try:
             host = idna.encode(host, uts46=True).decode('utf-8')
         except idna.IDNAError:
             raise UnicodeError
         return host
@@ -377,10 +383,23 @@ class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):
         # handles RFC 3986 only.
         if ':' in url and not url.lower().startswith('http'):
             self.url = url
             return
 
+        # Check for invalid labels in the URL
+        if '://' in url:
+            # Extract the host from the URL
+            host_start = url.find('://') + 3
+            host_end = url.find('/', host_start) if url.find('/', host_start) != -1 else len(url)
+            host = url[host_start:host_end]
+            
+            # Check for empty labels
+            if '.' in host:
+                for label in host.split('.'):
+                    if not label:
+                        raise InvalidURL('URL has an invalid label.')
+
         # Support for unicode domain names and paths.
         try:
             scheme, auth, host, port, path, query, fragment = parse_url(url)
         except LocationParseError as e:
             raise InvalidURL(*e.args)
