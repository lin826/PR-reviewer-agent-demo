diff --git a/django/db/backends/mysql/operations.py b/django/db/backends/mysql/operations.py
index af8cfd86b5..35e3add004 100644
--- a/django/db/backends/mysql/operations.py
+++ b/django/db/backends/mysql/operations.py
@@ -298,6 +298,8 @@ class DatabaseOperations(BaseDatabaseOperations):
                 converters.append(self.convert_datetimefield_value)
         elif internal_type == 'UUIDField':
             converters.append(self.convert_uuidfield_value)
+        elif internal_type == 'DurationField':
+            converters.append(self.convert_durationfield_value)
         return converters
 
     def convert_booleanfield_value(self, value, expression, connection):
@@ -315,6 +317,18 @@ class DatabaseOperations(BaseDatabaseOperations):
             value = uuid.UUID(value)
         return value
 
+    def convert_durationfield_value(self, value, expression, connection):
+        if value is not None:
+            # If value is an integer, it represents microseconds (from simple field reads)
+            if isinstance(value, int):
+                import datetime
+                return datetime.timedelta(0, 0, value)
+            # If value is a string, it's from a duration expression and needs parsing
+            elif isinstance(value, str):
+                from django.utils.dateparse import parse_duration
+                return parse_duration(value)
+        return value
+
     def binary_placeholder_sql(self, value):
         return '_binary %s' if value is not None and not hasattr(value, 'as_sql') else '%s'
 
diff --git a/django/db/backends/sqlite3/operations.py b/django/db/backends/sqlite3/operations.py
index 9510b5edd9..9fd2ebc9be 100644
--- a/django/db/backends/sqlite3/operations.py
+++ b/django/db/backends/sqlite3/operations.py
@@ -273,6 +273,8 @@ class DatabaseOperations(BaseDatabaseOperations):
             converters.append(self.get_decimalfield_converter(expression))
         elif internal_type == 'UUIDField':
             converters.append(self.convert_uuidfield_value)
+        elif internal_type == 'DurationField':
+            converters.append(self.convert_durationfield_value)
         elif internal_type in ('NullBooleanField', 'BooleanField'):
             converters.append(self.convert_booleanfield_value)
         return converters
@@ -321,6 +323,17 @@ class DatabaseOperations(BaseDatabaseOperations):
     def convert_booleanfield_value(self, value, expression, connection):
         return bool(value) if value in (1, 0) else value
 
+    def convert_durationfield_value(self, value, expression, connection):
+        if value is not None:
+            # If value is an integer, it represents microseconds (from simple field reads)
+            if isinstance(value, int):
+                return datetime.timedelta(0, 0, value)
+            # If value is a string, it's from a duration expression and needs parsing
+            elif isinstance(value, str):
+                from django.utils.dateparse import parse_duration
+                return parse_duration(value)
+        return value
+
     def bulk_insert_sql(self, fields, placeholder_rows):
         return " UNION ALL ".join(
             "SELECT %s" % ", ".join(row)
diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py
index 459a87797d..48b7243960 100644
--- a/tests/expressions/tests.py
+++ b/tests/expressions/tests.py
@@ -1468,6 +1468,33 @@ class FTimeDeltaTests(TestCase):
         ))
         self.assertIsNone(queryset.first().shifted)
 
+    def test_duration_expressions(self):
+        """
+        Test duration-only expressions like F('estimated_time') + timedelta.
+        Regression test for #XXXXX where duration expressions failed on SQLite and MySQL.
+        """
+        delta = datetime.timedelta(hours=1)
+        
+        # Test addition
+        result = list(Experiment.objects.annotate(
+            new_duration=F('estimated_time') + delta
+        ).values('name', 'new_duration'))
+        
+        # Verify that we get results and they have the expected type
+        self.assertTrue(len(result) > 0)
+        for item in result:
+            self.assertIsInstance(item['new_duration'], datetime.timedelta)
+        
+        # Test subtraction
+        result = list(Experiment.objects.annotate(
+            new_duration=F('estimated_time') - delta
+        ).values('name', 'new_duration'))
+        
+        # Verify that we get results and they have the expected type
+        self.assertTrue(len(result) > 0)
+        for item in result:
+            self.assertIsInstance(item['new_duration'], datetime.timedelta)
+
     @skipUnlessDBFeature('supports_temporal_subtraction')
     def test_date_subtraction(self):
         queryset = Experiment.objects.annotate(
