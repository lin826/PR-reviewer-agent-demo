diff --git a/django/db/migrations/executor.py b/django/db/migrations/executor.py
index 57042a8690..e7c674897e 100644
--- a/django/db/migrations/executor.py
+++ b/django/db/migrations/executor.py
@@ -262,10 +262,11 @@ class MigrationExecutor:
         return state
 
     def check_replacements(self):
         """
         Mark replacement migrations applied if their replaced set all are.
+        Mark replacement migrations unapplied if any of their replaced migrations are unapplied.
 
         Do this unconditionally on every migrate, rather than just when
         migrations are applied or unapplied, to correctly handle the case
         when a new squash migration is pushed to a deployment that already had
         all its replaced migrations applied. In this case no new migration will
@@ -275,10 +276,12 @@ class MigrationExecutor:
         applied = self.recorder.applied_migrations()
         for key, migration in self.loader.replacements.items():
             all_applied = all(m in applied for m in migration.replaces)
             if all_applied and key not in applied:
                 self.recorder.record_applied(*key)
+            elif not all_applied and key in applied:
+                self.recorder.record_unapplied(*key)
 
     def detect_soft_applied(self, project_state, migration):
         """
         Test whether a migration has been implicitly applied - that the
         tables or columns it would create exist. This is intended only for use
