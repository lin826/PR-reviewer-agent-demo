diff --git a/django/core/handlers/base.py b/django/core/handlers/base.py
index 8e8c3da06a..e85084f40d 100644
--- a/django/core/handlers/base.py
+++ b/django/core/handlers/base.py
@@ -51,11 +51,11 @@ class BaseHandler:
                 middleware_is_async = middleware_can_async
             try:
                 # Adapt handler, if needed.
-                handler = self.adapt_method_mode(
+                adapted_handler = self.adapt_method_mode(
                     middleware_is_async, handler, handler_is_async,
                     debug=settings.DEBUG, name='middleware %s' % middleware_path,
                 )
-                mw_instance = middleware(handler)
+                mw_instance = middleware(adapted_handler)
             except MiddlewareNotUsed as exc:
                 if settings.DEBUG:
                     if str(exc):
@@ -85,6 +85,7 @@ class BaseHandler:
                     self.adapt_method_mode(False, mw_instance.process_exception),
                 )
 
+            # Only update handler and handler_is_async if middleware was successfully instantiated
             handler = convert_exception_to_response(mw_instance)
             handler_is_async = middleware_is_async
 
diff --git a/tests/middleware_exceptions/tests.py b/tests/middleware_exceptions/tests.py
index 8b019ba524..ba53601b13 100644
--- a/tests/middleware_exceptions/tests.py
+++ b/tests/middleware_exceptions/tests.py
@@ -140,6 +140,32 @@ class MyMiddlewareWithExceptionMessage:
         pass
 
 
+class AsyncCapableMiddlewareNotUsed:
+    """Middleware that is async-capable but raises MiddlewareNotUsed."""
+    
+    async_capable = True
+    sync_capable = True
+    
+    def __init__(self, get_response):
+        raise MiddlewareNotUsed("This async-capable middleware is not used")
+    
+    def __call__(self, request):
+        return self.get_response(request)
+
+
+class SyncOnlyMiddleware:
+    """Simple sync-only middleware for testing."""
+    
+    async_capable = False
+    sync_capable = True
+    
+    def __init__(self, get_response):
+        self.get_response = get_response
+    
+    def __call__(self, request):
+        return self.get_response(request)
+
+
 @override_settings(
     DEBUG=True,
     ROOT_URLCONF='middleware_exceptions.urls',
@@ -181,6 +207,49 @@ class MiddlewareNotUsedTests(SimpleTestCase):
             with self.assertLogs('django.request', 'DEBUG'):
                 self.client.get('/middleware_exceptions/view/')
 
+    @override_settings(MIDDLEWARE=[
+        'middleware_exceptions.tests.AsyncCapableMiddlewareNotUsed',
+        'middleware_exceptions.tests.SyncOnlyMiddleware',
+    ])
+    def test_middleware_not_used_asgi_handler_state(self):
+        """
+        Test that MiddlewareNotUsed doesn't corrupt handler state in ASGI context.
+        
+        When an async-capable middleware raises MiddlewareNotUsed, it should not
+        affect the async/sync state of subsequent middleware processing.
+        """
+        import asyncio
+        from django.core.handlers.base import BaseHandler
+        
+        handler = BaseHandler()
+        handler.load_middleware(is_async=True)
+        
+        # The final middleware chain should remain async despite MiddlewareNotUsed
+        self.assertTrue(
+            asyncio.iscoroutinefunction(handler._middleware_chain),
+            "Middleware chain should remain async when MiddlewareNotUsed is raised"
+        )
+
+    @override_settings(MIDDLEWARE=[
+        'middleware_exceptions.tests.SyncOnlyMiddleware',
+        'middleware_exceptions.tests.AsyncCapableMiddlewareNotUsed',
+    ])
+    def test_middleware_not_used_different_order_asgi(self):
+        """
+        Test MiddlewareNotUsed with different middleware order in ASGI context.
+        """
+        import asyncio
+        from django.core.handlers.base import BaseHandler
+        
+        handler = BaseHandler()
+        handler.load_middleware(is_async=True)
+        
+        # The final middleware chain should remain async
+        self.assertTrue(
+            asyncio.iscoroutinefunction(handler._middleware_chain),
+            "Middleware chain should remain async regardless of middleware order"
+        )
+
 
 @override_settings(
     DEBUG=True,
