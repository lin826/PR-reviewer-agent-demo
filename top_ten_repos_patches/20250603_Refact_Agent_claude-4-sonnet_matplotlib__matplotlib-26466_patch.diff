diff --git a/lib/matplotlib/tests/test_text.py b/lib/matplotlib/tests/test_text.py
index 47121b7a22..9bbc4141b2 100644
--- a/lib/matplotlib/tests/test_text.py
+++ b/lib/matplotlib/tests/test_text.py
@@ -988,3 +988,72 @@ def test_text_math_antialiased_off_default_vs_manual(fig_test, fig_ref):
 
     mpl.rcParams['text.antialiased'] = False
     fig_ref.text(0.5, 0.5, r"OutsideMath $I\'m \sqrt{2}$")
+
+
+def test_annotation_xy_array_copy():
+    """
+    Test that annotation xy parameter is copied when a numpy array is passed.
+    
+    This prevents the bug where modifying the original array would update
+    the annotation position.
+    
+    Regression test for issue where updating an array passed as the xy 
+    parameter to annotate updates the annotation.
+    """
+    fig, ax = plt.subplots()
+    
+    # Test with numpy array
+    xy_array = np.array([1.0, 2.0])
+    annotation = ax.annotate('test', xy=xy_array, xytext=(0, 0))
+    
+    # Store original position
+    original_xy = annotation.xy.copy()
+    
+    # Modify the original array
+    xy_array[0] = 999.0
+    xy_array[1] = 888.0
+    
+    # Annotation position should not have changed
+    assert np.array_equal(annotation.xy, original_xy), \
+        f"Annotation xy was affected by changes to original array. " \
+        f"Expected {original_xy}, got {annotation.xy}"
+    
+    # Verify that annotation.xy is independent
+    assert not np.shares_memory(annotation.xy, xy_array), \
+        "Annotation xy shares memory with original array"
+    
+    # Test with list
+    xy_list = [3.0, 4.0]
+    annotation2 = ax.annotate('test2', xy=xy_list, xytext=(0, 0))
+    original_xy2 = annotation2.xy.copy()
+    
+    # Modify the original list
+    xy_list[0] = 777.0
+    xy_list[1] = 666.0
+    
+    # Annotation position should not have changed
+    assert np.array_equal(annotation2.xy, original_xy2), \
+        f"Annotation xy was affected by changes to original list. " \
+        f"Expected {original_xy2}, got {annotation2.xy}"
+    
+    # Verify xy is always a numpy array for different input types
+    test_cases = [
+        (np.array([1.0, 2.0]), "numpy array"),
+        ([3.0, 4.0], "list"),
+        ((5.0, 6.0), "tuple"),
+        (np.array([7, 8]), "int numpy array"),
+    ]
+    
+    for xy_input, description in test_cases:
+        annotation = ax.annotate(f'test_{description}', xy=xy_input, xytext=(0, 0))
+        
+        # Verify xy is always a numpy array
+        assert isinstance(annotation.xy, np.ndarray), \
+            f"annotation.xy should be numpy array for {description}, got {type(annotation.xy)}"
+        
+        # Verify values are preserved
+        expected = np.array(xy_input)
+        assert np.array_equal(annotation.xy, expected), \
+            f"Values not preserved for {description}. Expected {expected}, got {annotation.xy}"
+    
+    plt.close(fig)
diff --git a/lib/matplotlib/text.py b/lib/matplotlib/text.py
index d4922fc517..85134e9cc4 100644
--- a/lib/matplotlib/text.py
+++ b/lib/matplotlib/text.py
@@ -1456,7 +1456,7 @@ class _AnnotationBase:
                  xycoords='data',
                  annotation_clip=None):
 
-        self.xy = xy
+        self.xy = np.array(xy)
         self.xycoords = xycoords
         self.set_annotation_clip(annotation_clip)
 
