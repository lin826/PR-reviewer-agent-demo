diff --git a/sympy/polys/densetools.py b/sympy/polys/densetools.py
index fb52236de7..a3a08dc497 100644
--- a/sympy/polys/densetools.py
+++ b/sympy/polys/densetools.py
@@ -31,7 +31,8 @@
 )
 from sympy.polys.polyerrors import (
     MultivariatePolynomialError,
-    DomainError
+    DomainError,
+    CoercionFailed
 )
 from sympy.utilities import variations
 
@@ -527,6 +528,16 @@ def dup_monic(f, K):
 
     lc = dup_LC(f, K)
 
+    # In a hybrid ext-factorisation run the "leading coefficient" may be a
+    # polynomial in the other indeterminates. If that coefficient is
+    # not an element of the ground domain K we must *not* remove it
+    # because there is no way to put it back later.
+    try:
+        K.convert(lc)
+    except CoercionFailed:
+        # keep the polynomial unchanged
+        return f
+
     if K.is_one(lc):
         return f
     else:
@@ -563,6 +574,16 @@ def dmp_ground_monic(f, u, K):
 
     lc = dmp_ground_LC(f, u, K)
 
+    # In a hybrid ext-factorisation run the "leading coefficient" may be a
+    # polynomial in the other indeterminates. If that coefficient is
+    # not an element of the ground domain K we must *not* remove it
+    # because there is no way to put it back later.
+    try:
+        K.convert(lc)
+    except CoercionFailed:
+        # keep the polynomial unchanged
+        return f
+
     if K.is_one(lc):
         return f
     else:
@@ -683,6 +704,16 @@ def dup_primitive(f, K):
 
     cont = dup_content(f, K)
 
+    # In a hybrid ext-factorisation run the "content" may be a
+    # polynomial in the other indeterminates. If that coefficient is
+    # not an element of the ground domain K we must *not* remove it
+    # because there is no way to put it back later.
+    try:
+        K.convert(cont)
+    except CoercionFailed:
+        # keep the polynomial unchanged and signal unity content
+        return K.one, f
+
     if K.is_one(cont):
         return cont, f
     else:
@@ -719,6 +750,16 @@ def dmp_ground_primitive(f, u, K):
 
     cont = dmp_ground_content(f, u, K)
 
+    # In a hybrid ext-factorisation run the "content" may be a
+    # polynomial in the other indeterminates. If that coefficient is
+    # not an element of the ground domain K we must *not* remove it
+    # because there is no way to put it back later.
+    try:
+        K.convert(cont)
+    except CoercionFailed:
+        # keep the polynomial unchanged and signal unity content
+        return K.one, f
+
     if K.is_one(cont):
         return cont, f
     else:
diff --git a/sympy/polys/factortools.py b/sympy/polys/factortools.py
index c6a5f9f063..9f3473b910 100644
--- a/sympy/polys/factortools.py
+++ b/sympy/polys/factortools.py
@@ -1107,8 +1107,14 @@ def dmp_zz_factor(f, u, K):
 def dup_ext_factor(f, K):
     """Factor univariate polynomials over algebraic number fields. """
     n, lc = dup_degree(f), dup_LC(f, K)
-
-    f = dup_monic(f, K)
+    
+    # Check if the leading coefficient can be converted to the ground domain
+    try:
+        K.convert(lc)
+        f = dup_monic(f, K)
+    except CoercionFailed:
+        # If the leading coefficient can't be converted, keep the polynomial as is
+        pass
 
     if n <= 0:
         return lc, []
@@ -1141,7 +1147,14 @@ def dmp_ext_factor(f, u, K):
         return dup_ext_factor(f, K)
 
     lc = dmp_ground_LC(f, u, K)
-    f = dmp_ground_monic(f, u, K)
+    
+    # Check if the leading coefficient can be converted to the ground domain
+    try:
+        K.convert(lc)
+        f = dmp_ground_monic(f, u, K)
+    except CoercionFailed:
+        # If the leading coefficient can't be converted, keep the polynomial as is
+        pass
 
     if all(d <= 0 for d in dmp_degree_list(f, u)):
         return lc, []
@@ -1261,7 +1274,19 @@ def dmp_factor_list(f, u, K0):
         return dup_factor_list(f, K0)
 
     J, f = dmp_terms_gcd(f, u, K0)
-    cont, f = dmp_ground_primitive(f, u, K0)
+    
+    # Store the original polynomial before extracting content
+    original_f = f
+    
+    # Try to extract content, but keep track if we succeeded
+    try:
+        cont, f = dmp_ground_primitive(f, u, K0)
+        content_extracted = True
+    except CoercionFailed:
+        # If content extraction fails, keep the original polynomial
+        cont = K0.one
+        f = original_f
+        content_extracted = False
 
     if K0.is_FiniteField:  # pragma: no cover
         coeff, factors = dmp_gf_factor(f, u, K0)
