diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py
index dbbeb7fe9c..3ca033ad7c 100644
--- a/django/contrib/admin/checks.py
+++ b/django/contrib/admin/checks.py
@@ -443,7 +443,7 @@ class BaseModelAdminChecks:
             else:
                 if (
                     isinstance(field, models.ManyToManyField)
-                    and not field.remote_field.through._meta.auto_created
+                    and not field.remote_field.through_model._meta.auto_created
                 ):
                     return [
                         checks.Error(
diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py
index 8ccacd6213..5847e10152 100644
--- a/django/contrib/admin/options.py
+++ b/django/contrib/admin/options.py
@@ -286,7 +286,7 @@ class BaseModelAdmin(metaclass=forms.MediaDefiningClass):
         """
         # If it uses an intermediary model that isn't auto created, don't show
         # a field in admin.
-        if not db_field.remote_field.through._meta.auto_created:
+        if not db_field.remote_field.through_model._meta.auto_created:
             return None
         db = kwargs.get("using")
 
diff --git a/django/contrib/auth/management/commands/createsuperuser.py b/django/contrib/auth/management/commands/createsuperuser.py
index 314c5151c4..36f094ee5b 100644
--- a/django/contrib/auth/management/commands/createsuperuser.py
+++ b/django/contrib/auth/management/commands/createsuperuser.py
@@ -62,7 +62,7 @@ class Command(BaseCommand):
             if field.many_to_many:
                 if (
                     field.remote_field.through
-                    and not field.remote_field.through._meta.auto_created
+                    and not field.remote_field.through_model._meta.auto_created
                 ):
                     raise CommandError(
                         "Required field '%s' specifies a many-to-many "
diff --git a/django/core/serializers/__init__.py b/django/core/serializers/__init__.py
index 480c54b79b..8401800a2c 100644
--- a/django/core/serializers/__init__.py
+++ b/django/core/serializers/__init__.py
@@ -202,7 +202,7 @@ def sort_dependencies(app_list, allow_cycles=False):
             # that defines a natural key.  M2M relations with explicit through
             # models don't count as dependencies.
             for field in model._meta.many_to_many:
-                if field.remote_field.through._meta.auto_created:
+                if field.remote_field.through_model._meta.auto_created:
                     rel_model = field.remote_field.model
                     if hasattr(rel_model, "natural_key") and rel_model != model:
                         deps.append(rel_model)
diff --git a/django/core/serializers/python.py b/django/core/serializers/python.py
index a3918bf9d2..16a907977c 100644
--- a/django/core/serializers/python.py
+++ b/django/core/serializers/python.py
@@ -62,7 +62,7 @@ class Serializer(base.Serializer):
         self._current[field.name] = value
 
     def handle_m2m_field(self, obj, field):
-        if field.remote_field.through._meta.auto_created:
+        if field.remote_field.through_model._meta.auto_created:
             if self.use_natural_foreign_keys and hasattr(
                 field.remote_field.model, "natural_key"
             ):
diff --git a/django/core/serializers/xml_serializer.py b/django/core/serializers/xml_serializer.py
index 8d3918cfaa..401d0106ac 100644
--- a/django/core/serializers/xml_serializer.py
+++ b/django/core/serializers/xml_serializer.py
@@ -130,7 +130,7 @@ class Serializer(base.Serializer):
         references to the object's PK (i.e. the related *data* is not dumped,
         just the relation).
         """
-        if field.remote_field.through._meta.auto_created:
+        if field.remote_field.through_model._meta.auto_created:
             self._start_relational_field(field)
             if self.use_natural_foreign_keys and hasattr(
                 field.remote_field.model, "natural_key"
diff --git a/django/db/backends/base/introspection.py b/django/db/backends/base/introspection.py
index 5e4acb3ff9..71cc8d1ae7 100644
--- a/django/db/backends/base/introspection.py
+++ b/django/db/backends/base/introspection.py
@@ -145,7 +145,7 @@ class BaseDatabaseIntrospection:
                 for f in model._meta.local_many_to_many:
                     # If this is an m2m using an intermediate table,
                     # we don't need to reset the sequence.
-                    if f.remote_field.through._meta.auto_created:
+                    if f.remote_field.through_model._meta.auto_created:
                         sequence = self.get_sequences(cursor, f.m2m_db_table())
                         sequence_list.extend(
                             sequence or [{"table": f.m2m_db_table(), "column": None}]
diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py
index 09785e8586..10ea805b43 100644
--- a/django/db/backends/base/schema.py
+++ b/django/db/backends/base/schema.py
@@ -450,15 +450,15 @@ class BaseDatabaseSchemaEditor:
 
         # Make M2M tables
         for field in model._meta.local_many_to_many:
-            if field.remote_field.through._meta.auto_created:
-                self.create_model(field.remote_field.through)
+            if field.remote_field.through_model._meta.auto_created:
+                self.create_model(field.remote_field.through_model)
 
     def delete_model(self, model):
         """Delete a model from the database."""
         # Handle auto-created intermediary models
         for field in model._meta.local_many_to_many:
-            if field.remote_field.through._meta.auto_created:
-                self.delete_model(field.remote_field.through)
+            if field.remote_field.through_model._meta.auto_created:
+                self.delete_model(field.remote_field.through_model)
 
         # Delete the table
         self.execute(
@@ -630,8 +630,8 @@ class BaseDatabaseSchemaEditor:
         involve adding a table instead (for M2M fields).
         """
         # Special-case implicit M2M tables
-        if field.many_to_many and field.remote_field.through._meta.auto_created:
-            return self.create_model(field.remote_field.through)
+        if field.many_to_many and field.remote_field.through_model._meta.auto_created:
+            return self.create_model(field.remote_field.through_model)
         # Get the column's definition
         definition, params = self.column_sql(model, field, include_default=True)
         # It might not actually have a column behind it
@@ -704,8 +704,8 @@ class BaseDatabaseSchemaEditor:
         but for M2Ms may involve deleting a table.
         """
         # Special-case implicit M2M tables
-        if field.many_to_many and field.remote_field.through._meta.auto_created:
-            return self.delete_model(field.remote_field.through)
+        if field.many_to_many and field.remote_field.through_model._meta.auto_created:
+            return self.delete_model(field.remote_field.through_model)
         # It might not actually have a column behind it
         if field.db_parameters(connection=self.connection)["type"] is None:
             return
@@ -759,8 +759,8 @@ class BaseDatabaseSchemaEditor:
             and (
                 old_field.remote_field.through
                 and new_field.remote_field.through
-                and old_field.remote_field.through._meta.auto_created
-                and new_field.remote_field.through._meta.auto_created
+                and old_field.remote_field.through_model._meta.auto_created
+                and new_field.remote_field.through_model._meta.auto_created
             )
         ):
             return self._alter_many_to_many(model, old_field, new_field, strict)
@@ -770,8 +770,8 @@ class BaseDatabaseSchemaEditor:
             and (
                 old_field.remote_field.through
                 and new_field.remote_field.through
-                and not old_field.remote_field.through._meta.auto_created
-                and not new_field.remote_field.through._meta.auto_created
+                and not old_field.remote_field.through_model._meta.auto_created
+                and not new_field.remote_field.through_model._meta.auto_created
             )
         ):
             # Both sides have through models; this is a no-op.
diff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py
index 6c106ae868..ab75abfcac 100644
--- a/django/db/backends/sqlite3/schema.py
+++ b/django/db/backends/sqlite3/schema.py
@@ -403,8 +403,8 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):
         # M2M fields are a special case
         if field.many_to_many:
             # For implicit M2M tables, delete the auto-created table
-            if field.remote_field.through._meta.auto_created:
-                self.delete_model(field.remote_field.through)
+            if field.remote_field.through_model._meta.auto_created:
+                self.delete_model(field.remote_field.through_model)
             # For explicit "through" M2M fields, do nothing
         elif (
             self.connection.features.can_alter_table_drop_column
@@ -470,15 +470,15 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):
                 if not remote_field.many_to_many:
                     if remote_field.field_name == new_field.name:
                         related_models.add(remote_field.related_model)
-                elif new_field.primary_key and remote_field.through._meta.auto_created:
-                    related_models.add(remote_field.through)
+                elif new_field.primary_key and remote_field.through_model._meta.auto_created:
+                    related_models.add(remote_field.through_model)
             if new_field.primary_key:
                 for many_to_many in opts.many_to_many:
                     # Ignore self-relationship since the table was already rebuilt.
                     if many_to_many.related_model == model:
                         continue
-                    if many_to_many.remote_field.through._meta.auto_created:
-                        related_models.add(many_to_many.remote_field.through)
+                    if many_to_many.remote_field.through_model._meta.auto_created:
+                        related_models.add(many_to_many.remote_field.through_model)
             for related_model in related_models:
                 self._remake_table(related_model)
 
diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py
index 75a3b8b030..20b28010c6 100644
--- a/django/db/migrations/operations/models.py
+++ b/django/db/migrations/operations/models.py
@@ -405,7 +405,7 @@ class RenameModel(ModelOperation):
                 # Skip self-referential fields as these are renamed above.
                 if (
                     new_field.model == new_field.related_model
-                    or not new_field.remote_field.through._meta.auto_created
+                    or not new_field.remote_field.through_model._meta.auto_created
                 ):
                     continue
                 # Rename the M2M table that's based on this model's name.
@@ -509,7 +509,7 @@ class AlterModelTable(ModelOptionOperation):
             for (old_field, new_field) in zip(
                 old_model._meta.local_many_to_many, new_model._meta.local_many_to_many
             ):
-                if new_field.remote_field.through._meta.auto_created:
+                if new_field.remote_field.through_model._meta.auto_created:
                     schema_editor.alter_db_table(
                         new_field.remote_field.through,
                         old_field.remote_field.through._meta.db_table,
diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py
index 32085daf18..f22c9f124a 100644
--- a/django/db/models/fields/related.py
+++ b/django/db/models/fields/related.py
@@ -1749,7 +1749,7 @@ class ManyToManyField(RelatedField):
         if getattr(self.remote_field, "through", None) is not None:
             if isinstance(self.remote_field.through, str):
                 kwargs["through"] = self.remote_field.through
-            elif not self.remote_field.through._meta.auto_created:
+            elif not self.remote_field.through_model._meta.auto_created:
                 kwargs["through"] = self.remote_field.through._meta.label
         # If swappable is True, then see if we're actually pointing to the target
         # of a swap.
diff --git a/django/db/models/fields/reverse_related.py b/django/db/models/fields/reverse_related.py
index eb2d4714bb..d9be3269ca 100644
--- a/django/db/models/fields/reverse_related.py
+++ b/django/db/models/fields/reverse_related.py
@@ -372,6 +372,17 @@ class ManyToManyRel(ForeignObjectRel):
         self.symmetrical = symmetrical
         self.db_constraint = db_constraint
 
+    @property
+    def through_model(self):
+        """
+        Return the through model, resolving string references if necessary.
+        """
+        if isinstance(self.through, str):
+            # Resolve string reference to model class
+            from django.apps import apps
+            return apps.get_model(self.through)
+        return self.through
+
     @property
     def identity(self):
         return super().identity + (
@@ -385,7 +396,7 @@ class ManyToManyRel(ForeignObjectRel):
         Return the field in the 'to' object to which this relationship is tied.
         Provided for symmetry with ManyToOneRel.
         """
-        opts = self.through._meta
+        opts = self.through_model._meta
         if self.through_fields:
             field = opts.get_field(self.through_fields[0])
         else:
