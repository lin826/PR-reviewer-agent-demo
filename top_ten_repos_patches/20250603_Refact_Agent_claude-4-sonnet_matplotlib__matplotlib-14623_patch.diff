diff --git a/lib/matplotlib/ticker.py b/lib/matplotlib/ticker.py
index 209a3f92ce..f0129ee0fe 100644
--- a/lib/matplotlib/ticker.py
+++ b/lib/matplotlib/ticker.py
@@ -2299,7 +2299,9 @@ class LogLocator(Locator):
 
         _log.debug('vmin %s vmax %s', vmin, vmax)
 
-        if vmax < vmin:
+        # Remember if the axis was intended to be inverted
+        inverted = vmax < vmin
+        if inverted:
             vmin, vmax = vmax, vmin
         log_vmin = math.log(vmin) / math.log(b)
         log_vmax = math.log(vmax) / math.log(b)
@@ -2355,9 +2357,17 @@ class LogLocator(Locator):
             # If we're a minor locator *that expects at least two ticks per
             # decade* and the major locator stride is 1 and there's no more
             # than one minor tick, switch to AutoLocator.
-            return AutoLocator().tick_values(vmin, vmax)
+            result = AutoLocator().tick_values(vmin, vmax)
+            # If the original axis was inverted, reverse the tick locations
+            if inverted:
+                result = result[::-1]
+            return result
         else:
-            return self.raise_if_exceeds(ticklocs)
+            result = self.raise_if_exceeds(ticklocs)
+            # If the original axis was inverted, reverse the tick locations
+            if inverted:
+                result = result[::-1]
+            return result
 
     def view_limits(self, vmin, vmax):
         'Try to choose the view limits intelligently'
@@ -2379,7 +2389,9 @@ class LogLocator(Locator):
         if not np.isfinite(vmin) or not np.isfinite(vmax):
             return 1, 10  # initial range, no data plotted yet
 
-        if vmin > vmax:
+        # Remember if the axis was intended to be inverted
+        inverted = vmin > vmax
+        if inverted:
             vmin, vmax = vmax, vmin
         if vmax <= 0:
             cbook._warn_external(
@@ -2395,6 +2407,10 @@ class LogLocator(Locator):
         if vmin == vmax:
             vmin = _decade_less(vmin, self._base)
             vmax = _decade_greater(vmax, self._base)
+        
+        # Restore the original order if the axis was intended to be inverted
+        if inverted:
+            vmin, vmax = vmax, vmin
         return vmin, vmax
 
 
