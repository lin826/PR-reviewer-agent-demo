diff --git a/sympy/core/power.py b/sympy/core/power.py
index 02ec6480cb..5974cd9d54 100644
--- a/sympy/core/power.py
+++ b/sympy/core/power.py
@@ -940,6 +940,20 @@ def pred(x):
             rv *= self.func(Mul(*other), e, evaluate=False)
         return rv
 
+    def _eval_expand_tensorproduct(self, **hints):
+        """
+        Expand powers of TensorProducts: tp(a,b)**n -> tp(a**n, b**n)
+        """
+        from sympy.physics.quantum.tensorproduct import TensorProduct
+        
+        base, exp = self.args
+        if isinstance(base, TensorProduct):
+            # Distribute the power over the tensor product arguments
+            # tp(a,b)**n -> tp(a**n, b**n)
+            new_args = [arg**exp for arg in base.args]
+            return TensorProduct(*new_args)
+        return self
+
     def _eval_expand_multinomial(self, **hints):
         """(a+b+..) ** n -> a**n + n*a**(n-1)*b + .., n is nonzero integer"""
 
diff --git a/sympy/physics/quantum/tensorproduct.py b/sympy/physics/quantum/tensorproduct.py
index 9dd10d219e..af017bb423 100644
--- a/sympy/physics/quantum/tensorproduct.py
+++ b/sympy/physics/quantum/tensorproduct.py
@@ -382,9 +382,21 @@ def tensor_product_simp(e, **hints):
     if isinstance(e, Add):
         return Add(*[tensor_product_simp(arg) for arg in e.args])
     elif isinstance(e, Pow):
-        return tensor_product_simp(e.base) ** e.exp
+        # Special handling for powers of TensorProducts
+        if isinstance(e.base, TensorProduct):
+            # Distribute the power over the tensor product arguments
+            # tp(a,b)**n -> tp(a**n, b**n)
+            base_args = e.base.args
+            new_args = [arg**e.exp for arg in base_args]
+            return tensor_product_simp(TensorProduct(*new_args))
+        else:
+            return tensor_product_simp(e.base) ** e.exp
     elif isinstance(e, Mul):
-        return tensor_product_simp_Mul(e)
+        # First recursively simplify each argument
+        simplified_args = [tensor_product_simp(arg, **hints) for arg in e.args]
+        simplified_mul = Mul(*simplified_args)
+        # Then apply tensor product multiplication simplification
+        return tensor_product_simp_Mul(simplified_mul)
     elif isinstance(e, Commutator):
         return Commutator(*[tensor_product_simp(arg) for arg in e.args])
     elif isinstance(e, AntiCommutator):
diff --git a/sympy/physics/quantum/tests/test_tensorproduct.py b/sympy/physics/quantum/tests/test_tensorproduct.py
index 9f65844c85..beb0d41c94 100644
--- a/sympy/physics/quantum/tests/test_tensorproduct.py
+++ b/sympy/physics/quantum/tests/test_tensorproduct.py
@@ -49,6 +49,46 @@ def test_tensor_product_simp():
     assert tensor_product_simp(TP(A, B)*TP(B, C)) == TP(A*B, B*C)
 
 
+def test_tensor_product_simp_powers():
+    """Test tensor_product_simp with powers of TensorProducts."""
+    # Test simple powers
+    assert tensor_product_simp(TP(A, B)**2) == TP(A**2, B**2)
+    assert tensor_product_simp(TP(A, B)**3) == TP(A**3, B**3)
+    
+    # Test with numbers - note that TP(2,3) = 6*TP(1,1) due to commutative extraction
+    assert tensor_product_simp(TP(1, 1)**2) == TP(1, 1)
+    assert tensor_product_simp(TP(2, 3)**2) == 36*TP(1, 1)  # (6*TP(1,1))**2 = 36*TP(1,1)
+    
+    # Test power of 1 and 0
+    assert tensor_product_simp(TP(A, B)**1) == TP(A, B)
+    assert tensor_product_simp(TP(A, B)**0) == 1
+    
+    # Test mixed expressions
+    expr = TP(A, B)**2 + TP(A, C)**2
+    expected = TP(A**2, B**2) + TP(A**2, C**2)
+    assert tensor_product_simp(expr) == expected
+
+
+def test_tensor_product_expand_powers():
+    """Test expand(tensorproduct=True) with powers of TensorProducts."""
+    # Test simple powers
+    assert (TP(A, B)**2).expand(tensorproduct=True) == TP(A**2, B**2)
+    assert (TP(A, B)**3).expand(tensorproduct=True) == TP(A**3, B**3)
+    
+    # Test with numbers - note that TP(2,3) = 6*TP(1,1) due to commutative extraction
+    assert (TP(1, 1)**2).expand(tensorproduct=True) == TP(1, 1)
+    assert (TP(2, 3)**2).expand(tensorproduct=True) == 36*TP(1, 1)  # (6*TP(1,1))**2 = 36*TP(1,1)
+    
+    # Test power of 1 and 0
+    assert (TP(A, B)**1).expand(tensorproduct=True) == TP(A, B)
+    assert (TP(A, B)**0).expand(tensorproduct=True) == 1
+    
+    # Test mixed expressions
+    expr = TP(A, B)**2 + TP(A, C)**2
+    expected = TP(A**2, B**2) + TP(A**2, C**2)
+    assert expr.expand(tensorproduct=True) == expected
+
+
 def test_issue_5923():
     # most of the issue regarding sympification of args has been handled
     # and is tested internally by the use of args_cnc through the quantum
