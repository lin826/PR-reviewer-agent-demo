--- a/django/db/models/expressions.py
+++ b/django/db/models/expressions.py
@@ -1253,7 +1253,7 @@
         self.descending = True
 
 
-class Window(Expression):
+class Window(SQLiteNumericMixin, Expression):
     template = '%(expression)s OVER (%(window)s)'
     # Although the main expression may either be an aggregate or an
     # expression with an aggregate function, the GROUP BY that will
@@ -1331,6 +1331,67 @@
             'expression': expr_sql,
             'window': ''.join(window_sql).strip()
         }, params
+
+    def as_sqlite(self, compiler, connection, **extra_context):
+        # Handle SQLite-specific casting for DecimalField windows
+        connection.ops.check_expression_support(self)
+        if not connection.features.supports_over_clause:
+            raise NotSupportedError('This backend does not support window expressions.')
+        
+        # Get the raw SQL without SQLite casting for the source expression
+        if hasattr(self.source_expression, 'as_sql'):
+            # Call the parent class's as_sql method to avoid SQLite casting
+            if hasattr(self.source_expression, '__class__') and hasattr(self.source_expression.__class__, '__mro__'):
+                # Find the first non-SQLiteNumericMixin class in the MRO
+                for cls in self.source_expression.__class__.__mro__:
+                    if cls != SQLiteNumericMixin and hasattr(cls, 'as_sql'):
+                        expr_sql, params = cls.as_sql(self.source_expression, compiler, connection)
+                        break
+                else:
+                    # Fallback to compiler.compile if we can't find appropriate method
+                    expr_sql, params = compiler.compile(self.source_expression)
+            else:
+                expr_sql, params = compiler.compile(self.source_expression)
+        else:
+            expr_sql, params = compiler.compile(self.source_expression)
+            
+        window_sql, window_params = [], []
+
+        if self.partition_by is not None:
+            sql_expr, sql_params = self.partition_by.as_sql(
+                compiler=compiler, connection=connection,
+                template='PARTITION BY %(expressions)s',
+            )
+            window_sql.extend(sql_expr)
+            window_params.extend(sql_params)
+
+        if self.order_by is not None:
+            window_sql.append(' ORDER BY ')
+            order_sql, order_params = compiler.compile(self.order_by)
+            window_sql.extend(order_sql)
+            window_params.extend(order_params)
+
+        if self.frame:
+            frame_sql, frame_params = compiler.compile(self.frame)
+            window_sql.append(' ' + frame_sql)
+            window_params.extend(frame_params)
+
+        params.extend(window_params)
+        template = self.template
+
+        sql = template % {
+            'expression': expr_sql,
+            'window': ''.join(window_sql).strip()
+        }
+        
+        # Apply SQLite casting to the entire window expression if needed
+        try:
+            if self.output_field.get_internal_type() == 'DecimalField':
+                sql = 'CAST(%s AS NUMERIC)' % sql
+        except (AttributeError, FieldError):
+            pass
+            
+        return sql, params
 
     def __str__(self):
         return '{} OVER ({}{}{})'.format(
