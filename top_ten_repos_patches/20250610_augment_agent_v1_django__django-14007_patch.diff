diff --git a/django/db/models/base.py b/django/db/models/base.py
index 55b1691166..ac54b61dc1 100644
--- a/django/db/models/base.py
+++ b/django/db/models/base.py
@@ -869,11 +869,17 @@ class Model(metaclass=ModelBase):
                 fields = [f for f in fields if f is not meta.auto_field]
 
             returning_fields = meta.db_returning_fields
             results = self._do_insert(cls._base_manager, using, fields, returning_fields, raw)
             if results:
+                connection_obj = connections[using]
                 for value, field in zip(results[0], returning_fields):
+                    # Apply field converters (including from_db_value) to returned values
+                    converters = field.get_db_converters(connection_obj)
+                    if converters:
+                        for converter in converters:
+                            value = converter(value, field, connection_obj)
                     setattr(self, field.attname, value)
         return updated
 
     def _do_update(self, base_qs, using, pk_val, values, update_fields, forced_update):
         """
diff --git a/django/db/models/query.py b/django/db/models/query.py
index 387deca527..e6effe2b49 100644
--- a/django/db/models/query.py
+++ b/django/db/models/query.py
@@ -503,10 +503,15 @@ class QuerySet:
                     objs_with_pk, fields, batch_size, ignore_conflicts=ignore_conflicts,
                 )
                 for obj_with_pk, results in zip(objs_with_pk, returned_columns):
                     for result, field in zip(results, opts.db_returning_fields):
                         if field != opts.pk:
+                            # Apply field converters (including from_db_value) to returned values
+                            converters = field.get_db_converters(connection)
+                            if converters:
+                                for converter in converters:
+                                    result = converter(result, field, connection)
                             setattr(obj_with_pk, field.attname, result)
                 for obj_with_pk in objs_with_pk:
                     obj_with_pk._state.adding = False
                     obj_with_pk._state.db = self.db
             if objs_without_pk:
@@ -516,10 +521,15 @@ class QuerySet:
                 )
                 if connection.features.can_return_rows_from_bulk_insert and not ignore_conflicts:
                     assert len(returned_columns) == len(objs_without_pk)
                 for obj_without_pk, results in zip(objs_without_pk, returned_columns):
                     for result, field in zip(results, opts.db_returning_fields):
+                        # Apply field converters (including from_db_value) to returned values
+                        converters = field.get_db_converters(connection)
+                        if converters:
+                            for converter in converters:
+                                result = converter(result, field, connection)
                         setattr(obj_without_pk, field.attname, result)
                     obj_without_pk._state.adding = False
                     obj_without_pk._state.db = self.db
 
         return objs
diff --git a/tests/from_db_value/models.py b/tests/from_db_value/models.py
index 58e8ec3a27..361647a605 100644
--- a/tests/from_db_value/models.py
+++ b/tests/from_db_value/models.py
@@ -19,5 +19,37 @@ class CashField(models.DecimalField):
         return cash
 
 
 class CashModel(models.Model):
     cash = CashField()
+
+
+class IntWrapper:
+    def __init__(self, value):
+        self.value = value
+    
+    def __repr__(self):
+        return f"<IntWrapper: {self.value}>"
+    
+    def __int__(self):
+        return self.value
+    
+    def __eq__(self, other):
+        if isinstance(other, IntWrapper):
+            return self.value == other.value
+        return self.value == other
+
+
+class CustomAutoField(models.BigAutoField):
+    def from_db_value(self, value, expression, connection):
+        if value is None:
+            return None
+        return IntWrapper(value)
+    
+    def get_prep_value(self, value):
+        if value is None:
+            return None
+        return int(value)
+
+
+class AutoModel(models.Model):
+    id = CustomAutoField(primary_key=True)
diff --git a/tests/from_db_value/tests.py b/tests/from_db_value/tests.py
index ab92f37ccf..9331825c9e 100644
--- a/tests/from_db_value/tests.py
+++ b/tests/from_db_value/tests.py
@@ -1,10 +1,12 @@
+import unittest
+
 from django.db import connection
 from django.db.models import Max
 from django.test import TestCase
 
-from .models import Cash, CashModel
+from .models import Cash, CashModel, AutoModel, IntWrapper
 
 
 class FromDBValueTest(TestCase):
     @classmethod
     def setUpTestData(cls):
@@ -31,5 +33,51 @@ class FromDBValueTest(TestCase):
         self.assertIsInstance(instance.cash, Cash)
 
     def test_connection(self):
         instance = CashModel.objects.get()
         self.assertEqual(instance.cash.vendor, connection.vendor)
+
+    def test_create(self):
+        """Test that from_db_value is called for create() operations."""
+        # This test is for regular fields, but from_db_value is only called
+        # for returning fields (like auto fields) during create operations.
+        # Regular fields get their from_db_value called during queries, not creates.
+        instance = CashModel.objects.create(cash='15.75')
+        # The cash field won't have from_db_value called during create
+        # because it's not a returning field
+        self.assertEqual(str(instance.cash), '15.75')
+
+    @unittest.skipUnless(connection.features.can_return_rows_from_bulk_insert, 
+                         "Database doesn't support returning rows from bulk insert")
+    def test_bulk_create(self):
+        """Test that from_db_value is called for bulk_create() operations."""
+        instances = [CashModel(cash='20.25'), CashModel(cash='30.50')]
+        CashModel.objects.bulk_create(instances)
+        
+        for instance in instances:
+            self.assertIsInstance(instance.cash, Cash)
+            self.assertEqual(instance.cash.vendor, connection.vendor)
+
+
+class AutoFieldFromDBValueTest(TestCase):
+    """Test from_db_value for auto fields during create and bulk_create operations."""
+    
+    def test_auto_field_create(self):
+        """Test that from_db_value is called for auto fields during create() operations."""
+        instance = AutoModel.objects.create()
+        self.assertIsInstance(instance.id, IntWrapper)
+    
+    def test_auto_field_query(self):
+        """Test that from_db_value is called for auto fields during query operations."""
+        AutoModel.objects.create()
+        instance = AutoModel.objects.first()
+        self.assertIsInstance(instance.id, IntWrapper)
+    
+    @unittest.skipUnless(connection.features.can_return_rows_from_bulk_insert, 
+                         "Database doesn't support returning rows from bulk insert")
+    def test_auto_field_bulk_create(self):
+        """Test that from_db_value is called for auto fields during bulk_create() operations."""
+        instances = [AutoModel(), AutoModel()]
+        AutoModel.objects.bulk_create(instances)
+        
+        for instance in instances:
+            self.assertIsInstance(instance.id, IntWrapper)
