diff --git a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py
index d7605b078c..9008bc0777 100644
--- a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py
+++ b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py
@@ -151,10 +151,37 @@ class SlicedLowLevelWCS(BaseWCSWrapper):
 
         if len(self._pixel_keep) == 0 or len(self._world_keep) == 0:
             raise ValueError("Cannot slice WCS: the resulting WCS should have "
                              "at least one pixel and one world dimension.")
 
+    @lazyproperty
+    def _reference_world_coordinates(self):
+        """
+        Reference world coordinates for all dimensions of the underlying WCS.
+        
+        These are the world coordinates corresponding to the reference pixel
+        coordinates (CRPIX) and are used as default values for dropped dimensions
+        in world_to_pixel transformations.
+        """
+        try:
+            # Get reference pixel coordinates (CRPIX - 1 for 0-based indexing)
+            ref_pixel = []
+            for ipix in range(self._wcs.pixel_n_dim):
+                if hasattr(self._wcs, 'wcs') and hasattr(self._wcs.wcs, 'crpix'):
+                    # For FITS WCS objects
+                    ref_pixel.append(self._wcs.wcs.crpix[ipix] - 1)
+                else:
+                    # Fallback: use 0 as reference pixel
+                    ref_pixel.append(0.0)
+            
+            # Convert to world coordinates
+            return self._wcs.pixel_to_world_values(*ref_pixel)
+        except Exception:
+            # If we can't compute reference coordinates, fall back to zeros
+            # This maintains backward compatibility in case of errors
+            return [0.0] * self._wcs.world_n_dim
+
     @lazyproperty
     def dropped_world_dimensions(self):
         """
         Information describing the dropped world dimensions.
         """
@@ -249,11 +276,22 @@ class SlicedLowLevelWCS(BaseWCSWrapper):
         for iworld in range(self._wcs.world_n_dim):
             if iworld in self._world_keep:
                 iworld_curr += 1
                 world_arrays_new.append(world_arrays[iworld_curr])
             else:
-                world_arrays_new.append(1.)
+                # Use reference world coordinate for dropped dimensions instead of 1.0
+                # This is crucial for WCS with coupled dimensions (non-diagonal PC matrix)
+                try:
+                    ref_coords = self._reference_world_coordinates
+                    if isinstance(ref_coords, (list, tuple)):
+                        world_arrays_new.append(ref_coords[iworld])
+                    else:
+                        # Single dimension case
+                        world_arrays_new.append(ref_coords)
+                except (IndexError, TypeError):
+                    # Fallback to the old behavior if reference coordinates fail
+                    world_arrays_new.append(1.0)
 
         world_arrays_new = np.broadcast_arrays(*world_arrays_new)
         pixel_arrays = list(self._wcs.world_to_pixel_values(*world_arrays_new))
 
         for ipixel in range(self._wcs.pixel_n_dim):
