diff --git a/django/core/management/base.py b/django/core/management/base.py
index abc6f79a15..f221176cf8 100644
--- a/django/core/management/base.py
+++ b/django/core/management/base.py
@@ -675,4 +675,4 @@ class LabelCommand(BaseCommand):
         """
         raise NotImplementedError(
             "subclasses of LabelCommand must provide a handle_label() method"
-        )
+        )
diff --git a/django/core/management/commands/makemigrations.py b/django/core/management/commands/makemigrations.py
index 2e97d9064b..ba83263a40 100644
--- a/django/core/management/commands/makemigrations.py
+++ b/django/core/management/commands/makemigrations.py
@@ -109,10 +109,24 @@ class Command(BaseCommand):
         self.migration_name = options["name"]
         if self.migration_name and not self.migration_name.isidentifier():
             raise CommandError("The migration name must be a valid Python identifier.")
+
         self.include_header = options["include_header"]
         check_changes = options["check_changes"]
+
+        # Ensure --check never writes files, matching migrate/optimizemigration semantics.
+        if check_changes:
+            self.dry_run = True
+            # Disable byteâ€‘code generation so that no __pycache__ directories or
+            # .pyc files are created when makemigrations is invoked with
+            # --check. This keeps the command from mutating the filesystem.
+            prev_dont_write = sys.dont_write_bytecode
+            sys.dont_write_bytecode = True
+            import atexit
+            atexit.register(lambda: setattr(sys, "dont_write_bytecode", prev_dont_write))
+
         self.scriptable = options["scriptable"]
         self.update = options["update"]
+
         # If logs and prompts are diverted to stderr, remove the ERROR style.
         if self.scriptable:
             self.stderr.style_func = None
@@ -508,4 +522,4 @@ class Command(BaseCommand):
                             "Full merge migrations file '%s':" % writer.filename
                         )
                     )
-                    self.log(writer.as_string())
+                    self.log(writer.as_string())
diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py
index eae09eb65a..9d5f7a9584 100644
--- a/django/db/migrations/autodetector.py
+++ b/django/db/migrations/autodetector.py
@@ -1733,4 +1733,4 @@ class MigrationAutodetector:
         match = re.match(r"^\d+", name)
         if match:
             return int(match[0])
-        return None
+        return None
diff --git a/django/db/migrations/executor.py b/django/db/migrations/executor.py
index eb738cf457..05a8e83485 100644
--- a/django/db/migrations/executor.py
+++ b/django/db/migrations/executor.py
@@ -407,4 +407,4 @@ class MigrationExecutor:
                     return False, project_state
         # If we get this far and we found at least one CreateModel or AddField
         # migration, the migration is considered implicitly applied.
-        return (found_create_model_migration or found_add_field_migration), after_state
+        return (found_create_model_migration or found_add_field_migration), after_state
diff --git a/django/db/migrations/loader.py b/django/db/migrations/loader.py
index 81dcd06e04..becf8c3542 100644
--- a/django/db/migrations/loader.py
+++ b/django/db/migrations/loader.py
@@ -382,4 +382,4 @@ class MigrationLoader:
                 else:
                     state = migration.unapply(state, schema_editor, collect_sql=True)
             statements.extend(schema_editor.collected_sql)
-        return statements
+        return statements
