diff --git a/xarray/coding/variables.py b/xarray/coding/variables.py
index b035ff82..938752c4 100644
--- a/xarray/coding/variables.py
+++ b/xarray/coding/variables.py
@@ -316,6 +316,14 @@ class UnsignedIntegerCoder(VariableCoder):
                     if "_FillValue" in attrs:
                         new_fill = unsigned_dtype.type(attrs["_FillValue"])
                         attrs["_FillValue"] = new_fill
+            elif data.dtype.kind == "u":
+                if unsigned == "false":
+                    signed_dtype = np.dtype("i%s" % data.dtype.itemsize)
+                    transform = partial(np.asarray, dtype=signed_dtype)
+                    data = lazy_elemwise_func(data, transform, signed_dtype)
+                    if "_FillValue" in attrs:
+                        new_fill = signed_dtype.type(attrs["_FillValue"])
+                        attrs["_FillValue"] = new_fill
             else:
                 warnings.warn(
                     "variable %r has _Unsigned attribute but is not "
diff --git a/xarray/tests/test_coding.py b/xarray/tests/test_coding.py
index e0df7782..36ad8a48 100644
--- a/xarray/tests/test_coding.py
+++ b/xarray/tests/test_coding.py
@@ -117,3 +117,84 @@ def test_scaling_offset_as_list(scale_factor, add_offset):
     encoded = coder.encode(original)
     roundtripped = coder.decode(encoded)
     assert_allclose(original, roundtripped)
+
+
+def test_unsigned_integer_coder_unsigned_false():
+    """Test UnsignedIntegerCoder with _Unsigned=false on unsigned data.
+    
+    This tests the fix for handling signed bytes from OPeNDAP via pydap.
+    See: https://github.com/pydata/xarray/issues/4966
+    """
+    coder = variables.UnsignedIntegerCoder()
+    
+    # Test case: unsigned bytes with _Unsigned=false (pydap scenario)
+    # This simulates data from OPeNDAP/pydap where unsigned bytes
+    # should be interpreted as signed bytes
+    data = np.array([128, 255, 0, 1, 2, 127], dtype='u1')
+    attrs = {'_Unsigned': 'false'}
+    var = xr.Variable(['x'], data, attrs)
+    
+    decoded = coder.decode(var, name='test')
+    expected_data = np.array([-128, -1, 0, 1, 2, 127], dtype='i1')
+    
+    assert decoded.data.dtype == np.dtype('i1')
+    assert np.array_equal(decoded.data, expected_data)
+    assert '_Unsigned' not in decoded.attrs
+
+
+def test_unsigned_integer_coder_unsigned_false_with_fillvalue():
+    """Test UnsignedIntegerCoder with _Unsigned=false and _FillValue."""
+    coder = variables.UnsignedIntegerCoder()
+    
+    # Test with _FillValue that needs conversion
+    data = np.array([128, 255, 0, 1, 127], dtype='u1')
+    attrs = {'_Unsigned': 'false', '_FillValue': 255}
+    var = xr.Variable(['x'], data, attrs)
+    
+    decoded = coder.decode(var, name='test')
+    expected_data = np.array([-128, -1, 0, 1, 127], dtype='i1')
+    
+    assert decoded.data.dtype == np.dtype('i1')
+    assert np.array_equal(decoded.data, expected_data)
+    assert decoded.attrs['_FillValue'] == -1  # 255 as signed int8 is -1
+    assert '_Unsigned' not in decoded.attrs
+
+
+@pytest.mark.parametrize("dtype_char,unsigned_val,signed_val", [
+    ('1', 255, -1),  # 8-bit
+    ('2', 65535, -1),  # 16-bit  
+    ('4', 4294967295, -1),  # 32-bit
+])
+def test_unsigned_integer_coder_different_sizes(dtype_char, unsigned_val, signed_val):
+    """Test UnsignedIntegerCoder with different integer sizes."""
+    coder = variables.UnsignedIntegerCoder()
+    
+    unsigned_dtype = f'u{dtype_char}'
+    signed_dtype = f'i{dtype_char}'
+    
+    data = np.array([unsigned_val, 0, 1], dtype=unsigned_dtype)
+    attrs = {'_Unsigned': 'false'}
+    var = xr.Variable(['x'], data, attrs)
+    
+    decoded = coder.decode(var, name='test')
+    expected_data = np.array([signed_val, 0, 1], dtype=signed_dtype)
+    
+    assert decoded.data.dtype == np.dtype(signed_dtype)
+    assert np.array_equal(decoded.data, expected_data)
+
+
+def test_unsigned_integer_coder_backward_compatibility():
+    """Test that existing _Unsigned=true functionality still works."""
+    coder = variables.UnsignedIntegerCoder()
+    
+    # Test signed int with _Unsigned=true (existing functionality)
+    data = np.array([-128, -1, 0, 1, 127], dtype='i1')
+    attrs = {'_Unsigned': 'true'}
+    var = xr.Variable(['x'], data, attrs)
+    
+    decoded = coder.decode(var, name='test')
+    expected_data = np.array([128, 255, 0, 1, 127], dtype='u1')
+    
+    assert decoded.data.dtype == np.dtype('u1')
+    assert np.array_equal(decoded.data, expected_data)
+    assert '_Unsigned' not in decoded.attrs
