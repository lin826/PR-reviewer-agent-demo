diff --git a/sympy/physics/quantum/tensorproduct.py b/sympy/physics/quantum/tensorproduct.py
index 9dd10d219e..0913a65f23 100644
--- a/sympy/physics/quantum/tensorproduct.py
+++ b/sympy/physics/quantum/tensorproduct.py
@@ -380,12 +380,25 @@ def tensor_product_simp(e, **hints):
 
     """
     if isinstance(e, Add):
         return Add(*[tensor_product_simp(arg) for arg in e.args])
     elif isinstance(e, Pow):
-        return tensor_product_simp(e.base) ** e.exp
+        # Handle powers of TensorProducts by applying the power to each argument
+        if isinstance(e.base, TensorProduct) and e.exp.is_integer and e.exp.is_positive:
+            # TensorProduct(A, B)**n -> TensorProduct(A**n, B**n)
+            new_args = [tensor_product_simp(arg ** e.exp) for arg in e.base.args]
+            return TensorProduct(*new_args)
+        else:
+            return tensor_product_simp(e.base) ** e.exp
     elif isinstance(e, Mul):
+        # First, recursively simplify each argument
+        simplified_args = [tensor_product_simp(arg) for arg in e.args]
+        if simplified_args != list(e.args):
+            # If any argument was simplified, create a new Mul and try again
+            new_mul = Mul(*simplified_args)
+            if new_mul != e:
+                return tensor_product_simp(new_mul)
         return tensor_product_simp_Mul(e)
     elif isinstance(e, Commutator):
         return Commutator(*[tensor_product_simp(arg) for arg in e.args])
     elif isinstance(e, AntiCommutator):
         return AntiCommutator(*[tensor_product_simp(arg) for arg in e.args])
