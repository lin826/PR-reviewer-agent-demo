diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index 13a6809dd8..a2a1febd60 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -428,10 +428,20 @@ class Query(BaseExpression):
         self.set_annotation_mask(annotation_select_mask)
         # Existing usage of aggregation can be determined by the presence of
         # selected aggregates but also by filters against aliased aggregates.
         _, having, qualify = self.where.split_having_qualify()
         has_existing_aggregation = (
+            any(
+                getattr(annotation, "contains_aggregate", True) or
+                getattr(annotation, "contains_over_clause", False)
+                for annotation in self.annotations.values()
+            )
+            or having
+        )
+        # Separate condition for actual aggregations (not window functions)
+        # This is used to determine if GROUP BY is needed
+        has_existing_actual_aggregation = (
             any(
                 getattr(annotation, "contains_aggregate", True)
                 for annotation in self.annotations.values()
             )
             or having
@@ -471,11 +481,11 @@ class Query(BaseExpression):
                 # If the inner query uses default select and it has some
                 # aggregate annotations, then we must make sure the inner
                 # query is grouped by the main model's primary key. However,
                 # clearing the select clause can alter results if distinct is
                 # used.
-                if inner_query.default_cols and has_existing_aggregation:
+                if inner_query.default_cols and has_existing_actual_aggregation:
                     inner_query.group_by = (
                         self.model._meta.pk.get_col(inner_query.get_initial_alias()),
                     )
                 inner_query.default_cols = False
                 if not qualify:
