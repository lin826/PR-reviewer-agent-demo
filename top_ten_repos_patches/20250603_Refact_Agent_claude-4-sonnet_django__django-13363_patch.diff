diff --git a/django/db/models/functions/datetime.py b/django/db/models/functions/datetime.py
index b6594b043b..6828980733 100644
--- a/django/db/models/functions/datetime.py
+++ b/django/db/models/functions/datetime.py
@@ -292,7 +292,7 @@ class TruncDate(TruncBase):
     def as_sql(self, compiler, connection):
         # Cast to date rather than truncate to date.
         lhs, lhs_params = compiler.compile(self.lhs)
-        tzname = timezone.get_current_timezone_name() if settings.USE_TZ else None
+        tzname = self.get_tzname()
         sql = connection.ops.datetime_cast_date_sql(lhs, tzname)
         return sql, lhs_params
 
@@ -305,7 +305,7 @@ class TruncTime(TruncBase):
     def as_sql(self, compiler, connection):
         # Cast to time rather than truncate to time.
         lhs, lhs_params = compiler.compile(self.lhs)
-        tzname = timezone.get_current_timezone_name() if settings.USE_TZ else None
+        tzname = self.get_tzname()
         sql = connection.ops.datetime_cast_time_sql(lhs, tzname)
         return sql, lhs_params
 
diff --git a/tests/db_functions/datetime/test_extract_trunc.py b/tests/db_functions/datetime/test_extract_trunc.py
index f8ebb81cb5..45323c4159 100644
--- a/tests/db_functions/datetime/test_extract_trunc.py
+++ b/tests/db_functions/datetime/test_extract_trunc.py
@@ -1226,3 +1226,101 @@ class DateFunctionWithTimeZoneTests(DateFunctionTests):
 
         qs = DTModel.objects.filter(start_datetime__date=Trunc('start_datetime', 'day', output_field=DateField()))
         self.assertEqual(qs.count(), 2)
+
+    def test_trunc_date_func_with_timezone(self):
+        """
+        Test that TruncDate respects the tzinfo parameter.
+        """
+        start_datetime = datetime(2016, 1, 1, 1, 30, 50, 321)
+        end_datetime = datetime(2016, 6, 15, 14, 10, 50, 123)
+        start_datetime = timezone.make_aware(start_datetime, is_dst=False)
+        end_datetime = timezone.make_aware(end_datetime, is_dst=False)
+        self.create_model(start_datetime, end_datetime)
+
+        melb = pytz.timezone('Australia/Melbourne')
+        pacific = pytz.timezone('US/Pacific')
+
+        model = DTModel.objects.annotate(
+            melb_date=TruncDate('start_datetime', tzinfo=melb),
+            pacific_date=TruncDate('start_datetime', tzinfo=pacific),
+            utc_date=TruncDate('start_datetime', tzinfo=timezone.utc),
+        ).order_by('start_datetime').get()
+
+        self.assertEqual(model.start_datetime, start_datetime)
+        # Convert to target timezone and get date
+        melb_expected = start_datetime.astimezone(melb).date()
+        pacific_expected = start_datetime.astimezone(pacific).date()
+        utc_expected = start_datetime.astimezone(timezone.utc).date()
+        
+        self.assertEqual(model.melb_date, melb_expected)
+        self.assertEqual(model.pacific_date, pacific_expected)
+        self.assertEqual(model.utc_date, utc_expected)
+
+    def test_trunc_time_func_with_timezone(self):
+        """
+        Test that TruncTime respects the tzinfo parameter.
+        """
+        start_datetime = datetime(2016, 1, 1, 1, 30, 50, 321)
+        end_datetime = datetime(2016, 6, 15, 14, 10, 50, 123)
+        start_datetime = timezone.make_aware(start_datetime, is_dst=False)
+        end_datetime = timezone.make_aware(end_datetime, is_dst=False)
+        self.create_model(start_datetime, end_datetime)
+
+        melb = pytz.timezone('Australia/Melbourne')
+        pacific = pytz.timezone('US/Pacific')
+
+        model = DTModel.objects.annotate(
+            melb_time=TruncTime('start_datetime', tzinfo=melb),
+            pacific_time=TruncTime('start_datetime', tzinfo=pacific),
+            utc_time=TruncTime('start_datetime', tzinfo=timezone.utc),
+        ).order_by('start_datetime').get()
+
+        self.assertEqual(model.start_datetime, start_datetime)
+        # Convert to target timezone and get time
+        melb_expected = start_datetime.astimezone(melb).time()
+        pacific_expected = start_datetime.astimezone(pacific).time()
+        utc_expected = start_datetime.astimezone(timezone.utc).time()
+        
+        self.assertEqual(model.melb_time, melb_expected)
+        self.assertEqual(model.pacific_time, pacific_expected)
+        self.assertEqual(model.utc_time, utc_expected)
+
+    def test_trunc_date_func_with_timezone_crossing_date_boundary(self):
+        """
+        Test TruncDate with timezone that changes the date.
+        """
+        # Create a datetime that's early morning UTC but late previous day in NY
+        utc_datetime = timezone.make_aware(datetime(2023, 6, 16, 3, 30), timezone.utc)
+        self.create_model(utc_datetime, utc_datetime)
+
+        ny_tz = pytz.timezone('America/New_York')
+
+        model = DTModel.objects.annotate(
+            utc_date=TruncDate('start_datetime'),  # Should use current timezone (UTC)
+            ny_date=TruncDate('start_datetime', tzinfo=ny_tz),
+        ).get()
+
+        # UTC date should be 2023-06-16
+        self.assertEqual(str(model.utc_date), '2023-06-16')
+        # NY date should be 2023-06-15 (previous day)
+        self.assertEqual(str(model.ny_date), '2023-06-15')
+
+    def test_trunc_time_func_with_timezone_different_times(self):
+        """
+        Test TruncTime with timezone that changes the time.
+        """
+        # Create a datetime 
+        utc_datetime = timezone.make_aware(datetime(2023, 6, 15, 20, 30), timezone.utc)
+        self.create_model(utc_datetime, utc_datetime)
+
+        ny_tz = pytz.timezone('America/New_York')
+
+        model = DTModel.objects.annotate(
+            utc_time=TruncTime('start_datetime'),  # Should use current timezone (UTC)
+            ny_time=TruncTime('start_datetime', tzinfo=ny_tz),
+        ).get()
+
+        # UTC time should be 20:30:00
+        self.assertEqual(str(model.utc_time), '20:30:00')
+        # NY time should be 16:30:00 (4 hours earlier)
+        self.assertEqual(str(model.ny_time), '16:30:00')
