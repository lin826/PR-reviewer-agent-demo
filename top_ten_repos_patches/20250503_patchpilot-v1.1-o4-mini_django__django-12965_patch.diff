diff --git a/django/db/models/query.py b/django/db/models/query.py
index e0d8d05..677fc68 100644
--- a/django/db/models/query.py
+++ b/django/db/models/query.py
@@ -758,13 +758,9 @@ class QuerySet:
         Delete objects found from the given queryset in single direct SQL
         query. No signals are sent and there is no protection for cascades.
         """
-        query = self.query.clone()
-        query.__class__ = sql.DeleteQuery
-        cursor = query.get_compiler(using).execute_sql(CURSOR)
-        if cursor:
-            with cursor:
-                return cursor.rowcount
-        return 0
+
+        return sql.DeleteQuery(self.model).delete_qs(self, using)
+
     _raw_delete.alters_data = True
 
     def update(self, **kwargs):
diff --git a/django/db/models/sql/subqueries.py b/django/db/models/sql/subqueries.py
index 6a6c983..aa3e147 100644
--- a/django/db/models/sql/subqueries.py
+++ b/django/db/models/sql/subqueries.py
@@ -2,8 +2,11 @@
 Query subclasses which provide extra functionality beyond simple data retrieval.
 """
 
+
 from django.core.exceptions import FieldError
+from django.db import connections
 from django.db.models.query_utils import Q
+
 from django.db.models.sql.constants import (
     CURSOR, GET_ITERATOR_CHUNK_SIZE, NO_RESULTS,
 )
@@ -17,6 +20,7 @@ class DeleteQuery(Query):
 
     compiler = 'SQLDeleteCompiler'
 
+
     def do_query(self, table, where, using):
         self.alias_map = {table: self.alias_map[table]}
         self.where = where
@@ -26,7 +30,35 @@ class DeleteQuery(Query):
                 return cursor.rowcount
         return 0
 
+    def delete_qs(self, query, using):
+        """
+        Delete the queryset in one SQL query (if possible). For simple queries
+        this is done by copying the query.query.where to self.query, for
+        complex queries by using subquery or batch deletes.
+        """
+        innerq = query.query
+        innerq.get_initial_alias()
+        self.get_initial_alias()
+        innerq_used = [t for t in innerq.alias_map if innerq.alias_refcount[t]]
+        if not innerq_used or tuple(innerq_used) == tuple(self.alias_map):
+            self.where = innerq.where
+        else:
+            pk = query.model._meta.pk
+            if not connections[using].features.update_can_self_select:
+                vals = list(query.values_list('pk', flat=True))
+                if not vals:
+                    return 0
+                return self.delete_batch(vals, using)
+            innerq.clear_select_clause()
+            innerq.select = [pk.get_col(self.get_initial_alias())]
+            vals = innerq
+            self.where = self.where_class()
+            self.add_q(Q(pk__in=vals))
+        cursor = self.get_compiler(using).execute_sql(CURSOR)
+        return cursor.rowcount if cursor else 0
+
     def delete_batch(self, pk_list, using):
+
         """
         Set up and execute delete queries for all the objects in pk_list.
 
