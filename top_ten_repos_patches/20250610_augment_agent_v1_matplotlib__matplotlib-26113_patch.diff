diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py
index 5369eadbde..cdf706cfe5 100644
--- a/lib/matplotlib/axes/_axes.py
+++ b/lib/matplotlib/axes/_axes.py
@@ -4845,12 +4845,12 @@ default: :rc:`scatter.edgecolors`
             Use a linear or log10 scale on the horizontal axis.
 
         yscale : {'linear', 'log'}, default: 'linear'
             Use a linear or log10 scale on the vertical axis.
 
-        mincnt : int > 0, default: *None*
-            If not *None*, only display cells with more than *mincnt*
+        mincnt : int >= 0, default: *None*
+            If not *None*, only display cells with at least *mincnt*
             number of points in the cell.
 
         marginals : bool, default: *False*
             If marginals is *True*, plot the marginal density as
             colormapped rectangles along the bottom of the x-axis and
@@ -5009,17 +5009,26 @@ default: :rc:`scatter.edgecolors`
             for i in range(len(x)):
                 if bdist[i]:
                     Cs_at_i1[i1[i]].append(C[i])
                 else:
                     Cs_at_i2[i2[i]].append(C[i])
+            # Use a different default for when mincnt was originally None
+            # vs when it was explicitly set, to maintain backward compatibility
             if mincnt is None:
-                mincnt = 0
-            accum = np.array(
-                [reduce_C_function(acc) if len(acc) > mincnt else np.nan
-                 for Cs_at_i in [Cs_at_i1, Cs_at_i2]
-                 for acc in Cs_at_i[1:]],  # [1:] drops out-of-range points.
-                float)
+                # When mincnt is not specified, only show non-empty hexagons
+                accum = np.array(
+                    [reduce_C_function(acc) if len(acc) > 0 else np.nan
+                     for Cs_at_i in [Cs_at_i1, Cs_at_i2]
+                     for acc in Cs_at_i[1:]],  # [1:] drops out-of-range points.
+                    float)
+            else:
+                # When mincnt is explicitly specified, use >= for consistency with C=None case
+                accum = np.array(
+                    [reduce_C_function(acc) if len(acc) >= mincnt else np.nan
+                     for Cs_at_i in [Cs_at_i1, Cs_at_i2]
+                     for acc in Cs_at_i[1:]],  # [1:] drops out-of-range points.
+                    float)
 
         good_idxs = ~np.isnan(accum)
 
         offsets = np.zeros((n, 2), float)
         offsets[:nx1 * ny1, 0] = np.repeat(np.arange(nx1), ny1)
