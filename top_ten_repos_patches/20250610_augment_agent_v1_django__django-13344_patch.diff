diff --git a/django/core/handlers/exception.py b/django/core/handlers/exception.py
index 98fb46083a..5542c3d3c4 100644
--- a/django/core/handlers/exception.py
+++ b/django/core/handlers/exception.py
@@ -29,11 +29,17 @@ def convert_exception_to_response(get_response):
 
     This decorator is automatically applied to all middleware to ensure that
     no middleware leaks an exception and that the next middleware in the stack
     can rely on getting a response instead of an exception.
     """
-    if asyncio.iscoroutinefunction(get_response):
+    # Check if get_response is a coroutine function or a MiddlewareMixin with async behavior
+    is_async = asyncio.iscoroutinefunction(get_response) or (
+        hasattr(get_response, 'get_response') and 
+        asyncio.iscoroutinefunction(get_response.get_response)
+    )
+    
+    if is_async:
         @wraps(get_response)
         async def inner(request):
             try:
                 response = await get_response(request)
             except Exception as exc:
@@ -43,10 +49,31 @@ def convert_exception_to_response(get_response):
     else:
         @wraps(get_response)
         def inner(request):
             try:
                 response = get_response(request)
+                # If the response is a coroutine (e.g., from an async middleware),
+                # we need to await it.
+                if asyncio.iscoroutine(response):
+                    # We're in a sync context but got a coroutine. This shouldn't
+                    # normally happen, but if it does, we need to handle it.
+                    import warnings
+                    warnings.warn(
+                        "Synchronous middleware received a coroutine response. "
+                        "This may indicate a middleware configuration issue.",
+                        RuntimeWarning
+                    )
+                    # Try to run the coroutine
+                    loop = asyncio.get_event_loop()
+                    if loop.is_running():
+                        # We're already in an async context, this is problematic
+                        raise RuntimeError(
+                            "Cannot handle coroutine response in synchronous middleware "
+                            "while an event loop is running. Check your middleware configuration."
+                        )
+                    else:
+                        response = loop.run_until_complete(response)
             except Exception as exc:
                 response = response_for_exception(request, exc)
             return response
         return inner
 
