diff --git a/sphinx/directives/other.py b/sphinx/directives/other.py
index 19f7c0a8d..518a6204b 100644
--- a/sphinx/directives/other.py
+++ b/sphinx/directives/other.py
@@ -376,7 +376,55 @@ class Include(BaseInclude, SphinxDirective):
         rel_filename, filename = self.env.relfn2path(self.arguments[0])
         self.arguments[0] = filename
         self.env.note_included(filename)
-        return super().run()
+        
+        # Use Sphinx's source processing pipeline instead of direct file reading
+        # to ensure source-read events are properly applied to included content
+        return self._run_with_sphinx_processing(rel_filename, filename)
+    
+    def _run_with_sphinx_processing(self, rel_filename: str, filename: str) -> list[Node]:
+        """
+        Process the include directive using Sphinx's source processing pipeline
+        to ensure source-read events are applied to included content.
+        """
+        from docutils.io import FileInput
+        from docutils.statemachine import StringList
+        
+        # Read the included file through Sphinx's source processing pipeline
+        # This ensures that source-read events are fired and applied
+        try:
+            # Convert absolute path back to docname for Sphinx processing
+            docname = self.env.path2doc(filename)
+            if docname is None:
+                # If not a known document, fall back to direct file reading
+                return super().run()
+            
+            # Read the file content
+            source_input = FileInput(source_path=filename)
+            content = source_input.read()
+            
+            # Apply source-read event processing by temporarily setting docname
+            # and emitting the source-read event
+            old_docname = self.env.temp_data.get('docname')
+            try:
+                self.env.temp_data['docname'] = docname
+                # emit "source-read" event like SphinxStandaloneReader does
+                arg = [content]
+                self.env.events.emit('source-read', docname, arg)
+                processed_content = arg[0]
+            finally:
+                if old_docname is not None:
+                    self.env.temp_data['docname'] = old_docname
+                else:
+                    self.env.temp_data.pop('docname', None)
+            
+            # Convert processed content to StringList and insert it
+            include_lines = StringList(processed_content.splitlines(), filename)
+            self.state_machine.insert_input(include_lines, filename)
+            return []
+                
+        except Exception:
+            # If anything goes wrong, fall back to the original behavior
+            return super().run()
 
 
 def setup(app: Sphinx) -> dict[str, Any]:
