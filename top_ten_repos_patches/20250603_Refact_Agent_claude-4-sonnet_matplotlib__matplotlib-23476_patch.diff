diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py
index 9ae2982c62..0bd55dc4d0 100644
--- a/lib/matplotlib/backend_bases.py
+++ b/lib/matplotlib/backend_bases.py
@@ -1652,8 +1652,9 @@ class FigureCanvasBase:
         self.mouse_grabber = None  # the Axes currently grabbing mouse
         self.toolbar = None  # NavigationToolbar2 will set me
         self._is_idle_drawing = False
-        # We don't want to scale up the figure DPI more than once.
-        figure._original_dpi = figure.dpi
+# We don't want to scale up the figure DPI more than once.
+        if not hasattr(figure, '_original_dpi'):
+            figure._original_dpi = figure.dpi
         self._device_pixel_ratio = 1
         super().__init__()  # Typically the GUI widget init (if any).
 
diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py
index 0d0a5e5977..0cd2d9459e 100644
--- a/lib/matplotlib/tests/test_pickle.py
+++ b/lib/matplotlib/tests/test_pickle.py
@@ -237,3 +237,51 @@ def test_dynamic_norm():
 def test_vertexselector():
     line, = plt.plot([0, 1], picker=True)
     pickle.loads(pickle.dumps(VertexSelector(line)))
+
+
+def test_dpi_preservation_on_unpickle():
+    """
+    Test that figure DPI is preserved across pickle/unpickle cycles.
+    
+    This test ensures that the _original_dpi attribute is not corrupted
+    during canvas recreation, which was causing DPI doubling on MacOSX
+    backend with device pixel ratio scaling.
+    
+    See: https://github.com/matplotlib/matplotlib/issues/23476
+    """
+    # Create a figure with specific DPI
+    fig = plt.figure(dpi=100)
+    original_dpi = fig.dpi
+    
+    # Ensure _original_dpi is set correctly
+    assert hasattr(fig, '_original_dpi')
+    assert fig._original_dpi == original_dpi
+    
+    # Simulate device pixel ratio scaling (like on Retina displays)
+    device_pixel_ratio = 2.0
+    scaled_dpi = device_pixel_ratio * fig._original_dpi
+    fig._set_dpi(scaled_dpi, forward=False)
+    
+    # Verify scaling worked but _original_dpi is preserved
+    assert fig.dpi == scaled_dpi
+    assert fig._original_dpi == original_dpi
+    
+    # Test multiple pickle/unpickle cycles
+    for i in range(3):
+        # Pickle and unpickle
+        buffer = BytesIO()
+        pickle.dump(fig, buffer, pickle.HIGHEST_PROTOCOL)
+        buffer.seek(0)
+        fig = pickle.load(buffer)
+        
+        # Verify DPI and _original_dpi are preserved
+        assert fig.dpi == scaled_dpi, f"DPI changed in cycle {i+1}"
+        assert hasattr(fig, '_original_dpi'), f"_original_dpi missing in cycle {i+1}"
+        assert fig._original_dpi == original_dpi, f"_original_dpi corrupted in cycle {i+1}"
+        
+        # Simulate re-scaling (like moving window between displays)
+        new_scaled_dpi = device_pixel_ratio * fig._original_dpi
+        fig._set_dpi(new_scaled_dpi, forward=False)
+        
+        # Verify DPI didn't double
+        assert fig.dpi == scaled_dpi, f"DPI doubled in cycle {i+1}"
