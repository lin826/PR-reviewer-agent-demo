diff --git a/Dockerfile b/Dockerfile
index aafe62a6a..0b37a778d 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -1,7 +1,30 @@
-FROM python:3.9.0-alpine3.12
 
-COPY ./ /tmp/build
-WORKDIR /tmp/build
-RUN python setup.py install && rm -rf /tmp/build
+FROM swebench/sweb.eval.x86_64.pylint-dev_1776_pylint-4661:latest
 
-ENTRYPOINT ["pylint"]
+WORKDIR /install
+# Install docker cli
+# Add Docker's official GPG key:
+RUN apt-get update
+RUN apt-get install -y ca-certificates curl
+RUN install -m 0755 -d /etc/apt/keyrings
+RUN curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
+RUN chmod a+r /etc/apt/keyrings/docker.asc
+
+# Add the repository to Apt sources:
+RUN echo   "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu   $(. /etc/os-release && echo "${UBUNTU_CODENAME:-$VERSION_CODENAME}") stable" |   tee /etc/apt/sources.list.d/docker.list > /dev/null
+RUN apt-get update && apt-get install -y docker-ce-cli
+
+# Install required dependencies for SWE-bench (verification)
+RUN apt-get install -y -V ca-certificates lsb-release wget
+RUN wget https://apache.jfrog.io/artifactory/arrow/$(lsb_release --id --short | tr 'A-Z' 'a-z')/apache-arrow-apt-source-latest-$(lsb_release --codename --short).deb
+RUN apt-get update
+RUN apt-get install -y -V ./apache-arrow-apt-source-latest-$(lsb_release --codename --short).deb
+
+# Install SWE repo
+RUN git clone https://github.com/princeton-nlp/SWE-bench.git /SWE-bench
+WORKDIR /SWE-bench
+RUN apt-get install -y python3-venv
+RUN python3 -m venv .venv
+RUN . .venv/bin/activate      &&     pip install --upgrade pip &&     pip install . 
+
+WORKDIR /testbed
diff --git a/doc/faq.rst b/doc/faq.rst
index c817855f8..b6848c65a 100644
--- a/doc/faq.rst
+++ b/doc/faq.rst
@@ -93,8 +93,11 @@ localized using the following rules:
 
 * value of the PYLINTHOME environment variable if set
 
-* ".pylint.d" subdirectory of the user's home directory if it is found
-	(not always findable on Windows platforms)
+* "$XDG_DATA_HOME/pylint" (usually "~/.local/share/pylint") following the
+	XDG Base Directory Specification for new installations
+
+* ".pylint.d" subdirectory of the user's home directory if it already exists
+	(for backward compatibility)
 
 * ".pylint.d" directory in the current directory
 
diff --git a/pylint/config/__init__.py b/pylint/config/__init__.py
index 84774d0e3..2dd9620ae 100644
--- a/pylint/config/__init__.py
+++ b/pylint/config/__init__.py
@@ -63,7 +63,16 @@ if "PYLINTHOME" in os.environ:
 elif USER_HOME == "~":
     PYLINT_HOME = ".pylint.d"
 else:
-    PYLINT_HOME = os.path.join(USER_HOME, ".pylint.d")
+    # Use XDG Base Directory Specification for data storage
+    # but maintain backward compatibility with existing .pylint.d directories
+    old_pylint_home = os.path.join(USER_HOME, ".pylint.d")
+    if os.path.exists(old_pylint_home):
+        # Use existing .pylint.d directory for backward compatibility
+        PYLINT_HOME = old_pylint_home
+    else:
+        # Use XDG data directory for new installations
+        xdg_data_home = os.environ.get('XDG_DATA_HOME', os.path.join(USER_HOME, '.local', 'share'))
+        PYLINT_HOME = os.path.join(xdg_data_home, 'pylint')
 
 
 def _get_pdata_path(base_name, recurs):
@@ -83,7 +92,7 @@ def load_results(base):
 def save_results(results, base):
     if not os.path.exists(PYLINT_HOME):
         try:
-            os.mkdir(PYLINT_HOME)
+            os.makedirs(PYLINT_HOME, exist_ok=True)
         except OSError:
             print("Unable to create directory %s" % PYLINT_HOME, file=sys.stderr)
     data_file = _get_pdata_path(base, 1)
@@ -110,8 +119,9 @@ ENV_HELP = (
 The following environment variables are used:
     * PYLINTHOME
     Path to the directory where persistent data for the run will be stored. If
-not found, it defaults to ~/.pylint.d/ or .pylint.d (in the current working
-directory).
+not found, it defaults to $XDG_DATA_HOME/pylint (usually ~/.local/share/pylint)
+or ~/.pylint.d/ if that directory already exists, or .pylint.d (in the current
+working directory).
     * PYLINTRC
     Path to the configuration file. See the documentation for the method used
 to search for configuration file.
diff --git a/tests/lint/unittest_lint.py b/tests/lint/unittest_lint.py
index 004c29281..49d3d8f80 100644
--- a/tests/lint/unittest_lint.py
+++ b/tests/lint/unittest_lint.py
@@ -631,7 +631,14 @@ def test_pylint_home():
     if uhome == "~":
         expected = ".pylint.d"
     else:
-        expected = os.path.join(uhome, ".pylint.d")
+        # Check if old .pylint.d exists for backward compatibility
+        old_pylint_home = os.path.join(uhome, ".pylint.d")
+        if os.path.exists(old_pylint_home):
+            expected = old_pylint_home
+        else:
+            # Use XDG data directory for new installations
+            xdg_data_home = os.environ.get('XDG_DATA_HOME', os.path.join(uhome, '.local', 'share'))
+            expected = os.path.join(xdg_data_home, 'pylint')
     assert config.PYLINT_HOME == expected
 
     try:
@@ -649,6 +656,94 @@ def test_pylint_home():
         del os.environ["PYLINTHOME"]
 
 
+@pytest.mark.usefixtures("pop_pylintrc")
+def test_pylint_home_xdg_compliance():
+    """Test that pylint follows XDG Base Directory Specification for new installations"""
+    import tempfile
+    import shutil
+    
+    with tempfile.TemporaryDirectory() as temp_home:
+        # Save original environment
+        old_home = os.environ.get('HOME')
+        old_xdg_data_home = os.environ.get('XDG_DATA_HOME')
+        old_pylinthome = os.environ.get('PYLINTHOME')
+        
+        try:
+            # Set up clean environment (no existing .pylint.d)
+            os.environ['HOME'] = temp_home
+            if 'XDG_DATA_HOME' in os.environ:
+                del os.environ['XDG_DATA_HOME']
+            if 'PYLINTHOME' in os.environ:
+                del os.environ['PYLINTHOME']
+            
+            # Reload config
+            reload(config)
+            
+            # Should use XDG data directory
+            expected = os.path.join(temp_home, '.local', 'share', 'pylint')
+            assert config.PYLINT_HOME == expected
+            
+            # Test with custom XDG_DATA_HOME
+            custom_data_home = os.path.join(temp_home, 'custom_data')
+            os.environ['XDG_DATA_HOME'] = custom_data_home
+            reload(config)
+            
+            expected = os.path.join(custom_data_home, 'pylint')
+            assert config.PYLINT_HOME == expected
+            
+        finally:
+            # Restore environment
+            if old_home:
+                os.environ['HOME'] = old_home
+            elif 'HOME' in os.environ:
+                del os.environ['HOME']
+            
+            if old_xdg_data_home:
+                os.environ['XDG_DATA_HOME'] = old_xdg_data_home
+            elif 'XDG_DATA_HOME' in os.environ:
+                del os.environ['XDG_DATA_HOME']
+            
+            if old_pylinthome:
+                os.environ['PYLINTHOME'] = old_pylinthome
+
+
+@pytest.mark.usefixtures("pop_pylintrc")
+def test_pylint_home_backward_compatibility():
+    """Test backward compatibility with existing .pylint.d directories"""
+    import tempfile
+    
+    with tempfile.TemporaryDirectory() as temp_home:
+        # Save original environment
+        old_home = os.environ.get('HOME')
+        old_pylinthome = os.environ.get('PYLINTHOME')
+        
+        try:
+            # Set up environment with existing .pylint.d
+            os.environ['HOME'] = temp_home
+            if 'PYLINTHOME' in os.environ:
+                del os.environ['PYLINTHOME']
+            
+            # Create existing .pylint.d directory
+            old_pylint_dir = os.path.join(temp_home, '.pylint.d')
+            os.makedirs(old_pylint_dir)
+            
+            # Reload config
+            reload(config)
+            
+            # Should use existing .pylint.d for backward compatibility
+            assert config.PYLINT_HOME == old_pylint_dir
+            
+        finally:
+            # Restore environment
+            if old_home:
+                os.environ['HOME'] = old_home
+            elif 'HOME' in os.environ:
+                del os.environ['HOME']
+            
+            if old_pylinthome:
+                os.environ['PYLINTHOME'] = old_pylinthome
+
+
 @pytest.mark.usefixtures("pop_pylintrc")
 def test_pylintrc():
     with fake_home():
