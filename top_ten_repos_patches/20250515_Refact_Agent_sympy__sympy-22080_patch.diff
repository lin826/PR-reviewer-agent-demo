diff --git a/sympy/printing/pycode.py b/sympy/printing/pycode.py
index b669a2c783..997a51fa81 100644
--- a/sympy/printing/pycode.py
+++ b/sympy/printing/pycode.py
@@ -435,6 +435,54 @@ def _print_sign(self, e):
     def _print_Not(self, expr):
         PREC = precedence(expr)
         return self._operators['not'] + self.parenthesize(expr.args[0], PREC)
+        
+    def _needs_mul_parentheses(self, expr):
+        """
+        Return True if *expr* must be wrapped in parentheses when it is
+        emitted as part of a product in plain Python code, to keep the
+        numerical meaning unchanged.
+        """
+        from sympy.core.mod import Mod
+        # every explicit Mod, floor-division or bitwise op needs parens
+        if isinstance(expr, Mod):
+            return True
+        # fallback: look at already-printed form for dangerous tokens
+        code = self._print(expr)
+        return '%' in code or '//' in code or '&' in code or '|' in code \
+               or '^' in code or '<<' in code or '>>' in code
+        
+    def _print_Mul(self, expr):
+        """
+        Same algorithm as the base class but guarantees that a factor which
+        contains operators of the same precedence as '*' (notably '%', '//',
+        bit-wise ops) is surrounded by parentheses.
+        """
+        # original part (sign handling, separation into numerator/denominator)
+        sign = '-' if expr.could_extract_minus_sign() else ''
+        if sign:
+            expr = -expr
+        num, den = [], []
+        for arg in (expr.as_ordered_factors()
+                    if self.order not in ('old', 'none')
+                    else expr.args):
+            if arg.is_commutative and arg.is_Pow and arg.exp.is_Rational and arg.exp.is_negative:
+                den.append(-arg.exp if arg.exp != -1 else arg.base)
+            else:
+                num.append(arg)
+
+        def print_factor(a):
+            s = self._print(a)
+            if self._needs_mul_parentheses(a):
+                s = '(' + s + ')'
+            return s
+
+        n_code = '*'.join(print_factor(a) for a in num) or '1'
+        if not den:
+            return sign + n_code
+        d_code = '*'.join(print_factor(a) for a in den)
+        if len(den) == 1:
+            return f"{sign}{n_code}/{d_code}"
+        return f"{sign}{n_code}/({d_code})"
 
     def _print_Indexed(self, expr):
         base = expr.args[0]
