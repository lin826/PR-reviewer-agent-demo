diff --git a/django/db/models/query.py b/django/db/models/query.py
index d9c9b0db04..8632a5e7b0 100644
--- a/django/db/models/query.py
+++ b/django/db/models/query.py
@@ -16,6 +16,7 @@ from django.db import (
     router, transaction,
 )
 from django.db.models import AutoField, DateField, DateTimeField, sql
+from django.db.models.constraints import UniqueConstraint
 from django.db.models.constants import LOOKUP_SEP
 from django.db.models.deletion import Collector
 from django.db.models.expressions import Case, Expression, F, Value, When
@@ -682,6 +683,25 @@ class QuerySet:
         for obj in (self.reverse() if self.ordered else self.order_by('-pk'))[:1]:
             return obj
 
+    def _is_field_unique(self, field_name):
+        """
+        Check if a field is unique either through field.unique=True or through
+        a single-field UniqueConstraint without conditions.
+        """
+        # Check if field has unique=True
+        field = self.model._meta.get_field(field_name)
+        if field.unique:
+            return True
+        
+        # Check if field is covered by a single-field UniqueConstraint without conditions
+        for constraint in self.model._meta.total_unique_constraints:
+            if (len(constraint.fields) == 1 and 
+                constraint.fields[0] == field_name and 
+                constraint.condition is None):
+                return True
+        
+        return False
+
     def in_bulk(self, id_list=None, *, field_name='pk'):
         """
         Return a dictionary mapping each of the given IDs to the object with
@@ -689,7 +709,7 @@ class QuerySet:
         """
         assert not self.query.is_sliced, \
             "Cannot use 'limit' or 'offset' with in_bulk"
-        if field_name != 'pk' and not self.model._meta.get_field(field_name).unique:
+        if field_name != 'pk' and not self._is_field_unique(field_name):
             raise ValueError("in_bulk()'s field_name must be a unique field but %r isn't." % field_name)
         if id_list is not None:
             if not id_list:
diff --git a/tests/lookup/models.py b/tests/lookup/models.py
index fbc9fa606f..6921d0a37d 100644
--- a/tests/lookup/models.py
+++ b/tests/lookup/models.py
@@ -108,3 +108,14 @@ class Freebie(models.Model):
         to_fields=['id', 'product'],
         on_delete=models.CASCADE,
     )
+
+
+class UniqueConstraintArticle(models.Model):
+    """Model to test in_bulk() with UniqueConstraint instead of unique=True."""
+    headline = models.CharField(max_length=100)
+    slug = models.CharField(max_length=100)  # Not unique=True, but has UniqueConstraint
+    
+    class Meta:
+        constraints = [
+            models.UniqueConstraint(fields=['slug'], name='lookup_uniqueconstraintarticle_slug_unq')
+        ]
diff --git a/tests/lookup/tests.py b/tests/lookup/tests.py
index baefdf9701..708dccd703 100644
--- a/tests/lookup/tests.py
+++ b/tests/lookup/tests.py
@@ -12,6 +12,7 @@ from django.utils.deprecation import RemovedInDjango40Warning
 
 from .models import (
     Article, Author, Freebie, Game, IsNullWithNoneAsRHS, Player, Season, Tag,
+    UniqueConstraintArticle,
 )
 
 
@@ -194,6 +195,32 @@ class LookupTests(TestCase):
         with self.assertRaisesMessage(ValueError, msg):
             Article.objects.in_bulk([self.au1], field_name='author')
 
+    def test_in_bulk_with_unique_constraint(self):
+        """Test that in_bulk() works with fields that have UniqueConstraint."""
+        # Create test objects with UniqueConstraint
+        uca1 = UniqueConstraintArticle.objects.create(headline='UCA 1', slug='uca1')
+        uca2 = UniqueConstraintArticle.objects.create(headline='UCA 2', slug='uca2')
+        uca3 = UniqueConstraintArticle.objects.create(headline='UCA 3', slug='uca3')
+        
+        # Test in_bulk with specific slugs
+        result = UniqueConstraintArticle.objects.in_bulk(
+            [uca1.slug, uca3.slug], field_name='slug'
+        )
+        expected = {uca1.slug: uca1, uca3.slug: uca3}
+        self.assertEqual(result, expected)
+        
+        # Test in_bulk with all objects
+        result = UniqueConstraintArticle.objects.in_bulk(field_name='slug')
+        expected = {uca1.slug: uca1, uca2.slug: uca2, uca3.slug: uca3}
+        self.assertEqual(result, expected)
+        
+        # Test with non-existent slugs
+        result = UniqueConstraintArticle.objects.in_bulk(
+            ['non-existent', uca2.slug], field_name='slug'
+        )
+        expected = {uca2.slug: uca2}
+        self.assertEqual(result, expected)
+
     def test_values(self):
         # values() returns a list of dictionaries instead of object instances --
         # and you can specify which fields you want to retrieve.
