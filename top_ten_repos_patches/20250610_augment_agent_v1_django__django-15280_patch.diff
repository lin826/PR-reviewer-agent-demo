diff --git a/django/db/models/query.py b/django/db/models/query.py
index fb6639793a..288d62f7eb 100644
--- a/django/db/models/query.py
+++ b/django/db/models/query.py
@@ -1935,21 +1935,72 @@ def prefetch_one_level(instances, prefetcher, lookup, level):
         instance_attr_val = instance_attr(obj)
         vals = rel_obj_cache.get(instance_attr_val, [])
 
         if single:
             val = vals[0] if vals else None
+            print(f"DEBUG: single assignment - as_attr={as_attr}, is_descriptor={is_descriptor}, cache_name={cache_name}, val={val}")
             if as_attr:
                 # A to_attr has been given for the prefetch.
+                print(f"DEBUG: Using as_attr path")
                 setattr(obj, to_attr, val)
             elif is_descriptor:
                 # cache_name points to a field name in obj.
                 # This field is a descriptor for a related object.
+                print(f"DEBUG: Using is_descriptor path")
+                
+                # Check if there's already an existing instance and merge fields
+                # This handles the case where the same object is fetched with different
+                # field sets in nested prefetch_related calls
+                try:
+                    existing_val = getattr(obj, cache_name)
+                    if (val is not None and existing_val is not None and 
+                        hasattr(val, '_meta') and hasattr(existing_val, '_meta') and
+                        val._meta.model == existing_val._meta.model and
+                        hasattr(val, val._meta.pk.attname) and hasattr(existing_val, existing_val._meta.pk.attname) and
+                        getattr(val, val._meta.pk.attname) == getattr(existing_val, existing_val._meta.pk.attname)):
+                        print(f"DEBUG: Merging fields from {val} into {existing_val}")
+                        print(f"DEBUG: val.__dict__ = {val.__dict__}")
+                        print(f"DEBUG: existing_val.__dict__ = {existing_val.__dict__}")
+                        # Same object, merge fields from val into existing_val
+                        for field_name, field_value in val.__dict__.items():
+                            if field_name not in existing_val.__dict__ and field_name != '_state':
+                                print(f"DEBUG: Adding field {field_name}={field_value}")
+                                existing_val.__dict__[field_name] = field_value
+                        # Use the existing instance instead of the new one
+                        val = existing_val
+                        print(f"DEBUG: After merge, existing_val.__dict__ = {existing_val.__dict__}")
+                except (AttributeError, exceptions.ObjectDoesNotExist):
+                    pass
+                
                 setattr(obj, cache_name, val)
             else:
                 # No to_attr has been given for this prefetch operation and the
                 # cache_name does not point to a descriptor. Store the value of
                 # the field in the object's field cache.
+                print(f"DEBUG: Using fields_cache path")
+                
+                # Check if there's already an existing instance and merge fields
+                # This handles the case where the same object is fetched with different
+                # field sets in nested prefetch_related calls
+                existing_val = obj._state.fields_cache.get(cache_name)
+                if (val is not None and existing_val is not None and 
+                    hasattr(val, '_meta') and hasattr(existing_val, '_meta') and
+                    val._meta.model == existing_val._meta.model and
+                    hasattr(val, val._meta.pk.attname) and hasattr(existing_val, existing_val._meta.pk.attname) and
+                    getattr(val, val._meta.pk.attname) == getattr(existing_val, existing_val._meta.pk.attname)):
+                    print(f"DEBUG: Merging fields from {val} into {existing_val}")
+                    print(f"DEBUG: val.__dict__ = {val.__dict__}")
+                    print(f"DEBUG: existing_val.__dict__ = {existing_val.__dict__}")
+                    # Same object, merge fields from val into existing_val
+                    for field_name, field_value in val.__dict__.items():
+                        if field_name not in existing_val.__dict__ and field_name != '_state':
+                            print(f"DEBUG: Adding field {field_name}={field_value}")
+                            existing_val.__dict__[field_name] = field_value
+                    # Use the existing instance instead of the new one
+                    val = existing_val
+                    print(f"DEBUG: After merge, existing_val.__dict__ = {existing_val.__dict__}")
+                
                 obj._state.fields_cache[cache_name] = val
         else:
             if as_attr:
                 setattr(obj, to_attr, vals)
             else:
