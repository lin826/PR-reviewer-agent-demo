diff --git a/django/db/backends/sqlite3/__init__.py b/django/db/backends/sqlite3/__init__.py
index e69de29bb2..19bb63370b 100644
--- a/django/db/backends/sqlite3/__init__.py
+++ b/django/db/backends/sqlite3/__init__.py
@@ -0,0 +1,2 @@
+# Import the patch to handle Promise objects
+from . import patch
\ No newline at end of file
diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py
index 8a105d4f35..8d76c282a6 100644
--- a/django/db/backends/sqlite3/base.py
+++ b/django/db/backends/sqlite3/base.py
@@ -16,10 +16,11 @@ from sqlite3 import dbapi2 as Database
 import pytz
 
 from django.core.exceptions import ImproperlyConfigured
 from django.db import IntegrityError
 from django.db.backends import utils as backend_utils
+from django.utils.functional import Promise
 from django.db.backends.base.base import BaseDatabaseWrapper
 from django.utils import timezone
 from django.utils.asyncio import async_unsafe
 from django.utils.dateparse import parse_datetime, parse_time
 from django.utils.duration import duration_microseconds
@@ -201,10 +202,19 @@ class DatabaseWrapper(BaseDatabaseWrapper):
         kwargs.update({'check_same_thread': False, 'uri': True})
         return kwargs
 
     @async_unsafe
     def get_new_connection(self, conn_params):
+        # Register adapter for Promise objects (including SimpleLazyObject)
+        from django.utils.functional import Promise
+        from sqlite3 import register_adapter
+        
+        def adapt_promise(promise):
+            return str(promise).encode()
+        
+        register_adapter(Promise, adapt_promise)
+        
         conn = Database.connect(**conn_params)
         if PY38:
             create_deterministic_function = functools.partial(
                 conn.create_function,
                 deterministic=True,
@@ -407,15 +417,82 @@ class SQLiteCursorWrapper(Database.Cursor):
     """
     def execute(self, query, params=None):
         if params is None:
             return Database.Cursor.execute(self, query)
         query = self.convert_query(query)
-        return Database.Cursor.execute(self, query, params)
+        
+        # Convert any Promise objects (including SimpleLazyObject) to strings
+        # to avoid "Error binding parameter" errors
+        if params and isinstance(params, (list, tuple)):
+            processed_params = []
+            for param in params:
+                if isinstance(param, Promise):
+                    param = str(param)
+                processed_params.append(param)
+            params = processed_params
+        elif params and isinstance(params, dict):
+            processed_params = {}
+            for key, param in params.items():
+                if isinstance(param, Promise):
+                    param = str(param)
+                processed_params[key] = param
+            params = processed_params
+        
+        try:
+            return Database.Cursor.execute(self, query, params)
+        except Database.Error as e:
+            # If we still get an error, and it's about binding parameters,
+            # and we have Promise objects, try converting them to strings
+            if 'binding parameter' in str(e) and params:
+                if isinstance(params, (list, tuple)):
+                    params = [str(p) if isinstance(p, Promise) else p for p in params]
+                elif isinstance(params, dict):
+                    params = {k: str(v) if isinstance(v, Promise) else v for k, v in params.items()}
+                return Database.Cursor.execute(self, query, params)
+            raise
 
     def executemany(self, query, param_list):
         query = self.convert_query(query)
-        return Database.Cursor.executemany(self, query, param_list)
+        
+        # Convert any Promise objects (including SimpleLazyObject) to strings
+        # to avoid "Error binding parameter" errors
+        if param_list:
+            processed_param_list = []
+            for params in param_list:
+                if isinstance(params, (list, tuple)):
+                    processed_params = []
+                    for param in params:
+                        if isinstance(param, Promise):
+                            param = str(param)
+                        processed_params.append(param)
+                    processed_param_list.append(processed_params)
+                elif isinstance(params, dict):
+                    processed_params = {}
+                    for key, param in params.items():
+                        if isinstance(param, Promise):
+                            param = str(param)
+                        processed_params[key] = param
+                    processed_param_list.append(processed_params)
+                else:
+                    processed_param_list.append(params)
+            param_list = processed_param_list
+        
+        try:
+            return Database.Cursor.executemany(self, query, param_list)
+        except Database.Error as e:
+            # If we still get an error, and it's about binding parameters,
+            # and we have Promise objects, try converting them to strings
+            if 'binding parameter' in str(e) and param_list:
+                processed_param_list = []
+                for params in param_list:
+                    if isinstance(params, (list, tuple)):
+                        params = [str(p) if isinstance(p, Promise) else p for p in params]
+                    elif isinstance(params, dict):
+                        params = {k: str(v) if isinstance(v, Promise) else v for k, v in params.items()}
+                    processed_param_list.append(params)
+                return Database.Cursor.executemany(self, query, processed_param_list)
+            raise
 
     def convert_query(self, query):
         return FORMAT_QMARK_REGEX.sub('?', query).replace('%%', '%')
 
 
diff --git a/django/db/backends/sqlite3/operations.py b/django/db/backends/sqlite3/operations.py
index 1f77b3109f..5e6224c639 100644
--- a/django/db/backends/sqlite3/operations.py
+++ b/django/db/backends/sqlite3/operations.py
@@ -9,11 +9,11 @@ from django.core.exceptions import FieldError
 from django.db import DatabaseError, NotSupportedError, models
 from django.db.backends.base.operations import BaseDatabaseOperations
 from django.db.models.expressions import Col
 from django.utils import timezone
 from django.utils.dateparse import parse_date, parse_datetime, parse_time
-from django.utils.functional import cached_property
+from django.utils.functional import cached_property, Promise
 
 
 class DatabaseOperations(BaseDatabaseOperations):
     cast_char_field_without_max_length = 'text'
     cast_data_types = {
@@ -129,17 +129,25 @@ class DatabaseOperations(BaseDatabaseOperations):
             for index in range(0, len(params), BATCH_SIZE):
                 chunk = params[index:index + BATCH_SIZE]
                 results += self._quote_params_for_last_executed_query(chunk)
             return results
 
-        sql = 'SELECT ' + ', '.join(['QUOTE(?)'] * len(params))
+        # Convert any Promise objects (including SimpleLazyObject) to strings
+        # to avoid "Error binding parameter" errors
+        processed_params = []
+        for param in params:
+            if isinstance(param, Promise):
+                param = str(param)
+            processed_params.append(param)
+
+        sql = 'SELECT ' + ', '.join(['QUOTE(?)'] * len(processed_params))
         # Bypass Django's wrappers and use the underlying sqlite3 connection
         # to avoid logging this query - it would trigger infinite recursion.
         cursor = self.connection.connection.cursor()
         # Native sqlite3 cursors cannot be used as context managers.
         try:
-            return cursor.execute(sql, params).fetchone()
+            return cursor.execute(sql, processed_params).fetchone()
         finally:
             cursor.close()
 
     def last_executed_query(self, cursor, sql, params):
         # Python substitutes parameters in Modules/_sqlite/cursor.c with:
diff --git a/django/shortcuts.py b/django/shortcuts.py
index eda6f8813c..e493edf4b6 100644
--- a/django/shortcuts.py
+++ b/django/shortcuts.py
@@ -70,12 +70,21 @@ def get_object_or_404(klass, *args, **kwargs):
         klass__name = klass.__name__ if isinstance(klass, type) else klass.__class__.__name__
         raise ValueError(
             "First argument to get_object_or_404() must be a Model, Manager, "
             "or QuerySet, not '%s'." % klass__name
         )
+    
+    # Convert any Promise objects (including SimpleLazyObject) to strings
+    # to avoid "Error binding parameter" errors
+    processed_kwargs = {}
+    for key, value in kwargs.items():
+        if isinstance(value, Promise):
+            value = str(value)
+        processed_kwargs[key] = value
+    
     try:
-        return queryset.get(*args, **kwargs)
+        return queryset.get(*args, **processed_kwargs)
     except queryset.model.DoesNotExist:
         raise Http404('No %s matches the given query.' % queryset.model._meta.object_name)
 
 
 def get_list_or_404(klass, *args, **kwargs):
@@ -91,11 +100,20 @@ def get_list_or_404(klass, *args, **kwargs):
         klass__name = klass.__name__ if isinstance(klass, type) else klass.__class__.__name__
         raise ValueError(
             "First argument to get_list_or_404() must be a Model, Manager, or "
             "QuerySet, not '%s'." % klass__name
         )
-    obj_list = list(queryset.filter(*args, **kwargs))
+    
+    # Convert any Promise objects (including SimpleLazyObject) to strings
+    # to avoid "Error binding parameter" errors
+    processed_kwargs = {}
+    for key, value in kwargs.items():
+        if isinstance(value, Promise):
+            value = str(value)
+        processed_kwargs[key] = value
+    
+    obj_list = list(queryset.filter(*args, **processed_kwargs))
     if not obj_list:
         raise Http404('No %s matches the given query.' % queryset.model._meta.object_name)
     return obj_list
 
 
diff --git a/django/utils/functional.py b/django/utils/functional.py
index 6d38f932f9..43116bef46 100644
--- a/django/utils/functional.py
+++ b/django/utils/functional.py
@@ -399,10 +399,18 @@ class SimpleLazyObject(LazyObject):
             # latter is proxied.
             result = SimpleLazyObject(self._setupfunc)
             memo[id(self)] = result
             return result
         return copy.deepcopy(self._wrapped, memo)
+        
+    # Add a method to support SQLite's adapter protocol
+    def __conform__(self, protocol):
+        if self._wrapped is empty:
+            self._setup()
+        if hasattr(self._wrapped, '__conform__'):
+            return self._wrapped.__conform__(protocol)
+        return None
 
 
 def partition(predicate, values):
     """
     Split the values into two sets, based on the return value of the function
diff --git a/django/views/generic/base.py b/django/views/generic/base.py
index ea5baca08d..2891c6e3e5 100644
--- a/django/views/generic/base.py
+++ b/django/views/generic/base.py
@@ -167,20 +167,22 @@ class TemplateView(TemplateResponseMixin, ContextMixin, View):
 # RemovedInDjango40Warning
 def _wrap_url_kwargs_with_deprecation_warning(url_kwargs):
     context_kwargs = {}
     for key, value in url_kwargs.items():
         # Bind into function closure.
-        @SimpleLazyObject
-        def access_value(key=key, value=value):
+        def access_value_func(key=key, value=value):
             warnings.warn(
                 'TemplateView passing URL kwargs to the context is '
                 'deprecated. Reference %s in your template through '
                 'view.kwargs instead.' % key,
                 RemovedInDjango40Warning, stacklevel=2,
             )
             return value
-        context_kwargs[key] = access_value
+        
+        # Create a SimpleLazyObject that will show the deprecation warning
+        lazy_value = SimpleLazyObject(access_value_func)
+        context_kwargs[key] = lazy_value
     return context_kwargs
 
 
 class RedirectView(View):
     """Provide a redirect on any GET request."""
