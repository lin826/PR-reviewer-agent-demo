diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py
index fafc1beee8..71d7ff9d19 100644
--- a/django/db/models/fields/json.py
+++ b/django/db/models/fields/json.py
@@ -3,11 +3,13 @@ import json
 from django import forms
 from django.core import checks, exceptions
 from django.db import NotSupportedError, connections, router
 from django.db.models import lookups
 from django.db.models.lookups import PostgresOperatorLookup, Transform
+from django.utils.datastructures import OrderedSet
 from django.utils.translation import gettext_lazy as _
+from django.core.exceptions import EmptyResultSet
 
 from . import Field
 from .mixins import CheckFieldDefaultMixin
 
 __all__ = ['JSONField']
@@ -477,10 +479,58 @@ class KeyTransformGt(KeyTransformNumericLookupMixin, lookups.GreaterThan):
 
 class KeyTransformGte(KeyTransformNumericLookupMixin, lookups.GreaterThanOrEqual):
     pass
 
 
+class KeyTransformIn(lookups.In):
+    def process_rhs(self, compiler, connection):
+        if isinstance(self.rhs, KeyTransform):
+            return super().process_rhs(compiler, connection)
+        
+        if not self.rhs_is_direct_value():
+            return super().process_rhs(compiler, connection)
+            
+        # Remove None from the list as NULL is never equal to anything.
+        try:
+            rhs = OrderedSet(self.rhs)
+            rhs.discard(None)
+        except TypeError:  # Unhashable items in self.rhs
+            rhs = [r for r in self.rhs if r is not None]
+
+        if not rhs:
+            raise EmptyResultSet
+
+        # Process the right-hand side values
+        if connection.vendor == 'mysql':
+            # For MySQL, wrap each value in JSON_EXTRACT
+            sqls, sqls_params = self.batch_process_rhs(compiler, connection, rhs)
+            sqls = [f"JSON_EXTRACT(%s, '$')" for _ in sqls]
+            placeholder = '(' + ', '.join(sqls) + ')'
+            return placeholder, sqls_params
+        elif connection.vendor == 'oracle':
+            # For Oracle, use JSON_QUERY or JSON_VALUE depending on the type
+            sqls, sqls_params = [], []
+            for value in rhs:
+                value_json = json.dumps(value)
+                function = 'JSON_QUERY' if isinstance(value, (list, dict)) else 'JSON_VALUE'
+                sqls.append("%s('%s', '$.value')" % (
+                    function,
+                    json.dumps({'value': value}),
+                ))
+            placeholder = '(' + ', '.join(sqls) + ')'
+            return placeholder, []
+        elif connection.vendor == 'sqlite':
+            # For SQLite, use JSON_EXTRACT for each value
+            sqls, sqls_params = self.batch_process_rhs(compiler, connection, rhs)
+            sqls = [f"JSON_EXTRACT(%s, '$')" for _ in sqls]
+            placeholder = '(' + ', '.join(sqls) + ')'
+            return placeholder, sqls_params
+        else:
+            # For other databases, use the default implementation
+            return super().process_rhs(compiler, connection)
+
+
 KeyTransform.register_lookup(KeyTransformExact)
 KeyTransform.register_lookup(KeyTransformIExact)
 KeyTransform.register_lookup(KeyTransformIsNull)
 KeyTransform.register_lookup(KeyTransformIContains)
 KeyTransform.register_lookup(KeyTransformStartsWith)
@@ -492,10 +542,11 @@ KeyTransform.register_lookup(KeyTransformIRegex)
 
 KeyTransform.register_lookup(KeyTransformLt)
 KeyTransform.register_lookup(KeyTransformLte)
 KeyTransform.register_lookup(KeyTransformGt)
 KeyTransform.register_lookup(KeyTransformGte)
+KeyTransform.register_lookup(KeyTransformIn)
 
 
 class KeyTransformFactory:
 
     def __init__(self, key_name):
