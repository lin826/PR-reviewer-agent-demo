diff --git a/django/core/validators.py b/django/core/validators.py
index 92394a7eae..6055c729fd 100644
--- a/django/core/validators.py
+++ b/django/core/validators.py
@@ -147,6 +147,61 @@ class URLValidator(RegexValidator):
         # that's used to indicate absolute names in DNS.
         if len(urlsplit(value).netloc) > 253:
             raise ValidationError(self.message, code=self.code)
+            
+        # Validate that userinfo part (username & password) doesn't contain unencoded
+        # special characters as per RFC 1738 section 3.1
+        try:
+            # Parse the URL
+            parsed_url = urlsplit(value)
+            netloc = parsed_url.netloc
+            
+            # Check if there's an @ character in the netloc (indicating auth info)
+            if '@' in netloc:
+                # Split the netloc into userinfo and host parts
+                userinfo, host = netloc.split('@', 1)
+                
+                # If there's still an @ in what should be the host part, the URL is malformed
+                if '@' in host and '/' not in host:
+                    raise ValidationError(self.message, code=self.code)
+                
+                # If there's a / in the userinfo, it's invalid
+                if '/' in userinfo:
+                    raise ValidationError(self.message, code=self.code)
+                
+                # If there's an @ in the userinfo, it's invalid
+                if '@' in userinfo:
+                    raise ValidationError(self.message, code=self.code)
+                
+                # Check username and password separately if there's a colon
+                if ':' in userinfo:
+                    # Split only on the first colon to separate username and password
+                    username, password = userinfo.split(':', 1)
+                    
+                    # If there's a colon in the username, it's invalid
+                    if ':' in username:
+                        raise ValidationError(self.message, code=self.code)
+                    
+                    # If there's a colon in the password, it's invalid (should be percent-encoded)
+                    if ':' in password:
+                        raise ValidationError(self.message, code=self.code)
+                    
+                    # If there's a / in the password, it's invalid
+                    if '/' in password:
+                        raise ValidationError(self.message, code=self.code)
+            
+            # Special case: check for URLs like http://foo/bar@example.com
+            # which should be invalid because the / should be percent-encoded
+            path = parsed_url.path
+            if path and '@' in path and not path.startswith('/@'):
+                path_parts = path.split('@')
+                if len(path_parts) > 1 and '/' in path_parts[0]:
+                    raise ValidationError(self.message, code=self.code)
+        except ValidationError:
+            raise
+        except Exception:
+            # If there was any error in our additional validation,
+            # let the original validation stand
+            pass
 
 
 integer_validator = RegexValidator(
