diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py
index ec70dcc..cb9535e 100644
--- a/src/_pytest/assertion/rewrite.py
+++ b/src/_pytest/assertion/rewrite.py
@@ -354,8 +354,11 @@ def _rewrite_test(fn: Path, config: Config) -> Tuple[os.stat_result, types.CodeT
     with open(fn_, "rb") as f:
         source = f.read()
     tree = ast.parse(source, filename=fn_)
+
     rewrite_asserts(tree, source, fn_, config)
+    tree = _replace_literal_names(tree)
     co = compile(tree, fn_, "exec", dont_inherit=True)
+
     return stat, co
 
 
@@ -439,12 +442,42 @@ def _format_assertmsg(obj: object) -> str:
         obj = saferepr(obj)
         replaces.append(("\\n", "\n~"))
 
+
     for r1, r2 in replaces:
         obj = obj.replace(r1, r2)
 
     return obj
 
 
+def _replace_literal_names(tree: ast.AST) -> ast.AST:
+    """Replace Name nodes that refer to the built‑in singletons True, False or
+    None with the corresponding Constant/NameConstant nodes.
+
+    This sanitisation avoids hitting debug‑build assertions inside the CPython
+    compiler that disallow these identifiers from being treated as regular
+    variables.
+    """
+    class _LiteralNameReplacer(ast.NodeTransformer):
+        """AST transformer that performs the literal replacement."""
+
+        def visit_Name(self, node: ast.Name):  # type: ignore[override]
+            # Only transform simple loads of the singleton names.
+            if isinstance(node.ctx, ast.Load) and node.id in {"True", "False", "None"}:
+                value = {"True": True, "False": False, "None": None}[node.id]
+                if hasattr(ast, "Constant"):
+                    new_node = ast.Constant(value=value, kind=None)  # type: ignore[arg-type]
+                else:
+                    new_node = ast.NameConstant(value)  # type: ignore[arg-type]
+                return ast.copy_location(new_node, node)
+            return node
+
+    transformer = _LiteralNameReplacer()
+    new_tree = transformer.visit(tree)
+    ast.fix_missing_locations(new_tree)
+    return new_tree
+
+
+
 def _should_repr_global_name(obj: object) -> bool:
     if callable(obj):
         return False
