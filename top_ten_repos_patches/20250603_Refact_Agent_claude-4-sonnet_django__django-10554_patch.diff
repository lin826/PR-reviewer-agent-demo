diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index 08d7faf194..1da46f219c 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -328,6 +328,9 @@ class Query(BaseExpression):
             obj.subq_aliases = self.subq_aliases.copy()
         obj.used_aliases = self.used_aliases.copy()
         obj._filtered_relations = self._filtered_relations.copy()
+        # Clone combined_queries to avoid shared state between union querysets
+        if self.combined_queries:
+            obj.combined_queries = tuple(query.clone() for query in self.combined_queries)
         # Clear the cached_property
         try:
             del obj.base_table
diff --git a/tests/queries/test_qs_combinators.py b/tests/queries/test_qs_combinators.py
index 227972e8c4..cc8211175b 100644
--- a/tests/queries/test_qs_combinators.py
+++ b/tests/queries/test_qs_combinators.py
@@ -228,3 +228,45 @@ class QuerySetSetOperationTests(TestCase):
         qs1 = Number.objects.all()
         qs2 = Number.objects.intersection(Number.objects.filter(num__gt=1))
         self.assertEqual(qs1.difference(qs2).count(), 2)
+
+    def test_union_with_ordering_and_derived_queryset(self):
+        """
+        Test that creating derived querysets from union querysets with ordering
+        doesn't break the original queryset due to shared state.
+        Regression test for issue where ORDER BY position X is not in select list.
+        """
+        # Create a union queryset with ordering
+        qs1 = Number.objects.filter(num__lte=1)
+        qs2 = Number.objects.filter(num__gte=8)
+        union_qs = qs1.union(qs2).order_by('num')
+        
+        # First evaluation should work
+        original_result = list(union_qs)
+        
+        # Create a derived queryset with different select list
+        derived_qs = union_qs.order_by().values_list('pk', flat=True)
+        derived_result = list(derived_qs)
+        
+        # Re-evaluate the original queryset - this should still work
+        # (previously this would fail with "ORDER BY position X is not in select list")
+        re_evaluated_result = list(union_qs)
+        
+        # Verify results are consistent
+        self.assertEqual(original_result, re_evaluated_result)
+        self.assertEqual(len(derived_result), len(original_result))
+        
+        # Verify that the combined_queries are not shared between querysets
+        self.assertIsNot(
+            union_qs.query.combined_queries,
+            derived_qs.query.combined_queries,
+            "Combined queries should not be shared between original and derived querysets"
+        )
+        
+        # Verify that individual queries in combined_queries are not shared
+        for i, (orig_query, derived_query) in enumerate(
+            zip(union_qs.query.combined_queries, derived_qs.query.combined_queries)
+        ):
+            self.assertIsNot(
+                orig_query, derived_query,
+                f"Query {i} in combined_queries should not be shared"
+            )
