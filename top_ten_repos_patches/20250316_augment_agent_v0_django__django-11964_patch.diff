diff --git a/django/db/models/base.py b/django/db/models/base.py
index 0a5e5ff673..0d4019637a 100644
--- a/django/db/models/base.py
+++ b/django/db/models/base.py
@@ -429,18 +429,18 @@ class Model(metaclass=ModelBase):
             # is *not* consumed. We rely on this, so don't change the order
             # without changing the logic.
             for val, field in zip(args, fields_iter):
                 if val is _DEFERRED:
                     continue
-                _setattr(self, field.attname, val)
+                _setattr(self, field.attname, field.to_python(val))
         else:
             # Slower, kwargs-ready version.
             fields_iter = iter(opts.fields)
             for val, field in zip(args, fields_iter):
                 if val is _DEFERRED:
                     continue
-                _setattr(self, field.attname, val)
+                _setattr(self, field.attname, field.to_python(val))
                 kwargs.pop(field.name, None)
 
         # Now we're left with the unprocessed fields that *must* come from
         # keywords, or default.
 
@@ -480,21 +480,25 @@ class Model(metaclass=ModelBase):
                 # checked) by the RelatedObjectDescriptor.
                 if rel_obj is not _DEFERRED:
                     _setattr(self, field.name, rel_obj)
             else:
                 if val is not _DEFERRED:
-                    _setattr(self, field.attname, val)
+                    _setattr(self, field.attname, field.to_python(val))
 
         if kwargs:
             property_names = opts._property_names
             for prop in tuple(kwargs):
                 try:
                     # Any remaining kwargs must correspond to properties or
                     # virtual fields.
                     if prop in property_names or opts.get_field(prop):
                         if kwargs[prop] is not _DEFERRED:
-                            _setattr(self, prop, kwargs[prop])
+                            try:
+                                field = opts.get_field(prop)
+                                _setattr(self, prop, field.to_python(kwargs[prop]))
+                            except (AttributeError, FieldDoesNotExist):
+                                _setattr(self, prop, kwargs[prop])
                         del kwargs[prop]
                 except (AttributeError, FieldDoesNotExist):
                     pass
             for kwarg in kwargs:
                 raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py
index d610dc86f0..0c830e1c34 100644
--- a/django/db/models/fields/__init__.py
+++ b/django/db/models/fields/__init__.py
@@ -1,9 +1,10 @@
 import collections.abc
 import copy
 import datetime
 import decimal
+import enum
 import operator
 import uuid
 import warnings
 from base64 import b64decode, b64encode
 from functools import partialmethod, total_ordering
@@ -1006,11 +1007,15 @@ class CharField(Field):
 
     def get_internal_type(self):
         return "CharField"
 
     def to_python(self, value):
-        if isinstance(value, str) or value is None:
+        if value is None:
+            return value
+        if isinstance(value, enum.Enum):
+            return value.value
+        if isinstance(value, str):
             return value
         return str(value)
 
     def get_prep_value(self, value):
         value = super().get_prep_value(value)
@@ -1767,10 +1772,12 @@ class IntegerField(Field):
         return "IntegerField"
 
     def to_python(self, value):
         if value is None:
             return value
+        if isinstance(value, enum.Enum):
+            return value.value
         try:
             return int(value)
         except (TypeError, ValueError):
             raise exceptions.ValidationError(
                 self.error_messages['invalid'],
diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py
index 189fb4fa44..2422bd63a9 100644
--- a/django/db/models/query_utils.py
+++ b/django/db/models/query_utils.py
@@ -134,11 +134,12 @@ class DeferredAttribute:
             val = self._check_parent_chain(instance)
             if val is None:
                 instance.refresh_from_db(fields=[field_name])
                 val = getattr(instance, field_name)
             data[field_name] = val
-        return data[field_name]
+        # Apply to_python to handle enum values
+        return self.field.to_python(data[field_name])
 
     def _check_parent_chain(self, instance):
         """
         Check if the field value can be fetched from a parent field already
         loaded in the instance. This can be done if the to-be fetched
