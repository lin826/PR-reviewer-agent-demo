diff --git a/sympy/geometry/point.py b/sympy/geometry/point.py
index 7c978c47be..d922c76fdc 100644
--- a/sympy/geometry/point.py
+++ b/sympy/geometry/point.py
@@ -213,6 +213,16 @@ def __add__(self, other):
         sympy.geometry.point.Point.translate
 
         """
+        from sympy.core.mul import Mul
+        
+        # accept "k*Point" coming from SymPy's generic multiplication
+        if isinstance(other, Mul):
+            # separate the point factor from the scalar factors
+            pt = [a for a in other.args if isinstance(a, Point)]
+            if pt:
+                scalar = Mul(*[a for a in other.args if not isinstance(a, Point)])
+                return self + pt[0]*scalar
+        
         try:
             s, o = Point._normalize_dimension(self, Point(other, evaluate=False))
         except TypeError:
@@ -282,6 +292,26 @@ def __neg__(self):
         """Negate the point."""
         coords = [-x for x in self.args]
         return Point(coords, evaluate=False)
+        
+    def __rmul__(self, factor):
+        """Reflective multiplication so that both ``Point*scalar`` and
+        ``scalar*Point`` give a Point.
+
+        The implementation mirrors ``__mul__``.  It is purposely *not*
+        delegated back to the left operand – many SymPy ``Expr`` subclasses
+        (Float, Integer, Symbol, …) do not return ``NotImplemented`` and would
+        create a generic symbolic product instead.
+        """
+        return self.__mul__(factor)
+        
+    def as_coeff_Mul(self):
+        """Return the tuple (S.One, self) to be compatible with SymPy's Mul.flatten().
+        
+        This method is needed for scalar * Point operations to work properly with
+        all scalar types, especially SymPy's Integer, Rational, etc.
+        """
+        from sympy import S
+        return S.One, self
 
     def __sub__(self, other):
         """Subtract two points, or subtract a factor from this point's
