diff --git a/django/forms/models.py b/django/forms/models.py
index 5d115458a1..f993bb9c98 100644
--- a/django/forms/models.py
+++ b/django/forms/models.py
@@ -100,7 +100,7 @@ def apply_limit_choices_to_to_formfield(formfield):
     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):
         limit_choices_to = formfield.get_limit_choices_to()
         if limit_choices_to is not None:
-            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)
+            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to).distinct()
 
 
 def fields_for_model(model, fields=None, exclude=None, widgets=None,
diff --git a/tests/model_forms/models.py b/tests/model_forms/models.py
index 1a2102f898..1fbbd691d1 100644
--- a/tests/model_forms/models.py
+++ b/tests/model_forms/models.py
@@ -422,11 +422,61 @@ class Student(models.Model):
     study = models.CharField(max_length=30)
 
 
+
+
+
 # Model for #639
 class Photo(models.Model):
     title = models.CharField(max_length=30)
     image = models.FileField(storage=temp_storage, upload_to='tests')
 
+
+# Models for testing duplicate choices issue with limit_choices_to and Q objects
+class TestWriter(models.Model):
+    name = models.CharField(max_length=100)
+    is_active = models.BooleanField(default=True)
+
+    def __str__(self):
+        return self.name
+
+
+class TestNovel(models.Model):
+    title = models.CharField(max_length=200)
+    writer = models.ForeignKey(TestWriter, models.CASCADE)
+    is_available = models.BooleanField(default=True)
+
+    def __str__(self):
+        return self.title
+
+
+class TestLabel(models.Model):
+    name = models.CharField(max_length=50)
+    is_active = models.BooleanField(default=True)
+
+    def __str__(self):
+        return self.name
+
+
+class TestNovelLabel(models.Model):
+    """Many-to-many through model to create more complex joins"""
+    novel = models.ForeignKey(TestNovel, models.CASCADE)
+    label = models.ForeignKey(TestLabel, models.CASCADE)
+
+
+class TestBookReview(models.Model):
+    novel = models.ForeignKey(
+        TestNovel, 
+        models.CASCADE,
+        # This Q object involves joins that may cause duplicate options
+        # Using OR condition which might cause the same book to appear multiple times
+        limit_choices_to=models.Q(writer__is_active=True) | models.Q(testnovellabel__label__is_active=True)
+    )
+    rating = models.IntegerField()
+    comment = models.TextField()
+
+    def __str__(self):
+        return f"Review for {self.novel.title}"
+
     # Support code for the tests; this keeps track of how many times save()
     # gets called on each instance.
     def __init__(self, *args, **kwargs):
diff --git a/tests/model_forms/tests.py b/tests/model_forms/tests.py
index 9e900e35f4..5fbd60cd29 100644
--- a/tests/model_forms/tests.py
+++ b/tests/model_forms/tests.py
@@ -2829,6 +2829,80 @@ class LimitChoicesToTests(TestCase):
             StumpJokeForm()
             self.assertEqual(today_callable_dict.call_count, 3)
 
+    def test_limit_choices_to_q_object_with_joins_no_duplicates(self):
+        """
+        Test that limit_choices_to with Q objects involving joins doesn't 
+        produce duplicate options in form fields.
+        """
+        from .models import TestWriter, TestNovel, TestLabel, TestNovelLabel, TestBookReview
+        from django import forms
+        
+        # Create test data
+        writer1 = TestWriter.objects.create(name="Active Writer", is_active=True)
+        writer2 = TestWriter.objects.create(name="Inactive Writer", is_active=False)
+        
+        label1 = TestLabel.objects.create(name="Active Label 1", is_active=True)
+        label2 = TestLabel.objects.create(name="Active Label 2", is_active=True)
+        label3 = TestLabel.objects.create(name="Inactive Label", is_active=False)
+        
+        # Create novels
+        novel1 = TestNovel.objects.create(title="Novel 1", writer=writer1)  # Should match both conditions
+        novel2 = TestNovel.objects.create(title="Novel 2", writer=writer2)  # Should match only label condition
+        novel3 = TestNovel.objects.create(title="Novel 3", writer=writer1)  # Should match both conditions
+        novel4 = TestNovel.objects.create(title="Novel 4", writer=writer2)  # Should not match any condition
+        
+        # Create novel-label relationships
+        # Novel 1 has multiple active labels - this would cause duplicates without distinct()
+        TestNovelLabel.objects.create(novel=novel1, label=label1)
+        TestNovelLabel.objects.create(novel=novel1, label=label2)
+        
+        # Novel 2 has one active label
+        TestNovelLabel.objects.create(novel=novel2, label=label1)
+        
+        # Novel 3 has one inactive label but active writer
+        TestNovelLabel.objects.create(novel=novel3, label=label3)
+        
+        # Novel 4 has no labels
+        
+        # Create form and test choices
+        class ReviewForm(forms.ModelForm):
+            class Meta:
+                model = TestBookReview
+                fields = ['novel', 'rating', 'comment']
+        
+        form = ReviewForm()
+        novel_field = form.fields['novel']
+        
+        # Get the choices and check for duplicates
+        choices = list(novel_field.choices)
+        choice_values = []
+        for choice in choices:
+            if choice[0] != '':  # Skip empty choice
+                # Extract the actual value from ModelChoiceIteratorValue
+                if hasattr(choice[0], 'value'):
+                    choice_values.append(choice[0].value)
+                else:
+                    choice_values.append(choice[0])
+        
+        # Check that there are no duplicates
+        unique_values = set(choice_values)
+        self.assertEqual(
+            len(choice_values), 
+            len(unique_values),
+            f"Duplicate choices found: {choice_values}. Expected unique values: {list(unique_values)}"
+        )
+        
+        # Verify that the expected novels are included
+        expected_novels = {novel1.pk, novel2.pk, novel3.pk}  # novel4 should be excluded
+        actual_novels = set(choice_values)
+        self.assertEqual(actual_novels, expected_novels)
+        
+        # Verify that the queryset uses DISTINCT
+        queryset_sql = str(novel_field.queryset.query)
+        self.assertIn('DISTINCT', queryset_sql.upper())
+
+
+
 
 class FormFieldCallbackTests(SimpleTestCase):
 
