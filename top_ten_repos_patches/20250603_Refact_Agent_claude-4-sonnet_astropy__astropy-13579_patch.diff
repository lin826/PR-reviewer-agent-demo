diff --git a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py
index d7605b078c..6f1cafdcf6 100644
--- a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py
+++ b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py
@@ -251,7 +251,14 @@ class SlicedLowLevelWCS(BaseWCSWrapper):
                 iworld_curr += 1
                 world_arrays_new.append(world_arrays[iworld_curr])
             else:
-                world_arrays_new.append(1.)
+                # For sliced dimensions, compute the world coordinate that 
+                # corresponds to the slice pixel index
+                slice_pixel_index = self._slices_pixel[iworld]
+                # Use reference pixel coordinates for all other dimensions
+                ref_pixels = [0.0] * self._wcs.pixel_n_dim
+                ref_pixels[iworld] = slice_pixel_index
+                slice_world_coords = self._wcs.pixel_to_world_values(*ref_pixels)
+                world_arrays_new.append(slice_world_coords[iworld])
 
         world_arrays_new = np.broadcast_arrays(*world_arrays_new)
         pixel_arrays = list(self._wcs.world_to_pixel_values(*world_arrays_new))
diff --git a/astropy/wcs/wcsapi/wrappers/tests/test_sliced_wcs.py b/astropy/wcs/wcsapi/wrappers/tests/test_sliced_wcs.py
index a354114962..50da14ff67 100644
--- a/astropy/wcs/wcsapi/wrappers/tests/test_sliced_wcs.py
+++ b/astropy/wcs/wcsapi/wrappers/tests/test_sliced_wcs.py
@@ -13,6 +13,7 @@ from astropy.coordinates import SkyCoord, Galactic, ICRS
 from astropy.units import Quantity
 from astropy.wcs.wcsapi.wrappers.sliced_wcs import SlicedLowLevelWCS, sanitize_slices, combine_slices
 from astropy.wcs.wcsapi.utils import wcs_info_str
+from astropy.wcs.wcsapi import HighLevelWCSWrapper
 import astropy.units as u
 
 from astropy.coordinates.spectral_coordinate import SpectralCoord
@@ -899,3 +900,76 @@ def test_pixel_to_world_values_different_int_types():
     for int_coord, np64_coord in zip(int_sliced.pixel_to_world_values(*pixel_arrays),
                                      np64_sliced.pixel_to_world_values(*pixel_arrays)):
         assert all(int_coord == np64_coord)
+
+
+def test_sliced_wcs_world_to_pixel_with_pc_matrix():
+    """
+    Test that SlicedLowLevelWCS.world_to_pixel works correctly with non-trivial PC matrices.
+    
+    This is a regression test for the issue where SlicedLowLevelWCS would use
+    hardcoded default values (1.0) for dropped world dimensions instead of
+    computing the actual world coordinate corresponding to the slice pixel index.
+    
+    Regression test for https://github.com/astropy/astropy/issues/XXXX
+    """
+    # Suppress warnings about missing observer
+    with warnings.catch_warnings():
+        warnings.simplefilter("ignore")
+        
+        # Create a 3D WCS with non-trivial PC matrix that couples dimensions
+        nx, ny, nz = 100, 25, 2
+        wcs_header = {
+            'WCSAXES': 3,
+            'CRPIX1': (nx + 1)/2,
+            'CRPIX2': (ny + 1)/2,
+            'CRPIX3': 1.0,
+            'PC1_1': 0.0,
+            'PC1_2': -1.0,
+            'PC1_3': 0.0,
+            'PC2_1': 1.0,
+            'PC2_2': 0.0,
+            'PC2_3': -1.0,
+            'CDELT1': 5,
+            'CDELT2': 5,
+            'CDELT3': 0.055,
+            'CUNIT1': 'arcsec',
+            'CUNIT2': 'arcsec',
+            'CUNIT3': 'Angstrom',
+            'CTYPE1': 'HPLN-TAN',
+            'CTYPE2': 'HPLT-TAN',
+            'CTYPE3': 'WAVE',
+            'CRVAL1': 0.0,
+            'CRVAL2': 0.0,
+            'CRVAL3': 1.05,
+        }
+        fits_wcs = WCS(header=wcs_header)
+        
+        # Test coordinates
+        test_coords = [
+            (0*u.arcsec, 0*u.arcsec),
+            (10*u.arcsec, 5*u.arcsec),
+        ]
+        
+        # Test different slice indices
+        slice_indices = [0, 1]
+        
+        for slice_idx in slice_indices:
+            # Calculate the wavelength corresponding to this slice
+            wavelength = fits_wcs.pixel_to_world_values(0, 0, slice_idx)[2] * u.m
+            
+            # Create sliced WCS
+            ll_sliced_wcs = SlicedLowLevelWCS(fits_wcs, slice_idx)
+            hl_sliced_wcs = HighLevelWCSWrapper(ll_sliced_wcs)
+            
+            for tx, ty in test_coords:
+                # Get expected result from unsliced WCS
+                expected = fits_wcs.world_to_pixel(tx, ty, wavelength)
+                
+                # Get result from sliced WCS
+                result = hl_sliced_wcs.world_to_pixel(tx, ty)
+                
+                # First two coordinates should match
+                assert_allclose(expected[0], result[0], rtol=1e-10), \
+                    f"X coordinate mismatch for slice {slice_idx}, coords ({tx}, {ty}): {expected[0]} vs {result[0]}"
+                assert_allclose(expected[1], result[1], rtol=1e-10), \
+                    f"Y coordinate mismatch for slice {slice_idx}, coords ({tx}, {ty}): {expected[1]} vs {result[1]}"
