diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py
index 3f768d2..2f499d3 100644
--- a/django/db/models/fields/__init__.py
+++ b/django/db/models/fields/__init__.py
@@ -513,20 +513,65 @@ class Field(RegisterLookupMixin):
         name, path, args, kwargs = self.deconstruct()
         return self.__class__(*args, **kwargs)
 
+
     def __eq__(self, other):
-        # Needed for @total_ordering
-        if isinstance(other, Field):
-            return self.creation_counter == other.creation_counter
-        return NotImplemented
+        """
+        Fields are equal when they have the same creation_counter and originate
+        from the same model (or when neither is yet attached to a model).
+        """
+        if not isinstance(other, Field):
+            return NotImplemented
+        if self.creation_counter != other.creation_counter:
+            return False
+        self_model = getattr(self, 'model', None)
+        other_model = getattr(other, 'model', None)
+        if self_model is None and other_model is None:
+            return True
+        return self_model is other_model
 
     def __lt__(self, other):
-        # This is needed because bisect does not take a comparison function.
-        if isinstance(other, Field):
+        """
+        Provide a deterministic ordering for Field instances.
+
+        If both fields belong to the same model (or to no model yet), fall back
+        to creation_counter. Otherwise, order first by a stable model label and
+        then by creation_counter.
+        """
+        if not isinstance(other, Field):
+            return NotImplemented
+
+        self_model = getattr(self, 'model', None)
+        other_model = getattr(other, 'model', None)
+
+        if self_model is other_model:
             return self.creation_counter < other.creation_counter
-        return NotImplemented
+
+        def _model_label(model):
+            if model is None:
+                return ''
+            try:
+                return model._meta.label
+            except AttributeError:
+                return f'{model.__module__}.{getattr(model, "__qualname__", model.__class__.__name__)}'
+
+        return (
+            _model_label(self_model),
+            self.creation_counter
+        ) < (
+            _model_label(other_model),
+            other.creation_counter
+        )
 
     def __hash__(self):
-        return hash(self.creation_counter)
+        """
+        Combine the model (if available) with creation_counter to avoid
+        collisions between fields from different models.
+        """
+        model = getattr(self, 'model', None)
+        if model is None:
+            return hash(self.creation_counter)
+        return hash((self.creation_counter, model))
+
 
     def __deepcopy__(self, memodict):
         # We don't have to deepcopy very much here, since most things are not
