diff --git a/lib/matplotlib/contour.py b/lib/matplotlib/contour.py
index 144eadeae2..e9350b8173 100644
--- a/lib/matplotlib/contour.py
+++ b/lib/matplotlib/contour.py
@@ -1088,6 +1088,17 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):
         one contour line, but two filled regions, and therefore
         three levels to provide boundaries for both regions.
         """
+        # Auto-detect boolean arrays and return appropriate levels
+        if (hasattr(self, '_original_z_dtype') and 
+            self._original_z_dtype == np.bool_):
+            # For boolean arrays, check if we have both True and False values
+            if self.zmin == 0.0 and self.zmax == 1.0:
+                # Mixed boolean array: return single level at 0.5
+                return np.array([0.5])
+            else:
+                # Uniform boolean array: return level at the single value
+                return np.array([self.zmin])
+        
         if self.locator is None:
             if self.logscale:
                 self.locator = ticker.LogLocator()
@@ -1447,6 +1458,9 @@ class QuadContourSet(ContourSet):
             fn = 'contour'
         nargs = len(args)
         if nargs <= 2:
+            # Store original dtype before conversion to float64
+            z_orig = ma.asarray(args[0])
+            self._original_z_dtype = z_orig.dtype
             z = ma.asarray(args[0], dtype=np.float64)
             x, y = self._initialize_x_y(z)
             args = args[1:]
@@ -1475,6 +1489,9 @@ class QuadContourSet(ContourSet):
 
         x = np.asarray(x, dtype=np.float64)
         y = np.asarray(y, dtype=np.float64)
+        # Store original dtype before conversion to float64
+        z_orig = ma.asarray(args[2])
+        self._original_z_dtype = z_orig.dtype
         z = ma.asarray(args[2], dtype=np.float64)
 
         if z.ndim != 2:
diff --git a/lib/matplotlib/tests/test_contour.py b/lib/matplotlib/tests/test_contour.py
index e42206b8cb..c2cec39593 100644
--- a/lib/matplotlib/tests/test_contour.py
+++ b/lib/matplotlib/tests/test_contour.py
@@ -693,3 +693,39 @@ def test_contour_remove():
     assert ax.get_children() != orig_children
     cs.remove()
     assert ax.get_children() == orig_children
+
+
+def test_contour_boolean_array():
+    """Test auto-detection of boolean arrays for contour levels."""
+    # Mixed boolean array should get single level at 0.5
+    bool_mixed = np.array([[True, False, True], 
+                          [False, True, False], 
+                          [True, False, True]], dtype=bool)
+    cs_mixed = plt.contour(bool_mixed)
+    assert len(cs_mixed.levels) == 1
+    assert cs_mixed.levels[0] == 0.5
+    
+    # All True should get single level at 1.0 (but may warn about no levels in range)
+    bool_true = np.ones((3, 3), dtype=bool)
+    with pytest.warns(UserWarning, match="No contour levels were found"):
+        cs_true = plt.contour(bool_true)
+    assert len(cs_true.levels) == 1
+    assert cs_true.levels[0] == 1.0
+    
+    # All False should get single level at 0.0 (but may warn about no levels in range)
+    bool_false = np.zeros((3, 3), dtype=bool)
+    with pytest.warns(UserWarning, match="No contour levels were found"):
+        cs_false = plt.contour(bool_false)
+    assert len(cs_false.levels) == 1
+    assert cs_false.levels[0] == 0.0
+    
+    # Integer arrays with 0/1 should NOT be affected
+    int_array = np.array([[0, 1, 0], [1, 0, 1]], dtype=int)
+    cs_int = plt.contour(int_array)
+    assert len(cs_int.levels) > 1  # Should have multiple levels
+    
+    # Explicit levels should override boolean detection
+    cs_explicit = plt.contour(bool_mixed, levels=[0.2, 0.8])
+    assert len(cs_explicit.levels) == 2
+    assert cs_explicit.levels[0] == 0.2
+    assert cs_explicit.levels[1] == 0.8
