diff --git a/sympy/core/mod.py b/sympy/core/mod.py
index b4f3de2523..59f0324a6b 100644
--- a/sympy/core/mod.py
+++ b/sympy/core/mod.py
@@ -166,7 +166,12 @@ def doit(p, q):
         # XXX other possibilities?
 
         # extract gcd; any further simplification should be done by the user
-        G = gcd(p, q)
+        # But skip GCD computation if expressions contain Piecewise, as it can't be handled by polynomial system
+        from sympy.functions.elementary.piecewise import Piecewise
+        if (hasattr(p, 'find') and p.find(Piecewise)) or (hasattr(q, 'find') and q.find(Piecewise)):
+            G = S.One  # Skip GCD computation for Piecewise-containing expressions
+        else:
+            G = gcd(p, q)
         if G != 1:
             p, q = [
                 gcd_terms(i/G, clear=False, fraction=False) for i in (p, q)]
diff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py
index 2dc6589f8c..abec60a06e 100644
--- a/sympy/core/tests/test_arit.py
+++ b/sympy/core/tests/test_arit.py
@@ -1,7 +1,7 @@
 from sympy import (Basic, Symbol, sin, cos, atan, exp, sqrt, Rational,
         Float, re, pi, sympify, Add, Mul, Pow, Mod, I, log, S, Max, symbols,
         oo, zoo, Integer, sign, im, nan, Dummy, factorial, comp, floor, Poly,
-        FiniteSet
+        FiniteSet, sinh, Piecewise
 )
 from sympy.core.parameters import distribute
 from sympy.core.expr import unchanged
@@ -1987,6 +1987,44 @@ def test_Mod_is_nonposneg():
     assert Mod(k, n).is_nonnegative is None
 
 
+def test_Mod_piecewise():
+    """Test that Mod.eval() handles Piecewise expressions correctly.
+    
+    This tests the fix for the issue where expressions containing
+    exp(sinh(Piecewise(...)/z)) with real symbols would raise
+    PolynomialError during substitution due to GCD computation
+    on Piecewise expressions.
+    """
+    from sympy.core.cache import clear_cache
+    
+    # Test case 1: Original issue - should not raise PolynomialError
+    clear_cache()
+    x, y, z = symbols('x y z', real=True)
+    expr = exp(sinh(Piecewise((x, y > x), (y, True)) / z))
+    
+    # This should work without raising PolynomialError
+    result = expr.subs({1: 1.0})
+    assert result is not None
+    
+    # Test case 2: Direct Mod with Piecewise should work
+    clear_cache()
+    x, y = symbols('x y', real=True)
+    pw = Piecewise((x, y > x), (y, True))
+    
+    # This should not raise PolynomialError
+    mod_expr = Mod(pw, pi)
+    assert mod_expr is not None
+    
+    # Test case 3: Ensure normal GCD behavior is preserved for non-Piecewise
+    clear_cache()
+    x = symbols('x')
+    
+    # Normal case without Piecewise should still use GCD
+    mod_expr = Mod(6*x, 4*x)
+    # Should be able to evaluate without error
+    assert mod_expr is not None
+
+
 def test_issue_6001():
     A = Symbol("A", commutative=False)
     eq = A + A**2
