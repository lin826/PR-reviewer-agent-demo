diff --git a/sklearn/impute/_iterative.py b/sklearn/impute/_iterative.py
index 1d918bc0c..b465d5598 100644
--- a/sklearn/impute/_iterative.py
+++ b/sklearn/impute/_iterative.py
@@ -170,6 +170,15 @@ class IterativeImputer(_BaseImputer):
         the missing indicator even if there are missing values at
         transform/test time.
 
+    fill_value : str or numerical value, default=None
+        When `initial_strategy="constant"`, `fill_value` is used to replace all
+        occurrences of missing_values during the initial imputation (before the
+        iterative procedure). For string or object data types, `fill_value` must
+        be a string. If `None`, `fill_value` will be 0 when imputing numerical
+        data and "missing_value" for strings or object data types.
+
+        .. versionadded:: 1.4
+
     keep_empty_features : bool, default=False
         If True, features that consist exclusively of missing values when
         `fit` is called are returned in results when `transform` is called.
@@ -281,6 +290,7 @@ class IterativeImputer(_BaseImputer):
         "initial_strategy": [
             StrOptions({"mean", "median", "most_frequent", "constant"})
         ],
+        "fill_value": "no_validation",  # any object is valid
         "imputation_order": [
             StrOptions({"ascending", "descending", "roman", "arabic", "random"})
         ],
@@ -301,6 +311,7 @@ class IterativeImputer(_BaseImputer):
         tol=1e-3,
         n_nearest_features=None,
         initial_strategy="mean",
+        fill_value=None,
         imputation_order="ascending",
         skip_complete=False,
         min_value=-np.inf,
@@ -322,6 +333,7 @@ class IterativeImputer(_BaseImputer):
         self.tol = tol
         self.n_nearest_features = n_nearest_features
         self.initial_strategy = initial_strategy
+        self.fill_value = fill_value
         self.imputation_order = imputation_order
         self.skip_complete = skip_complete
         self.min_value = min_value
@@ -613,6 +625,7 @@ class IterativeImputer(_BaseImputer):
             self.initial_imputer_ = SimpleImputer(
                 missing_values=self.missing_values,
                 strategy=self.initial_strategy,
+                fill_value=self.fill_value,
                 keep_empty_features=self.keep_empty_features,
             )
             X_filled = self.initial_imputer_.fit_transform(X)
diff --git a/sklearn/impute/tests/test_impute.py b/sklearn/impute/tests/test_impute.py
index 86553effa..3bfd6ca95 100644
--- a/sklearn/impute/tests/test_impute.py
+++ b/sklearn/impute/tests/test_impute.py
@@ -1524,6 +1524,91 @@ def test_iterative_imputer_keep_empty_features(initial_strategy):
     assert_allclose(X_imputed[:, 1], 0)
 
 
+@pytest.mark.parametrize("fill_value", [0, 42, -1, 3.14, np.nan])
+def test_iterative_imputer_fill_value(fill_value):
+    """Test IterativeImputer with fill_value parameter for constant strategy."""
+    X = np.array([[1, 2, np.nan],
+                  [4, np.nan, 6],
+                  [np.nan, 8, 9]])
+    
+    # Test with custom fill_value
+    imputer = IterativeImputer(
+        initial_strategy='constant', 
+        fill_value=fill_value, 
+        max_iter=0,  # Only test initial imputation
+        random_state=42
+    )
+    X_imputed = imputer.fit_transform(X)
+    
+    # Check that the internal SimpleImputer has the correct fill_value
+    if np.isnan(fill_value):
+        assert np.isnan(imputer.initial_imputer_.fill_value)
+        # With np.nan fill_value, missing values should remain as NaN
+        assert_allclose(X_imputed, X, equal_nan=True)
+    else:
+        assert imputer.initial_imputer_.fill_value == fill_value
+        # Check that missing values were filled with fill_value
+        expected = X.copy()
+        expected[np.isnan(expected)] = fill_value
+        assert_array_equal(X_imputed, expected)
+
+
+def test_iterative_imputer_fill_value_backward_compatibility():
+    """Test that default behavior is unchanged when fill_value is not specified."""
+    X = np.array([[1, 2, np.nan],
+                  [4, np.nan, 6],
+                  [np.nan, 8, 9]])
+    
+    # Test default behavior (no fill_value specified)
+    imputer_default = IterativeImputer(
+        initial_strategy='constant', 
+        max_iter=1, 
+        random_state=42
+    )
+    X_default = imputer_default.fit_transform(X)
+    
+    # Test explicit None (should be same as default)
+    imputer_none = IterativeImputer(
+        initial_strategy='constant', 
+        fill_value=None, 
+        max_iter=1, 
+        random_state=42
+    )
+    X_none = imputer_none.fit_transform(X)
+    
+    # Should be identical
+    assert_allclose(X_default, X_none, equal_nan=True)
+    
+    # Both should have fill_value=None
+    assert imputer_default.initial_imputer_.fill_value is None
+    assert imputer_none.initial_imputer_.fill_value is None
+
+
+def test_iterative_imputer_fill_value_comparison_with_simple_imputer():
+    """Test that initial imputation matches SimpleImputer with same fill_value."""
+    X = np.array([[1, 2, np.nan],
+                  [4, np.nan, 6],
+                  [np.nan, 8, 9]])
+    
+    fill_value = 555
+    
+    # SimpleImputer
+    simple_imputer = SimpleImputer(strategy='constant', fill_value=fill_value)
+    X_simple = simple_imputer.fit_transform(X)
+    
+    # IterativeImputer with max_iter=0
+    iterative_imputer = IterativeImputer(
+        initial_strategy='constant', 
+        fill_value=fill_value, 
+        max_iter=0, 
+        random_state=42
+    )
+    X_iterative = iterative_imputer.fit_transform(X)
+    
+    # Should be identical
+    assert_allclose(X_simple, X_iterative, equal_nan=True)
+
+
 @pytest.mark.parametrize("keep_empty_features", [True, False])
 def test_knn_imputer_keep_empty_features(keep_empty_features):
     """Check the behaviour of `keep_empty_features` for `KNNImputer`."""
