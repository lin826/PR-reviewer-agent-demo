diff --git a/pylint/checkers/variables.py b/pylint/checkers/variables.py
index 3ddafd599..9d8938fa7 100644
--- a/pylint/checkers/variables.py
+++ b/pylint/checkers/variables.py
@@ -46,10 +46,11 @@
 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE
 
 """variables checkers for Python code
 """
+import ast
 import collections
 import copy
 import itertools
 import os
 import re
@@ -716,16 +717,51 @@ class VariablesChecker(BaseChecker):
     @utils.check_messages("redefined-outer-name")
     def leave_for(self, node):
         self._loop_variables.pop()
         self._store_type_annotation_names(node)
 
+    def _parse_type_comments(self, node):
+        """Parse type comments from assignment statements and store referenced names."""
+        if not hasattr(node, 'file') or not node.file:
+            return
+        
+        try:
+            # Read the source file
+            with open(node.file, 'r', encoding='utf-8') as f:
+                source = f.read()
+        except (OSError, UnicodeDecodeError):
+            return
+        
+        try:
+            # Parse with standard ast to get type comments
+            ast_tree = ast.parse(source, type_comments=True)
+        except SyntaxError:
+            return
+        
+        # Extract type comments from assignment statements
+        for ast_node in ast.walk(ast_tree):
+            if isinstance(ast_node, ast.Assign) and hasattr(ast_node, 'type_comment') and ast_node.type_comment:
+                # Parse the type comment as a type annotation
+                try:
+                    # Convert to astroid and extract names
+                    type_comment_astroid = astroid.builder.AstroidBuilder().string_build(
+                        ast_node.type_comment, 'type_comment'
+                    ).body[0].value
+                    self._store_type_annotation_node(type_comment_astroid)
+                except (SyntaxError, astroid.AstroidError):
+                    # If we can't parse the type comment, skip it
+                    continue
+
     def visit_module(self, node):
         """visit module : update consumption analysis variable
         checks globals doesn't overrides builtins
         """
         self._to_consume = [NamesConsumer(node, "module")]
         self._postponed_evaluation_enabled = is_postponed_evaluation_enabled(node)
+        
+        # Parse type comments to avoid false positives for unused imports
+        self._parse_type_comments(node)
 
         for name, stmts in node.locals.items():
             if utils.is_builtin(name):
                 if self._should_ignore_redefined_builtin(stmts[0]) or name == "__doc__":
                     continue
@@ -1245,11 +1281,12 @@ class VariablesChecker(BaseChecker):
     def leave_with(self, node):
         self._store_type_annotation_names(node)
 
     def visit_arguments(self, node):
         for annotation in node.type_comment_args:
-            self._store_type_annotation_node(annotation)
+            if annotation is not None:
+                self._store_type_annotation_node(annotation)
 
     # Relying on other checker's options, which might not have been initialized yet.
     @astroid.decorators.cachedproperty
     def _analyse_fallback_blocks(self):
         return get_global_option(self, "analyse-fallback-blocks", default=False)
@@ -1820,25 +1857,41 @@ class VariablesChecker(BaseChecker):
                 return True
         return False
 
     def _store_type_annotation_node(self, type_annotation):
         """Given a type annotation, store all the name nodes it refers to"""
+        if type_annotation is None:
+            return
+            
         if isinstance(type_annotation, astroid.Name):
             self._type_annotation_names.append(type_annotation.name)
             return
 
-        if not isinstance(type_annotation, astroid.Subscript):
+        if isinstance(type_annotation, astroid.Attribute):
+            # Handle attribute access like abc.ABC - extract all Name nodes
+            self._type_annotation_names.extend(
+                annotation.name
+                for annotation in type_annotation.nodes_of_class(astroid.Name)
+            )
             return
 
-        if (
-            isinstance(type_annotation.value, astroid.Attribute)
-            and isinstance(type_annotation.value.expr, astroid.Name)
-            and type_annotation.value.expr.name == TYPING_MODULE
-        ):
-            self._type_annotation_names.append(TYPING_MODULE)
+        if isinstance(type_annotation, astroid.Subscript):
+            if (
+                isinstance(type_annotation.value, astroid.Attribute)
+                and isinstance(type_annotation.value.expr, astroid.Name)
+                and type_annotation.value.expr.name == TYPING_MODULE
+            ):
+                self._type_annotation_names.append(TYPING_MODULE)
+                return
+
+            self._type_annotation_names.extend(
+                annotation.name
+                for annotation in type_annotation.nodes_of_class(astroid.Name)
+            )
             return
 
+        # For any other node type, extract all Name nodes recursively
         self._type_annotation_names.extend(
             annotation.name
             for annotation in type_annotation.nodes_of_class(astroid.Name)
         )
 
