diff --git a/sympy/sets/sets.py b/sympy/sets/sets.py
index 3c4aa86e36..4d5d9b0aca 100644
--- a/sympy/sets/sets.py
+++ b/sympy/sets/sets.py
@@ -863,10 +863,31 @@ def __len__(self):
         return reduce(lambda a, b: a*b, (len(s) for s in self.args))
 
     def __bool__(self):
         return all([bool(s) for s in self.sets])
 
+    def _eval_is_subset(self, other):
+        """
+        Returns True if this ProductSet is a subset of other.
+        
+        For ProductSet vs FiniteSet comparison, we check if all elements
+        of the ProductSet are contained in the FiniteSet.
+        """
+        if isinstance(other, FiniteSet):
+            # If this ProductSet is finite and iterable, we can check element by element
+            if self.is_finite_set and self.is_iterable:
+                try:
+                    # Check if all elements of self are in other
+                    for element in self:
+                        if element not in other:
+                            return False
+                    return True
+                except (ValueError, TypeError):
+                    # If iteration fails, fall back to default behavior
+                    pass
+        return None
+
 
 class Interval(Set, EvalfMixin):
     """
     Represents a real interval as a Set.
 
@@ -1612,10 +1633,31 @@ def __iter__(self):
             if a not in B:
                     yield a
             else:
                 continue
 
+    def equals(self, other, failing_expression=False):
+        """
+        Return True if self == other, False if it doesn't, or None.
+        
+        For Complement objects, we check if the complement equals zero
+        by checking if it's empty (i.e., if A is a subset of B).
+        """
+        from sympy.core.sympify import sympify
+        other = sympify(other)
+        
+        if other == 0 or other == S.EmptySet:
+            # A - B == 0 (empty) if and only if A is a subset of B
+            A, B = self.args
+            return A.is_subset(B)
+        
+        # For other comparisons, use standard equality
+        if self == other:
+            return True
+        
+        return None
+
 
 class EmptySet(Set, metaclass=Singleton):
     """
     Represents the empty set. The empty set is available as a singleton
     as S.EmptySet.
@@ -1677,10 +1719,28 @@ def _complement(self, other):
         return other
 
     def _symmetric_difference(self, other):
         return other
 
+    def equals(self, other, failing_expression=False):
+        """
+        Return True if self == other, False if it doesn't, or None.
+        
+        For EmptySet, it equals 0 (since empty set is like zero in set arithmetic).
+        """
+        from sympy.core.sympify import sympify
+        other = sympify(other)
+        
+        if other == 0 or other == S.EmptySet:
+            return True
+        
+        # For other comparisons, use standard equality
+        if self == other:
+            return True
+        
+        return False
+
 
 class UniversalSet(Set, metaclass=Singleton):
     """
     Represents the set of all things.
     The universal set is available as a singleton as S.UniversalSet.
