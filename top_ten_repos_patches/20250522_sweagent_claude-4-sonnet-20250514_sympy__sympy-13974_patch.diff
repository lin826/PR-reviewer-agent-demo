diff --git a/sympy/core/power.py b/sympy/core/power.py
index 02ec6480cb..6f0a99ce0e 100644
--- a/sympy/core/power.py
+++ b/sympy/core/power.py
@@ -1062,6 +1062,26 @@ def _eval_expand_multinomial(self, **hints):
         else:
             return result
 
+    def _eval_expand_tensorproduct(self, **hints):
+        """Expand powers of TensorProducts by converting them to multiplications."""
+        from sympy.physics.quantum.tensorproduct import TensorProduct, tensor_product_simp_Mul
+        
+        base, exp = self.args
+        
+        # Handle powers of TensorProducts by expanding them into multiplications
+        if isinstance(base, TensorProduct) and exp.is_integer and exp.is_positive:
+            # Expand the power into a multiplication: (A)^n -> A * A * ... * A
+            # Use evaluate=False to prevent SymPy from automatically converting back to a power
+            expanded = Mul(*[base for _ in range(int(exp))], evaluate=False)
+            return tensor_product_simp_Mul(expanded)
+        else:
+            # For other cases, recursively expand the base
+            expanded_base = base.expand(**hints)
+            if expanded_base != base:
+                return self.func(expanded_base, exp)
+            else:
+                return self
+
     def as_real_imag(self, deep=True, **hints):
         from sympy import atan2, cos, im, re, sin
         from sympy.polys.polytools import poly
diff --git a/sympy/physics/quantum/tensorproduct.py b/sympy/physics/quantum/tensorproduct.py
index 9dd10d219e..96f5d4f022 100644
--- a/sympy/physics/quantum/tensorproduct.py
+++ b/sympy/physics/quantum/tensorproduct.py
@@ -382,7 +382,14 @@ def tensor_product_simp(e, **hints):
     if isinstance(e, Add):
         return Add(*[tensor_product_simp(arg) for arg in e.args])
     elif isinstance(e, Pow):
-        return tensor_product_simp(e.base) ** e.exp
+        # Handle powers of TensorProducts by expanding them into multiplications
+        if isinstance(e.base, TensorProduct) and e.exp.is_integer and e.exp.is_positive:
+            # Expand the power into a multiplication: (A)^n -> A * A * ... * A
+            # Use evaluate=False to prevent SymPy from automatically converting back to a power
+            expanded = Mul(*[e.base for _ in range(int(e.exp))], evaluate=False)
+            return tensor_product_simp_Mul(expanded)
+        else:
+            return tensor_product_simp(e.base) ** e.exp
     elif isinstance(e, Mul):
         return tensor_product_simp_Mul(e)
     elif isinstance(e, Commutator):
