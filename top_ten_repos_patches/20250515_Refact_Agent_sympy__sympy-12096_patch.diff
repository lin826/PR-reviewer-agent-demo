diff --git a/sympy/core/function.py b/sympy/core/function.py
index 1b8005e1d2..e92fa07b7e 100644
--- a/sympy/core/function.py
+++ b/sympy/core/function.py
@@ -506,11 +506,37 @@ def _eval_evalf(self, prec):
                 fname = MPMATH_TRANSLATIONS[fname]
             func = getattr(mpmath, fname)
         except (AttributeError, KeyError):
+            # No mpmath version. Fall back to the user supplied _imp_
+            # implementation, but make sure we pass it *numeric* arguments,
+            # exactly as we do in the mpmath branch above.
             try:
-                return Float(self._imp_(*self.args), prec)
+                # Recursively turn all arguments into mpmath numbers at a
+                # slightly higher precision so that the user implementation
+                # gets full-precision input.
+                args = [a._to_mpmath(prec + 5) for a in self.args]
             except (AttributeError, TypeError, ValueError):
+                # If an argument cannot be converted, give up.
                 return
 
+            try:
+                with mpmath.workprec(prec):
+                    val = self._imp_(*args)
+            except (AttributeError, TypeError, ValueError):
+                # Either _imp_ does not exist or the call failed â€“ let evalf()
+                # decide what to do.
+                return
+
+            # Convert the numerical return value back to a SymPy Float (or
+            # complex Float) at the requested precision.
+            try:
+                return Expr._from_mpmath(val, prec)
+            except Exception:
+                # Fall back to Float for plain Python numeric types.
+                try:
+                    return Float(val, prec)
+                except Exception:
+                    return
+
         # Convert all args to mpf or mpc
         # Convert the arguments to *higher* precision than requested for the
         # final result.
