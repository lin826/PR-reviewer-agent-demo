--- a/sympy/matrices/matrices.py
+++ b/sympy/matrices/matrices.py
@@ -208,10 +208,26 @@
             def entry(i, j):
                 ret = (pivot_val*tmp_mat[i, j + 1] - mat[pivot_pos, j + 1]*tmp_mat[i, 0]) / cumm
                 if not ret.is_Atom:
-                    cancel(ret)
+                    ret = cancel(ret)
+                # Check for NaN and handle it gracefully
+                if ret is S.NaN:
+                    # If we encounter NaN, fall back to a more robust method
+                    return S.NaN
                 return ret
 
-            return sign*bareiss(self._new(mat.rows - 1, mat.cols - 1, entry), pivot_val)
+            try:
+                new_mat = self._new(mat.rows - 1, mat.cols - 1, entry)
+                # Check if any entry in new matrix is NaN
+                for i in range(new_mat.rows):
+                    for j in range(new_mat.cols):
+                        if new_mat[i, j] is S.NaN:
+                            # If NaN is detected, the bareiss method is failing
+                            # Return NaN to signal the calling code to use a fallback
+                            return S.NaN
+                return sign*bareiss(new_mat, pivot_val)
+            except (TypeError, ValueError):
+                # If matrix creation fails due to invalid expressions, return NaN
+                return S.NaN
 
         return cancel(bareiss(self))
 
@@ -423,7 +439,11 @@
                    - self[0, 1] * self[1, 0] * self[2, 2])
 
         if method == "bareiss":
-            return self._eval_det_bareiss()
+            result = self._eval_det_bareiss()
+            # If bareiss returns NaN, fall back to berkowitz method
+            if result is S.NaN:
+                return self._eval_det_berkowitz()
+            return result
         elif method == "berkowitz":
             return self._eval_det_berkowitz()
         elif method == "lu":
