diff --git a/sklearn/linear_model/huber.py b/sklearn/linear_model/huber.py
index 65c686400..a877ab85d 100644
--- a/sklearn/linear_model/huber.py
+++ b/sklearn/linear_model/huber.py
@@ -250,10 +250,15 @@ class HuberRegressor(LinearModel, RegressorMixin, BaseEstimator):
         -------
         self : object
         """
         X, y = check_X_y(
             X, y, copy=False, accept_sparse=['csr'], y_numeric=True)
+        
+        # Convert boolean arrays to float to avoid issues with arithmetic operations
+        if X.dtype == bool:
+            X = X.astype(float)
+            
         if sample_weight is not None:
             sample_weight = np.array(sample_weight)
             check_consistent_length(y, sample_weight)
         else:
             sample_weight = np.ones_like(y)
diff --git a/sklearn/linear_model/tests/test_huber.py b/sklearn/linear_model/tests/test_huber.py
index 6a8b26133..11556e482 100644
--- a/sklearn/linear_model/tests/test_huber.py
+++ b/sklearn/linear_model/tests/test_huber.py
@@ -197,5 +197,42 @@ def test_huber_better_r2_score():
     ridge_outlier_score = ridge.score(X[~mask], y[~mask])
     assert_greater(huber_score, ridge_score)
 
     # The huber model should also fit poorly on the outliers.
     assert_greater(ridge_outlier_score, huber_outlier_score)
+
+
+def test_huber_boolean_input():
+    """Test that HuberRegressor works with boolean input arrays."""
+    # Generate test data
+    X, y, coef = make_regression(n_samples=50, n_features=3, noise=2.0, 
+                                coef=True, random_state=42)
+    X_bool = X > 0  # Convert to boolean
+    
+    # Test that boolean input works without error
+    huber = HuberRegressor(max_iter=100)
+    huber.fit(X_bool, y)
+    
+    # Test that predictions work
+    y_pred = huber.predict(X_bool)
+    assert y_pred.shape == y.shape
+    
+    # Test that results are consistent with manual conversion
+    huber_manual = HuberRegressor(max_iter=100)
+    huber_manual.fit(X_bool.astype(float), y)
+    
+    # Results should be identical (within numerical precision)
+    assert_array_almost_equal(huber.coef_, huber_manual.coef_, decimal=10)
+    assert_almost_equal(huber.intercept_, huber_manual.intercept_, decimal=10)
+    assert_almost_equal(huber.scale_, huber_manual.scale_, decimal=10)
+    
+    # Test edge cases
+    # All True
+    X_all_true = np.ones((20, 2), dtype=bool)
+    y_small = np.random.RandomState(42).randn(20)
+    huber_true = HuberRegressor(max_iter=50)
+    huber_true.fit(X_all_true, y_small)  # Should not raise
+    
+    # All False  
+    X_all_false = np.zeros((20, 2), dtype=bool)
+    huber_false = HuberRegressor(max_iter=50)
+    huber_false.fit(X_all_false, y_small)  # Should not raise
