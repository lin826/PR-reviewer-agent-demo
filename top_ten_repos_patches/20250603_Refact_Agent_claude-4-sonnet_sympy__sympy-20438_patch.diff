diff --git a/sympy/sets/handlers/issubset.py b/sympy/sets/handlers/issubset.py
index fdca06025a..4cb09708d2 100644
--- a/sympy/sets/handlers/issubset.py
+++ b/sympy/sets/handlers/issubset.py
@@ -1,7 +1,7 @@
 from sympy import S, Symbol
 from sympy.core.logic import fuzzy_and, fuzzy_bool, fuzzy_not, fuzzy_or
 from sympy.core.relational import Eq
-from sympy.sets.sets import FiniteSet, Interval, Set, Union
+from sympy.sets.sets import FiniteSet, Interval, Set, Union, ProductSet
 from sympy.sets.fancysets import Complexes, Reals, Range, Rationals
 from sympy.multipledispatch import dispatch
 
@@ -133,3 +133,49 @@ def is_subset_sets(a, b): # noqa:F811
 @dispatch(Rationals, Range)  # type: ignore # noqa:F811
 def is_subset_sets(a, b): # noqa:F811
     return False
+
+@dispatch(ProductSet, FiniteSet)  # type: ignore # noqa:F811
+def is_subset_sets(a_product, b_finite): # noqa:F811
+    """
+    Check if a ProductSet is a subset of a FiniteSet.
+    
+    This handles the case where a ProductSet represents the same mathematical
+    set as a FiniteSet but with different structural representation.
+    """
+    # If the ProductSet is not finite, it cannot be a subset of a FiniteSet
+    if not a_product.is_finite_set:
+        return False
+    
+    # If the ProductSet is not iterable, we can't check membership
+    if not a_product.is_iterable:
+        return None
+        
+    # Check if all elements of the ProductSet are in the FiniteSet
+    try:
+        for element in a_product:
+            if element not in b_finite:
+                return False
+        return True
+    except (TypeError, ValueError):
+        # If iteration fails, fall back to intersection-based check
+        intersection = a_product.intersection(b_finite)
+        # Check if intersection equals the ProductSet by comparing their elements
+        # when both are finite and iterable
+        if (intersection.is_finite_set and intersection.is_iterable and
+            a_product.is_finite_set and a_product.is_iterable):
+            try:
+                return set(intersection) == set(a_product)
+            except (TypeError, ValueError):
+                pass
+        return None
+
+@dispatch(FiniteSet, ProductSet)  # type: ignore # noqa:F811  
+def is_subset_sets(a_finite, b_product): # noqa:F811
+    """
+    Check if a FiniteSet is a subset of a ProductSet.
+    """
+    # Check if all elements of the FiniteSet are in the ProductSet
+    for element in a_finite:
+        if element not in b_product:
+            return False
+    return True
diff --git a/sympy/sets/sets.py b/sympy/sets/sets.py
index 3c4aa86e36..851c3540e8 100644
--- a/sympy/sets/sets.py
+++ b/sympy/sets/sets.py
@@ -1614,6 +1614,21 @@ def __iter__(self):
             else:
                 continue
 
+    def equals(self, other):
+        """
+        Check if this Complement equals another expression.
+        
+        This method is needed for relational simplification logic.
+        """
+        from sympy import S
+        
+        # If other is 0 or EmptySet, check if this complement is empty
+        if other == 0 or other == S.EmptySet:
+            return self.is_empty
+        
+        # For other cases, use the default equality check
+        return self == other
+
 
 class EmptySet(Set, metaclass=Singleton):
     """
@@ -1679,6 +1694,21 @@ def _complement(self, other):
     def _symmetric_difference(self, other):
         return other
 
+    def equals(self, other):
+        """
+        Check if this EmptySet equals another expression.
+        
+        This method is needed for relational simplification logic.
+        """
+        from sympy import S
+        
+        # EmptySet equals 0 or another EmptySet
+        if other == 0 or other == S.EmptySet:
+            return True
+        
+        # For other cases, use the default equality check
+        return self == other
+
 
 class UniversalSet(Set, metaclass=Singleton):
     """
