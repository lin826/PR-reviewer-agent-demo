diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py
index 802fd3c997..04d7e3ba0b 100644
--- a/lib/matplotlib/axes/_base.py
+++ b/lib/matplotlib/axes/_base.py
@@ -1309,8 +1309,65 @@ class _AxesBase(martist.Artist):
             self.yaxis.set_visible(yaxis_visible)
             self.patch.set_visible(patch_visible)
 
+        # Fix for shared axes: restore proper tick label visibility 
+        # when this axis is part of a shared axes group
+        self._restore_shared_axes_visibility()
+
         self.stale = True
 
+    def _restore_shared_axes_visibility(self):
+        """
+        Restore appropriate tick label visibility for shared axes after clear().
+        
+        When an axis is part of a shared axes group, only edge axes should show
+        tick labels. This method determines the axis position in the shared group
+        and hides tick labels appropriately.
+        """
+        # Check if this axis is part of shared axes groups
+        x_siblings = list(self.get_shared_x_axes().get_siblings(self))
+        y_siblings = list(self.get_shared_y_axes().get_siblings(self))
+        
+        # Only proceed if this axis is part of shared axes 
+        if len(x_siblings) <= 1 and len(y_siblings) <= 1:
+            return
+            
+        # For shared axes, we need to determine if this axis is on an edge
+        # where labels should be visible
+        
+        # Get subplot position if available - need to check if _subplotspec exists
+        subplotspec = None
+        if hasattr(self, '_subplotspec') and self._subplotspec is not None:
+            subplotspec = self._subplotspec
+        elif hasattr(self, 'get_subplotspec'):
+            try:
+                subplotspec = self.get_subplotspec()
+            except AttributeError:
+                pass
+                
+        if subplotspec is not None:
+            gridspec = subplotspec.get_gridspec()
+            
+            # Get the row/col position of this subplot
+            rows, cols = gridspec.get_geometry()
+            row_start, row_stop = subplotspec.rowspan.start, subplotspec.rowspan.stop
+            col_start, col_stop = subplotspec.colspan.start, subplotspec.colspan.stop
+            
+            # For shared x-axis: only bottom row should show x tick labels  
+            if len(x_siblings) > 1:
+                is_bottom_row = (row_stop == rows)
+                if not is_bottom_row:
+                    # Hide x-axis tick labels for non-bottom rows
+                    for label in self.xaxis.get_ticklabels():
+                        label.set_visible(False)
+                        
+            # For shared y-axis: only left column should show y tick labels
+            if len(y_siblings) > 1:
+                is_left_column = (col_start == 0)
+                if not is_left_column:
+                    # Hide y-axis tick labels for non-left columns
+                    for label in self.yaxis.get_ticklabels():
+                        label.set_visible(False)
+
     class ArtistList(MutableSequence):
         """
         A sublist of Axes children based on their type.
diff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py
index db7050f732..496d11317e 100644
--- a/lib/matplotlib/tests/test_axes.py
+++ b/lib/matplotlib/tests/test_axes.py
@@ -6976,6 +6976,54 @@ def test_shared_axes_retick():
         assert ax.get_ylim() == axs[0, 0].get_ylim()
 
 
+def test_shared_axes_clear_tick_visibility():
+    """
+    Test that ax.clear() preserves shared axes tick label visibility.
+    
+    Regression test for issue where calling ax.clear() on shared axes
+    would incorrectly show tick labels on interior subplots.
+    """
+    fig, axes = plt.subplots(2, 2, sharex=True, sharey=True)
+    
+    x = np.arange(0.0, 2*np.pi, 0.01)
+    y = np.sin(x)
+    
+    # Clear and plot on each axis (this used to break tick label visibility)
+    for ax in axes.flatten():
+        ax.clear()
+        ax.plot(x, y)
+    
+    # Force a draw to ensure tick labels are created
+    fig.canvas.draw()
+    
+    # Check that tick label visibility follows shared axes rules
+    for i, ax in enumerate(axes.flatten()):
+        row, col = divmod(i, 2)
+        
+        # Count visible tick labels
+        x_labels_visible = sum(1 for label in ax.xaxis.get_ticklabels() 
+                              if label.get_visible())
+        y_labels_visible = sum(1 for label in ax.yaxis.get_ticklabels() 
+                              if label.get_visible())
+        
+        # Expected behavior for shared axes:
+        # - X labels should only be visible on bottom row (row 1)
+        # - Y labels should only be visible on left column (col 0)
+        expected_x_visible = (row == 1)  # Bottom row
+        expected_y_visible = (col == 0)  # Left column
+        
+        actual_x_visible = x_labels_visible > 0
+        actual_y_visible = y_labels_visible > 0
+        
+        assert actual_x_visible == expected_x_visible, \
+            f"Subplot {i} (row {row}, col {col}): x-axis tick labels " \
+            f"visibility incorrect. Expected {expected_x_visible}, got {actual_x_visible}"
+            
+        assert actual_y_visible == expected_y_visible, \
+            f"Subplot {i} (row {row}, col {col}): y-axis tick labels " \
+            f"visibility incorrect. Expected {expected_y_visible}, got {actual_y_visible}"
+
+
 @pytest.mark.parametrize('ha', ['left', 'center', 'right'])
 def test_ylabel_ha_with_position(ha):
     fig = Figure()
