diff --git a/sympy/functions/elementary/hyperbolic.py b/sympy/functions/elementary/hyperbolic.py
index 860989f7c1..8f3767b6dc 100644
--- a/sympy/functions/elementary/hyperbolic.py
+++ b/sympy/functions/elementary/hyperbolic.py
@@ -246,10 +246,17 @@ def _eval_is_real(self):
             return True
 
         # if `im` is of the form n*pi
         # else, check if it is a number
         re, im = arg.as_real_imag()
+        
+        # Check if imaginary part contains Piecewise expressions
+        # If so, we can't safely compute the modulo operation
+        from sympy.functions.elementary.piecewise import Piecewise
+        if im.has(Piecewise):
+            return None
+            
         return (im%pi).is_zero
 
     def _eval_is_extended_real(self):
         if self.args[0].is_extended_real:
             return True
@@ -435,10 +442,17 @@ def _eval_is_real(self):
 
         # cosh(a+ib) = cos(b)*cosh(a) + i*sin(b)*sinh(a)
         # the imaginary part can be an expression like n*pi
         # if not, check if the imaginary part is a number
         re, im = arg.as_real_imag()
+        
+        # Check if imaginary part contains Piecewise expressions
+        # If so, we can't safely compute the modulo operation
+        from sympy.functions.elementary.piecewise import Piecewise
+        if im.has(Piecewise):
+            return None
+            
         return (im%pi).is_zero
 
     def _eval_is_positive(self):
         # cosh(x+I*y) = cos(y)*cosh(x) + I*sin(y)*sinh(x)
         # cosh(z) is positive iff it is real and the real part is positive.
@@ -446,10 +460,17 @@ def _eval_is_positive(self):
         # Case 1 (y=n*pi): cosh(z) = (-1)**n * cosh(x) -> positive for n even
         # Case 2 (x=0): cosh(z) = cos(y) -> positive when cos(y) is positive
         z = self.args[0]
 
         x, y = z.as_real_imag()
+        
+        # Check if imaginary part contains Piecewise expressions
+        # If so, we can't safely compute the modulo operation
+        from sympy.functions.elementary.piecewise import Piecewise
+        if y.has(Piecewise):
+            return None
+            
         ymod = y % (2*pi)
 
         yzero = ymod.is_zero
         # shortcut if ymod is zero
         if yzero:
@@ -473,10 +494,17 @@ def _eval_is_positive(self):
 
     def _eval_is_nonnegative(self):
         z = self.args[0]
 
         x, y = z.as_real_imag()
+        
+        # Check if imaginary part contains Piecewise expressions
+        # If so, we can't safely compute the modulo operation
+        from sympy.functions.elementary.piecewise import Piecewise
+        if y.has(Piecewise):
+            return None
+            
         ymod = y % (2*pi)
 
         yzero = ymod.is_zero
         # shortcut if ymod is zero
         if yzero:
@@ -655,10 +683,16 @@ def _eval_is_real(self):
         if arg.is_real:
             return True
 
         re, im = arg.as_real_imag()
 
+        # Check if imaginary part contains Piecewise expressions
+        # If so, we can't safely compute the modulo operation
+        from sympy.functions.elementary.piecewise import Piecewise
+        if im.has(Piecewise):
+            return None
+
         # if denom = 0, tanh(arg) = zoo
         if re == 0 and im % pi == pi/2:
             return None
 
         # check if im is of the form n*pi/2 to make sin(2*im) = 0
