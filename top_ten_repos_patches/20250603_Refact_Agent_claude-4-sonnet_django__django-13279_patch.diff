diff --git a/django/contrib/sessions/backends/base.py b/django/contrib/sessions/backends/base.py
index b5453160a5..9e146b8561 100644
--- a/django/contrib/sessions/backends/base.py
+++ b/django/contrib/sessions/backends/base.py
@@ -108,6 +108,14 @@ class SessionBase:
 
     def encode(self, session_dict):
         "Return the given session dictionary serialized and encoded as a string."
+        # RemovedInDjango40Warning: when the deprecation ends, remove this
+        # special case.
+        if getattr(settings, 'DEFAULT_HASHING_ALGORITHM', None) == 'sha1':
+            # Use legacy encoding format for compatibility during transition
+            # to Django 3.1 when DEFAULT_HASHING_ALGORITHM is set to 'sha1'.
+            serialized = self.serializer().dumps(session_dict)
+            hash = self._hash(serialized)
+            return base64.b64encode(hash.encode() + b':' + serialized).decode('ascii')
         return signing.dumps(
             session_dict, salt=self.key_salt, serializer=self.serializer,
             compress=True,
@@ -119,6 +127,29 @@ class SessionBase:
         # RemovedInDjango40Warning: when the deprecation ends, handle here
         # exceptions similar to what _legacy_decode() does now.
         except Exception:
+            # If DEFAULT_HASHING_ALGORITHM is 'sha1', also try to decode with 'sha256'
+            # for compatibility during transition to Django 3.1.
+            if getattr(settings, 'DEFAULT_HASHING_ALGORITHM', None) == 'sha1':
+                try:
+                    # Create a temporary signer with SHA-256 to try decoding
+                    from django.core.signing import TimestampSigner
+                    sha256_signer = TimestampSigner(salt=self.key_salt, algorithm='sha256')
+                    unsigned_data = sha256_signer.unsign(session_data)
+                    # Parse the data part (remove timestamp)
+                    data_part = unsigned_data.rsplit(sha256_signer.sep, 1)[0]
+                    # Decode the base64 and deserialize
+                    from django.core.signing import b64_decode
+                    import zlib
+                    if data_part.startswith('.'):
+                        # Compressed data
+                        data_part = data_part[1:]
+                        raw_data = b64_decode(data_part.encode())
+                        raw_data = zlib.decompress(raw_data)
+                    else:
+                        raw_data = b64_decode(data_part.encode())
+                    return self.serializer().loads(raw_data)
+                except Exception:
+                    pass
             return self._legacy_decode(session_data)
 
     def _legacy_decode(self, session_data):
