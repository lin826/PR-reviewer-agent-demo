diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py
index 9875a9f4b..434e6d6bd 100644
--- a/sphinx/domains/python.py
+++ b/sphinx/domains/python.py
@@ -82,8 +82,14 @@ class ModuleEntry(NamedTuple):
 
 def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xref:
     """Convert a type string to a cross reference node."""
+    # Handle literal values (True, False, None, numbers, strings)
     if text == 'None':
         reftype = 'obj'
+    elif text in ('True', 'False') or text.isdigit() or \
+         (text.startswith("'") and text.endswith("'")) or \
+         (text.startswith('"') and text.endswith('"')):
+        # For literal values, use 'obj' role to avoid nitpick warnings
+        reftype = 'obj'
     else:
         reftype = 'class'
 
@@ -1381,8 +1387,8 @@ class PythonDomain(Domain):
 
 
 def builtin_resolver(app: Sphinx, env: BuildEnvironment,
-                     node: pending_xref, contnode: Element) -> Element:
-    """Do not emit nitpicky warnings for built-in types."""
+                      node: pending_xref, contnode: Element) -> Element:
+    """Do not emit nitpicky warnings for built-in types and literal values."""
     def istyping(s: str) -> bool:
         if s.startswith('typing.'):
             s = s.split('.', 1)[1]
@@ -1391,16 +1397,42 @@ def builtin_resolver(app: Sphinx, env: BuildEnvironment,
 
     if node.get('refdomain') != 'py':
         return None
-    elif node.get('reftype') in ('class', 'obj') and node.get('reftarget') == 'None':
+    
+    reftarget = node.get('reftarget')
+    reftype = node.get('reftype')
+    
+    # Special handling for Literal values
+    # If the parent node is a Literal type annotation, don't generate warnings for its values
+    parent_node = node.parent
+    if parent_node and isinstance(parent_node, addnodes.desc_sig_name):
+        parent_text = parent_node.astext()
+        if 'Literal' in parent_text:
+            return contnode
+    
+    # Handle all common literal values
+    if reftarget in ('None', 'True', 'False') or reftarget.isdigit() or \
+       (reftarget.startswith("'") and reftarget.endswith("'")) or \
+       (reftarget.startswith('"') and reftarget.endswith('"')) or \
+       '"' in reftarget or "'" in reftarget or \
+       not reftarget.isidentifier():  # Handle any non-identifier as a literal
+        return contnode
+    
+    # Original logic
+    elif reftype in ('class', 'obj') and reftarget == 'None':
         return contnode
-    elif node.get('reftype') in ('class', 'exc'):
-        reftarget = node.get('reftarget')
+    elif reftype in ('class', 'exc'):
         if inspect.isclass(getattr(builtins, reftarget, None)):
             # built-in class
             return contnode
         elif istyping(reftarget):
             # typing class
             return contnode
+        # Handle literal values like True, False, etc.
+        elif reftarget in ('True', 'False', 'None') or reftarget.isdigit():
+            # Boolean, None, or numeric literals
+            return contnode
+            # Literal values (booleans, None, numbers, strings)
+            return contnode
 
     return None
 
