diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index d69c24419b..a1456055cf 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -1661,13 +1661,27 @@ class Query(BaseExpression):
         saner null handling, and is easier for the backend's optimizer to
         handle.
         """
+        from django.db.models.sql.where import AND
         filter_lhs, filter_rhs = filter_expr
         if isinstance(filter_rhs, F):
             filter_expr = (filter_lhs, OuterRef(filter_rhs.name))
         # Generate the inner query.
         query = Query(self.model)
+        # Copy FilteredRelation annotations to the subquery to ensure they are 
+        # available when resolving field names in the filter expression.
+        query._filtered_relations = self._filtered_relations.copy()
         query.add_filter(filter_expr)
         query.clear_ordering(True)
+        
+        # Add FilteredRelation conditions to the WHERE clause before trimming
+        # to ensure they are preserved even if the joins are simplified.
+        for alias, filtered_relation in self._filtered_relations.items():
+            if alias in filter_lhs:
+                condition = query.build_filtered_relation_q(
+                    filtered_relation.condition, reuse=set()
+                )
+                query.where.add(condition, AND)
+        
         # Try to have as simple as possible subquery -> trim leading joins from
         # the subquery.
         trimmed_prefix, contains_louter = query.trim_start(names_with_path)
diff --git a/tests/filtered_relation/tests.py b/tests/filtered_relation/tests.py
index 5e85dff16c..0b80e74c1f 100644
--- a/tests/filtered_relation/tests.py
+++ b/tests/filtered_relation/tests.py
@@ -98,6 +98,22 @@ class FilteredRelationTests(TestCase):
             [self.author1]
         )
 
+    def test_exclude_with_join(self):
+        self.assertSequenceEqual(
+            Author.objects.annotate(
+                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),
+            ).exclude(book_alice__isnull=False),
+            [self.author2]
+        )
+
+    def test_exclude_with_join_using_negated_q(self):
+        self.assertSequenceEqual(
+            Author.objects.annotate(
+                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),
+            ).filter(~Q(book_alice__isnull=False)),
+            [self.author2]
+        )
+
     def test_with_join_and_complex_condition(self):
         self.assertSequenceEqual(
             Author.objects.annotate(
