diff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py
index 6752a8e3c0..5a45c52e2f 100644
--- a/django/db/backends/sqlite3/schema.py
+++ b/django/db/backends/sqlite3/schema.py
@@ -327,7 +327,9 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):
         # Fields with default values cannot by handled by ALTER TABLE ADD
         # COLUMN statement because DROP DEFAULT is not supported in
         # ALTER TABLE.
-        if not field.null or self.effective_default(field) is not None:
+        # Fields with unique constraints also cannot be handled by ALTER TABLE ADD
+        # COLUMN statement.
+        if not field.null or self.effective_default(field) is not None or field.unique:
             self._remake_table(model, create_field=field)
         else:
             super().add_field(model, field)
diff --git a/tests/schema/tests.py b/tests/schema/tests.py
index cd6a52f6af..ded009e2b2 100644
--- a/tests/schema/tests.py
+++ b/tests/schema/tests.py
@@ -4168,3 +4168,72 @@ class SchemaTests(TransactionTestCase):
             if connection.vendor == 'postgresql':
                 with connection.cursor() as cursor:
                     cursor.execute('DROP COLLATION IF EXISTS case_insensitive')
+
+    @skipUnlessDBFeature('supports_foreign_keys')
+    def test_add_nullable_onetoone_field_sqlite(self):
+        """
+        Test adding a nullable OneToOneField to an existing table on SQLite.
+        Regression test for #33355 - SQLite cannot add UNIQUE columns via ALTER TABLE.
+        """
+        if connection.vendor != 'sqlite':
+            self.skipTest('SQLite-specific test')
+        
+        # Create the tables
+        with connection.schema_editor() as editor:
+            editor.create_model(Author)
+            editor.create_model(Book)
+        
+        # Add a nullable OneToOneField (which is always unique)
+        new_field = OneToOneField(
+            Author, 
+            blank=True, 
+            null=True, 
+            on_delete=CASCADE, 
+            related_name="unique_book"
+        )
+        new_field.set_attributes_from_name("unique_author")
+        
+        # This should not raise "Cannot add a UNIQUE column"
+        with connection.schema_editor() as editor:
+            editor.add_field(Book, new_field)
+        
+        # Verify the field was added
+        with connection.cursor() as cursor:
+            columns = [col.name for col in connection.introspection.get_table_description(cursor, Book._meta.db_table)]
+            self.assertIn('unique_author_id', columns)
+
+    def test_add_unique_field_sqlite(self):
+        """
+        Test adding various unique fields to existing tables on SQLite.
+        Ensures the fix for unique constraints works for all field types.
+        """
+        if connection.vendor != 'sqlite':
+            self.skipTest('SQLite-specific test')
+        
+        # Create the table
+        with connection.schema_editor() as editor:
+            editor.create_model(Author)
+        
+        # Test 1: Nullable unique CharField
+        unique_char_field = CharField(max_length=100, unique=True, null=True, blank=True)
+        unique_char_field.set_attributes_from_name("unique_name")
+        
+        with connection.schema_editor() as editor:
+            editor.add_field(Author, unique_char_field)
+        
+        # Verify first field was added
+        with connection.cursor() as cursor:
+            columns = [col.name for col in connection.introspection.get_table_description(cursor, Author._meta.db_table)]
+            self.assertIn('unique_name', columns)
+        
+        # Test 2: Non-nullable unique CharField with default
+        unique_email_field = CharField(max_length=254, unique=True, default='test@example.com')
+        unique_email_field.set_attributes_from_name("unique_email")
+        
+        with connection.schema_editor() as editor:
+            editor.add_field(Author, unique_email_field)
+        
+        # Verify second field was added
+        with connection.cursor() as cursor:
+            columns = [col.name for col in connection.introspection.get_table_description(cursor, Author._meta.db_table)]
+            self.assertIn('unique_email', columns)
