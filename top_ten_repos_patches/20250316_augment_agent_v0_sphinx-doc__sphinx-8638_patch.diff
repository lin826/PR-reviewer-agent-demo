diff --git b/sphinx/domains/python.py a/sphinx/domains/python.py
index ef141335f..000e2e8d3 100644
--- b/sphinx/domains/python.py
+++ a/sphinx/domains/python.py
@@ -775,11 +775,10 @@ class PyAttribute(PyObject):
 
     option_spec = PyObject.option_spec.copy()
     option_spec.update({
         'type': directives.unchanged,
         'value': directives.unchanged,
-        'noindex_with_parent': directives.flag,
     })
 
     def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:
         fullname, prefix = super().handle_signature(sig, signode)
 
@@ -791,44 +790,10 @@ class PyAttribute(PyObject):
         value = self.options.get('value')
         if value:
             signode += addnodes.desc_annotation(value, ' = ' + value)
 
         return fullname, prefix
-        
-    def add_target_and_index(self, name_cls: Tuple[str, str], sig: str,
-                             signode: desc_signature) -> None:
-        modname = self.options.get('module', self.env.ref_context.get('py:module'))
-        fullname = (modname + '.' if modname else '') + name_cls[0]
-        node_id = make_id(self.env, self.state.document, '', fullname)
-        signode['ids'].append(node_id)
-
-        # Assign old styled node_id(fullname) not to break old hyperlinks (if possible)
-        # Note: Will removed in Sphinx-5.0  (RemovedInSphinx50Warning)
-        if node_id != fullname and fullname not in self.state.document.ids:
-            signode['ids'].append(fullname)
-
-        self.state.document.note_explicit_target(signode)
-
-        domain = cast(PythonDomain, self.env.get_domain('py'))
-        domain.note_object(fullname, self.objtype, node_id, location=signode)
-
-        canonical_name = self.options.get('canonical')
-        if canonical_name:
-            domain.note_object(canonical_name, self.objtype, node_id, location=signode)
-
-        if 'noindex' not in self.options:
-            # For attributes, use a custom index entry type to prevent them from being grouped
-            # with other attributes of the same name
-            name, cls = name_cls
-            if cls:
-                # This is a class attribute, use a custom index entry type
-                # Use the full name as the index key to ensure uniqueness
-                self.indexnode['entries'].append(('attribute', fullname, node_id, '', None))
-            else:
-                # This is a module-level attribute, use the standard index entry type
-                indextext = self.get_index_text(modname, name_cls)
-                self.indexnode['entries'].append(('single', indextext, node_id, '', None))
 
     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:
         name, cls = name_cls
         try:
             clsname, attrname = name.rsplit('.', 1)
@@ -1189,55 +1154,28 @@ class PythonDomain(Domain):
                         newname = modname + '.' + name
                     elif name in self.objects and self.objects[name].objtype in objtypes:
                         newname = name
                     else:
                         # "fuzzy" searching mode
-                        # For attributes, only look within the same class or module
-                        # to avoid linking to unrelated attributes with the same name
-                        if type in ('attr', 'attribute') and (modname or classname):
-                            # For attributes, only look for exact matches within the current context
-                            if modname and classname:
-                                fullname = modname + '.' + classname + '.' + name
-                                if fullname in self.objects and self.objects[fullname].objtype in objtypes:
-                                    matches = [(fullname, self.objects[fullname])]
-                            elif modname:
-                                fullname = modname + '.' + name
-                                if fullname in self.objects and self.objects[fullname].objtype in objtypes:
-                                    matches = [(fullname, self.objects[fullname])]
-                            elif classname:
-                                fullname = classname + '.' + name
-                                if fullname in self.objects and self.objects[fullname].objtype in objtypes:
-                                    matches = [(fullname, self.objects[fullname])]
-                        else:
-                            # For other types, use the original fuzzy search
-                            searchname = '.' + name
-                            matches = [(oname, self.objects[oname]) for oname in self.objects
-                                      if oname.endswith(searchname) and
-                                      self.objects[oname].objtype in objtypes]
+                        searchname = '.' + name
+                        matches = [(oname, self.objects[oname]) for oname in self.objects
+                                   if oname.endswith(searchname) and
+                                   self.objects[oname].objtype in objtypes]
         else:
             # NOTE: searching for exact match, object type is not considered
-            
-            # For attributes with a class context, only match if the class context matches
-            if type == 'attr' and classname:
-                if modname and classname and modname + '.' + classname + '.' + name in self.objects:
-                    newname = modname + '.' + classname + '.' + name
-                elif classname and classname + '.' + name in self.objects:
-                    newname = classname + '.' + name
-            else:
-                # Original fallback logic for other types
-                if name in self.objects:
-                    newname = name
-                elif type == 'mod':
-                    # only exact matches allowed for modules
-                    return []
-                elif classname and classname + '.' + name in self.objects:
-                    newname = classname + '.' + name
-                elif modname and modname + '.' + name in self.objects:
-                    newname = modname + '.' + name
-                elif modname and classname and \
-                        modname + '.' + classname + '.' + name in self.objects:
-                    newname = modname + '.' + classname + '.' + name
+            if name in self.objects:
+                newname = name
+            elif type == 'mod':
+                # only exact matches allowed for modules
+                return []
+            elif classname and classname + '.' + name in self.objects:
+                newname = classname + '.' + name
+            elif modname and modname + '.' + name in self.objects:
+                newname = modname + '.' + name
+            elif modname and classname and \
+                    modname + '.' + classname + '.' + name in self.objects:
+                newname = modname + '.' + classname + '.' + name
         if newname is not None:
             matches.append((newname, self.objects[newname]))
         return matches
 
     def resolve_xref(self, env: BuildEnvironment, fromdocname: str, builder: Builder,
diff --git b/sphinx/environment/adapters/indexentries.py a/sphinx/environment/adapters/indexentries.py
index f3bcdd31b..e662bfe4a 100644
--- b/sphinx/environment/adapters/indexentries.py
+++ a/sphinx/environment/adapters/indexentries.py
@@ -37,28 +37,13 @@ class IndexEntries:
                       dic: Dict = new, key: str = None) -> None:
             # Force the word to be unicode if it's a ASCII bytestring.
             # This will solve problems with unicode normalization later.
             # For instance the RFC role will add bytestrings at the moment
             word = str(word)
-            
-            # For fully qualified names, use the full name as the key in the dictionary
-            # to avoid grouping attributes with the same name from different classes/modules
-            if '.' in word and not word.startswith('.'):
-                # This is a fully qualified name like 'module.class.attribute'
-                # Use the full name as the key to ensure uniqueness
-                dict_key = word
-                
-                # For attributes, we want to use the full name as the key to avoid grouping
-                # attributes with the same name from different classes/modules
-                if not key:
-                    key = word
-            else:
-                dict_key = word
-            
-            entry = dic.get(dict_key)
+            entry = dic.get(word)
             if not entry:
-                dic[dict_key] = entry = [[], {}, key]
+                dic[word] = entry = [[], {}, key]
             if subword:
                 add_entry(subword, '', main, link=link, dic=entry[1], key=key)
             elif link:
                 try:
                     uri = builder.get_relative_uri('genindex', fn) + '#' + tid
@@ -104,27 +89,10 @@ class IndexEntries:
         # sort the index entries for same keyword.
         def keyfunc0(entry: Tuple[str, str]) -> Tuple[bool, str]:
             main, uri = entry
             return (not main, uri)  # show main entries at first
 
-        # For fully qualified names, we want to create separate entries in the index
-        # to avoid grouping attributes with the same name from different classes/modules
-        new_entries = {}
-        for key, entry in list(new.items()):
-            if '.' in key and not key.startswith('.'):
-                # This is a fully qualified name, create a separate entry
-                # Use the full name as the key to ensure uniqueness
-                new_entries[key] = entry
-                # Use the last part of the name as the display name
-                display_name = key.split('.')[-1]
-                # If there's an entry with just the display name, remove it
-                if display_name in new and display_name != key:
-                    del new[display_name]
-        
-        # Add the new entries to the dictionary
-        new.update(new_entries)
-        
         for indexentry in new.values():
             indexentry[0].sort(key=keyfunc0)
             for subentry in indexentry[1].values():
                 subentry[0].sort(key=keyfunc0)  # type: ignore
 
@@ -132,19 +100,11 @@ class IndexEntries:
         def keyfunc(entry: Tuple[str, List]) -> Tuple[Tuple[int, str], str]:
             key, (void, void, category_key) = entry
             if category_key:
                 # using specified category key to sort
                 key = category_key
-            
-            # For display purposes, if the key contains dots (fully qualified name),
-            # use the last part for sorting
-            if '.' in key and not key.startswith('.'):
-                display_key = key.split('.')[-1]
-            else:
-                display_key = key
-                
-            lckey = unicodedata.normalize('NFD', display_key.lower())
+            lckey = unicodedata.normalize('NFD', key.lower())
             if lckey.startswith('\N{RIGHT-TO-LEFT MARK}'):
                 lckey = lckey[1:]
 
             if lckey[0:1].isalpha() or lckey.startswith('_'):
                 # put non-symbol characters at the folloing group (1)
@@ -168,18 +128,10 @@ class IndexEntries:
             oldkey = ''
             oldsubitems = None  # type: Dict[str, List]
             i = 0
             while i < len(newlist):
                 key, (targets, subitems, _key) = newlist[i]
-                
-                # Skip grouping for fully qualified names (attributes)
-                # to avoid grouping attributes with the same name from different classes/modules
-                if '.' in key and not key.startswith('.'):
-                    # This is a fully qualified name, don't group it
-                    i += 1
-                    continue
-                
                 # cannot move if it has subitems; structure gets too complex
                 if not subitems:
                     m = _fixre.match(key)
                     if m:
                         if oldkey == m.group(1):
diff --git b/sphinx/ext/autodoc/__init__.py a/sphinx/ext/autodoc/__init__.py
index 5bf65752c..f66852a34 100644
--- b/sphinx/ext/autodoc/__init__.py
+++ a/sphinx/ext/autodoc/__init__.py
@@ -2443,15 +2443,10 @@ class AttributeDocumenter(GenericAliasMixin, NewTypeMixin, SlotsMixin,  # type:
                 if self.options.no_value or self.should_suppress_value_header():
                     pass
                 else:
                     objrepr = object_description(self.object)
                     self.add_line('   :value: ' + objrepr, sourcename)
-                
-                # Add a unique index key for this attribute to prevent it from being grouped
-                # with other attributes of the same name in the index
-                if len(self.objpath) > 0:
-                    self.add_line('   :noindex_with_parent:', sourcename)
             except ValueError:
                 pass
 
     def get_attribute_comment(self, parent: Any, attrname: str) -> Optional[List[str]]:
         try:
diff --git b/sphinx/util/nodes.py a/sphinx/util/nodes.py
index 2e2c4147d..944fd3ecb 100644
--- b/sphinx/util/nodes.py
+++ a/sphinx/util/nodes.py
@@ -354,11 +354,11 @@ def split_explicit_title(text: str) -> Tuple[bool, str, str]:
         return True, match.group(1), match.group(2)
     return False, text, text
 
 
 indextypes = [
-    'single', 'pair', 'double', 'triple', 'see', 'seealso', 'attribute',
+    'single', 'pair', 'double', 'triple', 'see', 'seealso',
 ]
 
 
 def process_index_entry(entry: str, targetid: str) -> List[Tuple[str, str, str, str, str]]:
     from sphinx.domains.python import pairindextypes
@@ -392,20 +392,11 @@ def process_index_entry(entry: str, targetid: str) -> List[Tuple[str, str, str,
                 if value.startswith('!'):
                     main = 'main'
                     value = value[1:].lstrip()
                 if not value:
                     continue
-                
-                # For fully qualified names, use the full name as the index key
-                # to avoid grouping attributes with the same name from different classes/modules
-                if '.' in value and not value.startswith('.'):
-                    # This is a fully qualified name, use it as the index key
-                    index_key = value
-                else:
-                    index_key = None
-                
-                indexentries.append(('single', value, targetid, main, index_key))
+                indexentries.append(('single', value, targetid, main, None))
     return indexentries
 
 
 def inline_all_toctrees(builder: "Builder", docnameset: Set[str], docname: str,
                         tree: nodes.document, colorfunc: Callable, traversed: List[str]
