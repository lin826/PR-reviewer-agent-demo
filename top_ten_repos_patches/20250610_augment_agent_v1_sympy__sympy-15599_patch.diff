diff --git a/sympy/core/mod.py b/sympy/core/mod.py
index eae25630cc..2f937967e5 100644
--- a/sympy/core/mod.py
+++ b/sympy/core/mod.py
@@ -121,10 +121,48 @@ def doit(p, q):
             # separating into modulus and non modulus
             both_l = non_mod_l, mod_l = [], []
             for arg in p.args:
                 both_l[isinstance(arg, cls)].append(arg)
 
+            # Check if we can simplify by applying modular arithmetic to integer coefficients
+            # This handles cases like Mod(3*i, 2) -> Mod(i, 2)
+            if not mod_l:  # Only apply when there are no existing Mod terms
+                from sympy.core.numbers import Integer
+                
+                # Extract integer coefficients and other factors
+                integer_factors = []
+                other_factors = []
+                for arg in non_mod_l:
+                    if isinstance(arg, Integer):
+                        integer_factors.append(arg)
+                    else:
+                        other_factors.append(arg)
+                
+                # If we have integer factors, apply modular arithmetic
+                if integer_factors and isinstance(q, Integer):
+                    coeff_product = 1
+                    for factor in integer_factors:
+                        coeff_product *= factor
+                    
+                    # Apply modular arithmetic: (a*b) mod n = ((a mod n) * b) mod n
+                    new_coeff = coeff_product % q
+                    
+                    # If the coefficient becomes 0, the whole expression is 0
+                    if new_coeff == 0:
+                        return 0
+                    
+                    # Reconstruct the expression with the reduced coefficient
+                    if new_coeff == 1:
+                        new_p = Mul(*other_factors) if other_factors else 1
+                    else:
+                        new_p = Mul(new_coeff, *other_factors) if other_factors else new_coeff
+                    
+                    # Return the simplified form, but avoid infinite recursion
+                    # by checking if we're making progress
+                    if new_p != p:
+                        return cls(new_p, q)
+
             if mod_l and all(inner.args[1] == q for inner in mod_l):
                 # finding distributive term
                 non_mod_l = [cls(x, q) for x in non_mod_l]
                 mod = []
                 non_mod = []
