diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index 13a6809dd8..cd5fd0b74e 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -419,6 +419,12 @@ class Query(BaseExpression):
                 getattr(self.annotations[ref], "subquery", False)
                 for ref in aggregate.get_refs()
             )
+            # Check if any referenced annotations contain window functions
+            refs_subquery |= any(
+                getattr(self.annotations[ref], "contains_over_clause", False)
+                for ref in aggregate.get_refs()
+                if ref in self.annotations
+            )
             aggregate = aggregate.replace_expressions(replacements)
             self.annotations[alias] = aggregate
             replacements[Ref(alias, aggregate)] = aggregate
diff --git a/tests/expressions_window/tests.py b/tests/expressions_window/tests.py
index 3a02a36707..28ed491c85 100644
--- a/tests/expressions_window/tests.py
+++ b/tests/expressions_window/tests.py
@@ -1577,6 +1577,47 @@ class WindowFunctionTests(TestCase):
         with self.assertRaisesMessage(NotImplementedError, msg):
             list(qs.exclude(window=1, department="Accounting"))
 
+    def test_aggregate_over_window_function(self):
+        """
+        Test that aggregating over window function annotations works correctly.
+        This tests the fix for the issue where aggregating over window functions
+        would generate invalid SQL with nested window functions.
+        """
+        # Annotate with a window function
+        queryset = Employee.objects.annotate(
+            cumul_salary=Window(Sum("salary"), order_by=F("hire_date").asc())
+        )
+        
+        # This should work without raising "misuse of window function" error
+        result = queryset.aggregate(
+            total_salary=Sum("salary"),
+            total_cumul_salary=Sum("cumul_salary")
+        )
+        
+        # Verify the results are correct
+        self.assertEqual(result['total_salary'], 637000)
+        # The cumulative salary should be the sum of all cumulative values
+        self.assertIsNotNone(result['total_cumul_salary'])
+        self.assertGreater(result['total_cumul_salary'], result['total_salary'])
+
+    def test_multiple_window_function_aggregates(self):
+        """
+        Test aggregating over multiple window function annotations.
+        """
+        queryset = Employee.objects.annotate(
+            cumul_salary=Window(Sum("salary"), order_by=F("hire_date").asc()),
+            avg_salary_dept=Window(Avg("salary"), partition_by=F("department"))
+        )
+        
+        result = queryset.aggregate(
+            total_cumul=Sum("cumul_salary"),
+            avg_of_avg=Avg("avg_salary_dept")
+        )
+        
+        # Both should work without errors
+        self.assertIsNotNone(result['total_cumul'])
+        self.assertIsNotNone(result['avg_of_avg'])
+
 
 class WindowUnsupportedTests(TestCase):
     def test_unsupported_backend(self):
@@ -1664,3 +1705,5 @@ class NonQueryWindowTests(SimpleTestCase):
         msg = "Expression 'Upper' isn't compatible with OVER clauses."
         with self.assertRaisesMessage(ValueError, msg):
             Window(expression=Upper("name"))
+
+
