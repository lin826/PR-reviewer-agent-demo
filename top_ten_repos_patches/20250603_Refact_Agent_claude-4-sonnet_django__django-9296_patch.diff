diff --git a/django/core/paginator.py b/django/core/paginator.py
index 1f92da5d4f..896535d89a 100644
--- a/django/core/paginator.py
+++ b/django/core/paginator.py
@@ -106,6 +106,10 @@ class Paginator:
         """
         return range(1, self.num_pages + 1)
 
+    def __iter__(self):
+        for page_num in self.page_range:
+            yield self.page(page_num)
+
     def _check_object_list_is_ordered(self):
         """
         Warn if self.object_list is unordered (typically a QuerySet).
diff --git a/tests/pagination/tests.py b/tests/pagination/tests.py
index ef6e355e8d..b1745e4b65 100644
--- a/tests/pagination/tests.py
+++ b/tests/pagination/tests.py
@@ -2,7 +2,7 @@ import warnings
 from datetime import datetime
 
 from django.core.paginator import (
-    EmptyPage, InvalidPage, PageNotAnInteger, Paginator,
+    EmptyPage, InvalidPage, Page, PageNotAnInteger, Paginator,
     UnorderedObjectListWarning,
 )
 from django.test import SimpleTestCase, TestCase
@@ -265,6 +265,80 @@ class PaginationTests(SimpleTestCase):
         """
         self.assertIsInstance(Paginator([1, 2, 3], 2).page_range, type(range(0)))
 
+    def test_paginator_iteration(self):
+        """
+        Paginator should be iterable and yield Page objects.
+        """
+        paginator = Paginator([1, 2, 3, 4, 5, 6], 2)
+        pages = list(paginator)
+        
+        # Should yield the correct number of pages
+        self.assertEqual(len(pages), 3)
+        
+        # Each item should be a Page object
+        for page in pages:
+            self.assertIsInstance(page, Page)
+        
+        # Pages should have correct numbers and content
+        self.assertEqual(pages[0].number, 1)
+        self.assertEqual(list(pages[0].object_list), [1, 2])
+        
+        self.assertEqual(pages[1].number, 2)
+        self.assertEqual(list(pages[1].object_list), [3, 4])
+        
+        self.assertEqual(pages[2].number, 3)
+        self.assertEqual(list(pages[2].object_list), [5, 6])
+        
+        # Should produce same results as using page_range
+        traditional_pages = []
+        for page_num in paginator.page_range:
+            traditional_pages.append(paginator.page(page_num))
+        
+        # Compare page numbers and content
+        for iter_page, trad_page in zip(pages, traditional_pages):
+            self.assertEqual(iter_page.number, trad_page.number)
+            self.assertEqual(list(iter_page.object_list), list(trad_page.object_list))
+
+    def test_paginator_iteration_empty(self):
+        """
+        Test iteration over empty paginators.
+        """
+        # Empty paginator with allow_empty_first_page=True
+        paginator_empty = Paginator([], 5, allow_empty_first_page=True)
+        pages_empty = list(paginator_empty)
+        self.assertEqual(len(pages_empty), 1)
+        self.assertEqual(pages_empty[0].number, 1)
+        self.assertEqual(list(pages_empty[0].object_list), [])
+        
+        # Empty paginator with allow_empty_first_page=False
+        paginator_no_empty = Paginator([], 5, allow_empty_first_page=False)
+        pages_no_empty = list(paginator_no_empty)
+        self.assertEqual(len(pages_no_empty), 0)
+
+    def test_paginator_iteration_single_page(self):
+        """
+        Test iteration over single-page paginator.
+        """
+        paginator = Paginator([1, 2, 3], 10)
+        pages = list(paginator)
+        self.assertEqual(len(pages), 1)
+        self.assertEqual(pages[0].number, 1)
+        self.assertEqual(list(pages[0].object_list), [1, 2, 3])
+
+    def test_paginator_iteration_multiple_times(self):
+        """
+        Test that paginator can be iterated multiple times.
+        """
+        paginator = Paginator([1, 2, 3, 4], 2)
+        
+        first_iteration = list(paginator)
+        second_iteration = list(paginator)
+        
+        self.assertEqual(len(first_iteration), len(second_iteration))
+        for page1, page2 in zip(first_iteration, second_iteration):
+            self.assertEqual(page1.number, page2.number)
+            self.assertEqual(list(page1.object_list), list(page2.object_list))
+
     def test_get_page(self):
         """
         Paginator.get_page() returns a valid page even with invalid page
