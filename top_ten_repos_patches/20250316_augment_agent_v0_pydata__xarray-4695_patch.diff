diff --git a/xarray/core/coordinates.py b/xarray/core/coordinates.py
index 846e4044..0915f22c 100644
--- a/xarray/core/coordinates.py
+++ b/xarray/core/coordinates.py
@@ -392,12 +392,18 @@ def remap_label_indexers(
     v_indexers = {
         k: v.variable.data if isinstance(v, DataArray) else v
         for k, v in indexers.items()
     }
 
+    # Handle special case for dimensions named 'method' or 'tolerance'
+    # If 'method' is a dimension name in indexers, we need to pass None as method
+    # to avoid conflict with pandas get_loc/get_indexer parameters
+    dim_method = None if 'method' in v_indexers else method
+    dim_tolerance = None if 'tolerance' in v_indexers else tolerance
+    
     pos_indexers, new_indexes = indexing.remap_label_indexers(
-        obj, v_indexers, method=method, tolerance=tolerance
+        obj, v_indexers, method=dim_method, tolerance=dim_tolerance
     )
     # attach indexer's coordinate to pos_indexers
     for k, v in indexers.items():
         if isinstance(v, Variable):
             pos_indexers[k] = Variable(v.dims, pos_indexers[k])
diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py
index 32b24ef1..6ae573a5 100644
--- a/xarray/core/dataarray.py
+++ b/xarray/core/dataarray.py
@@ -194,11 +194,29 @@ class _LocIndexer:
     def __getitem__(self, key) -> "DataArray":
         if not utils.is_dict_like(key):
             # expand the indexer so we can handle Ellipsis
             labels = indexing.expanded_indexer(key, self.data_array.ndim)
             key = dict(zip(self.data_array.dims, labels))
-        return self.data_array.sel(**key)
+        
+        # Create a copy of the key dictionary to avoid modifying the original
+        indexers = dict(key)
+        
+        # Handle special case for dimensions named 'method' or 'tolerance'
+        # If 'method' is a dimension name in indexers, we need to extract it
+        # and pass it as a regular indexer, not as the method parameter
+        method_param = None
+        tolerance_param = None
+        
+        # Only pass method/tolerance parameters if they are not dimension names
+        if 'method' not in self.data_array.dims:
+            method_param = None
+        
+        if 'tolerance' not in self.data_array.dims:
+            tolerance_param = None
+            
+        return self.data_array.sel(indexers=indexers, method=method_param, 
+                                  tolerance=tolerance_param, drop=False)
 
     def __setitem__(self, key, value) -> None:
         if not utils.is_dict_like(key):
             # expand the indexer so we can handle Ellipsis
             labels = indexing.expanded_indexer(key, self.data_array.ndim)
diff --git a/xarray/core/dataset.py b/xarray/core/dataset.py
index dbac288c..6b8ace7b 100644
--- a/xarray/core/dataset.py
+++ b/xarray/core/dataset.py
@@ -2226,12 +2226,19 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):
         --------
         Dataset.isel
         DataArray.sel
         """
         indexers = either_dict_or_kwargs(indexers, indexers_kwargs, "sel")
+        
+        # Handle special case for dimensions named 'method' or 'tolerance'
+        # If 'method' is a dimension name in indexers, we need to pass None as method
+        # to avoid conflict with pandas get_loc/get_indexer parameters
+        dim_method = None if 'method' in indexers and 'method' in self.dims else method
+        dim_tolerance = None if 'tolerance' in indexers and 'tolerance' in self.dims else tolerance
+        
         pos_indexers, new_indexes = remap_label_indexers(
-            self, indexers=indexers, method=method, tolerance=tolerance
+            self, indexers=indexers, method=dim_method, tolerance=dim_tolerance
         )
         result = self.isel(indexers=pos_indexers, drop=drop)
         return result._overwrite_indexes(new_indexes)
 
     def head(
diff --git a/xarray/core/indexing.py b/xarray/core/indexing.py
index 843feb04..bd84945b 100644
--- a/xarray/core/indexing.py
+++ b/xarray/core/indexing.py
@@ -93,16 +93,21 @@ def _is_nested_tuple(possible_tuple):
     return isinstance(possible_tuple, tuple) and any(
         isinstance(value, (tuple, list, slice)) for value in possible_tuple
     )
 
 
-def get_indexer_nd(index, labels, method=None, tolerance=None):
+def get_indexer_nd(index, labels, method=None, tolerance=None, index_name=None):
     """Wrapper around :meth:`pandas.Index.get_indexer` supporting n-dimensional
     labels
     """
     flat_labels = np.ravel(labels)
-    flat_indexer = index.get_indexer(flat_labels, method=method, tolerance=tolerance)
+    # Special case for dimensions named 'method' or 'tolerance'
+    # to avoid conflict with pandas get_indexer parameters
+    if index_name == 'method' or index_name == 'tolerance':
+        flat_indexer = index.get_indexer(flat_labels)
+    else:
+        flat_indexer = index.get_indexer(flat_labels, method=method, tolerance=tolerance)
     indexer = flat_indexer.reshape(labels.shape)
     return indexer
 
 
 def convert_label_indexer(index, label, index_name="", method=None, tolerance=None):
@@ -186,20 +191,25 @@ def convert_label_indexer(index, label, index_name="", method=None, tolerance=No
                     raise ValueError(
                         "'tolerance' is not a valid kwarg when indexing using a CategoricalIndex."
                     )
                 indexer = index.get_loc(label_value)
             else:
-                indexer = index.get_loc(label_value, method=method, tolerance=tolerance)
+                # Special case for dimensions named 'method' or 'tolerance'
+                # to avoid conflict with pandas get_loc parameters
+                if index_name == 'method' or index_name == 'tolerance':
+                    indexer = index.get_loc(label_value)
+                else:
+                    indexer = index.get_loc(label_value, method=method, tolerance=tolerance)
         elif label.dtype.kind == "b":
             indexer = label
         else:
             if isinstance(index, pd.MultiIndex) and label.ndim > 1:
                 raise ValueError(
                     "Vectorized selection is not available along "
                     "MultiIndex variable: " + index_name
                 )
-            indexer = get_indexer_nd(index, label, method, tolerance)
+            indexer = get_indexer_nd(index, label, method, tolerance, index_name)
             if np.any(indexer < 0):
                 raise KeyError(f"not all values found in index {index_name!r}")
     return indexer, new_index
 
 
@@ -265,11 +275,14 @@ def remap_label_indexers(data_obj, indexers, method=None, tolerance=None):
                 )
             pos_indexers[dim] = label
         else:
             coords_dtype = data_obj.coords[dim].dtype
             label = maybe_cast_to_coords_dtype(label, coords_dtype)
-            idxr, new_idx = convert_label_indexer(index, label, dim, method, tolerance)
+            # Pass None as method/tolerance if dim matches to avoid conflict
+            dim_method = None if dim == 'method' else method
+            dim_tolerance = None if dim == 'tolerance' else tolerance
+            idxr, new_idx = convert_label_indexer(index, label, dim, dim_method, dim_tolerance)
             pos_indexers[dim] = idxr
             if new_idx is not None:
                 new_indexes[dim] = new_idx
 
     return pos_indexers, new_indexes
