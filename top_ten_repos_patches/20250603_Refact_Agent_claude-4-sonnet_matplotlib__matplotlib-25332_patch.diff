diff --git a/lib/matplotlib/cbook.py b/lib/matplotlib/cbook.py
index c9699b2e21..8ff1ced160 100644
--- a/lib/matplotlib/cbook.py
+++ b/lib/matplotlib/cbook.py
@@ -846,6 +846,81 @@ class Grouper:
         siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])
         return [x() for x in siblings]
 
+    def __getstate__(self):
+        """
+        Convert weak references to strong references for pickling.
+        
+        This method is called during pickling to prepare the object state.
+        Since weak references cannot be pickled, we convert them to strong
+        references while preserving the grouping relationships.
+        """
+        self.clean()  # Remove any dead weak references first
+        
+        # Convert the mapping from weak refs to strong refs
+        strong_mapping = {}
+        for weak_key, weak_list in self._mapping.items():
+            strong_key = weak_key()
+            if strong_key is not None:  # Only include live references
+                strong_list = []
+                for weak_ref in weak_list:
+                    strong_obj = weak_ref()
+                    if strong_obj is not None:
+                        strong_list.append(strong_obj)
+                if strong_list:  # Only include non-empty groups
+                    strong_mapping[strong_key] = strong_list
+        
+        return {'strong_mapping': strong_mapping}
+
+    def __setstate__(self, state):
+        """
+        Convert strong references back to weak references after unpickling.
+        
+        This method is called during unpickling to restore the object state.
+        We rebuild the weak reference mapping from the strong references
+        that were saved during pickling.
+        """
+        strong_mapping = state['strong_mapping']
+        self._mapping = {}
+        
+        # Rebuild the weak reference mapping
+        for strong_key, strong_list in strong_mapping.items():
+            weak_key = weakref.ref(strong_key)
+            weak_list = [weakref.ref(obj) for obj in strong_list]
+            self._mapping[weak_key] = weak_list
+            
+            # Ensure all objects in the same group point to the same list
+            for weak_ref in weak_list:
+                self._mapping[weak_ref] = weak_list
+
+    def __getstate__(self):
+        """Convert weak references to strong references for pickling."""
+        # Convert the _mapping from weak refs to strong refs
+        strong_mapping = {}
+        for weak_key, weak_value_list in self._mapping.items():
+            strong_key = weak_key()  # Get the actual object
+            if strong_key is not None:  # Only if the object still exists
+                strong_value_list = []
+                for weak_value in weak_value_list:
+                    strong_value = weak_value()
+                    if strong_value is not None:
+                        strong_value_list.append(strong_value)
+                if strong_value_list:  # Only if we have valid objects
+                    strong_mapping[strong_key] = strong_value_list
+        return {'_mapping': strong_mapping}
+
+    def __setstate__(self, state):
+        """Convert strong references back to weak references after unpickling."""
+        strong_mapping = state['_mapping']
+        weak_mapping = {}
+        for strong_key, strong_value_list in strong_mapping.items():
+            weak_key = weakref.ref(strong_key)
+            weak_value_list = [weakref.ref(obj) for obj in strong_value_list]
+            weak_mapping[weak_key] = weak_value_list
+            # Make sure all items in the list point to the same list object
+            for weak_value in weak_value_list:
+                weak_mapping[weak_value] = weak_value_list
+        self._mapping = weak_mapping
+
 
 class GrouperView:
     """Immutable view over a `.Grouper`."""
diff --git a/lib/matplotlib/tests/test_figure.py b/lib/matplotlib/tests/test_figure.py
index 80d80f9691..109b860983 100644
--- a/lib/matplotlib/tests/test_figure.py
+++ b/lib/matplotlib/tests/test_figure.py
@@ -83,6 +83,51 @@ def test_align_labels_stray_axes():
     np.testing.assert_allclose(xn[:2], xn[2:])
     np.testing.assert_allclose(yn[::2], yn[1::2])
 
+
+def test_pickle_figure_after_align_labels():
+    """
+    Test that figures can be pickled after calling align_labels().
+    
+    This is a regression test for the issue where figures became
+    unpicklable after calling align_labels() due to weak references
+    in the Grouper objects.
+    """
+    import pickle
+    
+    # Create figure with subplots as in the original bug report
+    fig = plt.figure()
+    ax1 = fig.add_subplot(211)
+    ax2 = fig.add_subplot(212)
+    
+    time = [0, 1, 2, 3, 4]
+    speed = [40000, 4300, 4500, 4700, 4800]
+    acc = [10, 11, 12, 13, 14]
+    
+    ax1.plot(time, speed)
+    ax1.set_ylabel('speed')
+    ax2.plot(time, acc)
+    ax2.set_ylabel('acc')
+
+    # This used to break pickling
+    fig.align_labels()
+    
+    # Test that the figure can be pickled
+    pickled_data = pickle.dumps(fig)
+    
+    # Test that it can be unpickled
+    unpickled_fig = pickle.loads(pickled_data)
+    
+    # Verify the structure is preserved
+    assert len(unpickled_fig.axes) == 2
+    assert unpickled_fig.axes[0].get_ylabel() == 'speed'
+    assert unpickled_fig.axes[1].get_ylabel() == 'acc'
+    
+    # Test that align_labels still works on unpickled figure
+    unpickled_fig.align_labels()
+    
+    # Test that it can be pickled again
+    pickle.dumps(unpickled_fig)
+
     fig, axs = plt.subplots(2, 2, constrained_layout=True)
     for nn, ax in enumerate(axs.flat):
         ax.set_xlabel('Boo')
