diff --git a/sklearn/ensemble/_iforest.py b/sklearn/ensemble/_iforest.py
index 4d6c1c3f0..a5e8d4b18 100644
--- a/sklearn/ensemble/_iforest.py
+++ b/sklearn/ensemble/_iforest.py
@@ -345,10 +345,36 @@ class IsolationForest(OutlierMixin, BaseBagging):
             return self
 
         # else, define offset_ wrt contamination parameter
-        self.offset_ = np.percentile(self.score_samples(X), 100.0 * self.contamination)
+        self.offset_ = np.percentile(self._score_samples_fit(X), 100.0 * self.contamination)
 
         return self
 
+    def _score_samples_fit(self, X):
+        """
+        Internal method to compute score samples during fit without feature name validation.
+        
+        This method is used internally during fit() when contamination != "auto" to avoid
+        spurious feature name warnings when the same DataFrame is used for fitting.
+        
+        Parameters
+        ----------
+        X : {array-like, sparse matrix} of shape (n_samples, n_features)
+            The input samples that were already validated during fit().
+            
+        Returns
+        -------
+        scores : ndarray of shape (n_samples,)
+            The anomaly score of the input samples.
+        """
+        check_is_fitted(self)
+        
+        # Skip _validate_data to avoid feature name validation since X was already
+        # validated during fit() and we're in the same fit() call
+        X = check_array(X, accept_sparse="csr", dtype=np.float32)
+        
+        # Take the opposite of the scores as bigger is better (here less abnormal)
+        return -self._compute_chunked_score_samples(X)
+
     def predict(self, X):
         """
         Predict if a particular sample is an outlier or not.
