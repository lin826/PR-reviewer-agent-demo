diff --git a/xarray/coding/variables.py b/xarray/coding/variables.py
index b035ff82..f4d144af 100644
--- a/xarray/coding/variables.py
+++ b/xarray/coding/variables.py
@@ -316,6 +316,42 @@ class UnsignedIntegerCoder(VariableCoder):
                     if "_FillValue" in attrs:
                         new_fill = unsigned_dtype.type(attrs["_FillValue"])
                         attrs["_FillValue"] = new_fill
+            elif data.dtype.kind == "u" and unsigned == "false":
+                # Handle the case where pydap returns unsigned integer values for byte data
+                # with _Unsigned=false. This is a hack to handle the OPeNDAP convention
+                # for signed bytes, which are represented as unsigned bytes in OPeNDAP
+                # but should be interpreted as signed.
+                signed_dtype = np.dtype("i%s" % data.dtype.itemsize)
+                
+                def convert_unsigned_to_signed(values):
+                    # Convert unsigned values to signed values using view
+                    # This matches the behavior of netCDF-C with _Unsigned=false
+                    return np.asarray(values).view(signed_dtype)
+                
+                transform = convert_unsigned_to_signed
+                data = lazy_elemwise_func(data, transform, signed_dtype)
+                if "_FillValue" in attrs:
+                    new_fill = signed_dtype.type(attrs["_FillValue"])
+                    attrs["_FillValue"] = new_fill
+            elif data.dtype.kind == "f" and unsigned == "false":
+                # Handle the case where pydap returns float values for byte data
+                # with _Unsigned=false. This is a hack to handle the OPeNDAP convention
+                # for signed bytes, which are represented as unsigned bytes in OPeNDAP
+                # but should be interpreted as signed.
+                def convert_unsigned_to_signed(values):
+                    # Convert values in the range [128, 255] to [-128, -1]
+                    # Keep values in the range [0, 127] as is
+                    # This matches the behavior of netCDF-C with _Unsigned=false
+                    values = np.asarray(values)
+                    result = values.copy()
+                    # Find values that appear to be in the unsigned byte range [128, 255]
+                    mask = (values >= 128) & (values <= 255)
+                    # Convert these to their signed equivalents [-128, -1]
+                    result[mask] = values[mask] - 256
+                    return result
+                
+                transform = convert_unsigned_to_signed
+                data = lazy_elemwise_func(data, transform, data.dtype)
             else:
                 warnings.warn(
                     "variable %r has _Unsigned attribute but is not "
