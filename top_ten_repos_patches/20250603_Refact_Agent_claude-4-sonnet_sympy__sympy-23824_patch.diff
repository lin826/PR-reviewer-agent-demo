diff --git a/sympy/physics/hep/gamma_matrices.py b/sympy/physics/hep/gamma_matrices.py
index 23284e4a92..9b0c8e5a2e 100644
--- a/sympy/physics/hep/gamma_matrices.py
+++ b/sympy/physics/hep/gamma_matrices.py
@@ -695,7 +695,7 @@ def kahane_simplify(expression):
     # If `first_dum_pos` is not zero, it means that there are trailing free gamma
     # matrices in front of `expression`, so multiply by them:
     for i in range(0, first_dum_pos):
-        [ri.insert(0, free_pos[i]) for ri in resulting_indices]
+        [ri.insert(i, free_pos[i]) for ri in resulting_indices]
 
     resulting_expr = S.Zero
     for i in resulting_indices:
diff --git a/sympy/physics/hep/tests/test_gamma_matrices.py b/sympy/physics/hep/tests/test_gamma_matrices.py
index 27509803f2..1b80f81133 100644
--- a/sympy/physics/hep/tests/test_gamma_matrices.py
+++ b/sympy/physics/hep/tests/test_gamma_matrices.py
@@ -399,3 +399,38 @@ def test_gamma_matrix_trace():
     t = ps*ps*ps*ps*ps*ps*ps*ps
     r = gamma_trace(t)
     assert r.equals(4*p2*p2*p2*p2)
+
+
+def test_kahane_leading_gamma_matrix_order():
+    """
+    Test that kahane_simplify preserves the order of leading uncontracted gamma matrices.
+    
+    This is a regression test for the bug where leading gamma matrices were
+    incorrectly reversed when contracted matrices appeared at the end.
+    """
+    mu, nu, rho, sigma, alpha, beta, gamma = tensor_indices(
+        "mu, nu, rho, sigma, alpha, beta, gamma", LorentzIndex)
+    
+    # Test case 1: Two leading free matrices with contraction at end
+    t = G(rho)*G(sigma)*G(mu)*G(-mu)
+    r = kahane_simplify(t)
+    expected = 4*G(rho)*G(sigma)
+    assert r.equals(expected), f"Expected {expected}, got {r}"
+    
+    # Test case 2: Three leading free matrices with contraction at end
+    t = G(alpha)*G(beta)*G(gamma)*G(mu)*G(-mu)
+    r = kahane_simplify(t)
+    expected = 4*G(alpha)*G(beta)*G(gamma)
+    assert r.equals(expected), f"Expected {expected}, got {r}"
+    
+    # Test case 3: Contraction in middle should also preserve order
+    t = G(rho)*G(mu)*G(-mu)*G(sigma)
+    r = kahane_simplify(t)
+    expected = 4*G(rho)*G(sigma)
+    assert r.equals(expected), f"Expected {expected}, got {r}"
+    
+    # Test case 4: Complex case with multiple free matrices around contraction
+    t = G(alpha)*G(beta)*G(mu)*G(-mu)*G(gamma)*G(sigma)
+    r = kahane_simplify(t)
+    expected = 4*G(alpha)*G(beta)*G(gamma)*G(sigma)
+    assert r.equals(expected), f"Expected {expected}, got {r}"
