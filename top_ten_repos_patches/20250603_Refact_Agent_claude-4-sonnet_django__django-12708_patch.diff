diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py
index 61f88401ab..1f521cfc5c 100644
--- a/django/db/backends/base/schema.py
+++ b/django/db/backends/base/schema.py
@@ -393,7 +393,7 @@ class BaseDatabaseSchemaEditor:
         news = {tuple(fields) for fields in new_index_together}
         # Deleted indexes
         for fields in olds.difference(news):
-            self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)
+            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)
         # Created indexes
         for field_names in news.difference(olds):
             fields = [model._meta.get_field(field) for field in field_names]
diff --git a/tests/schema/tests.py b/tests/schema/tests.py
index 9aa1e239ac..a4cc7b0e3a 100644
--- a/tests/schema/tests.py
+++ b/tests/schema/tests.py
@@ -2184,6 +2184,58 @@ class SchemaTests(TransactionTestCase):
         with connection.schema_editor() as editor:
             editor.alter_index_together(Book, [['author', 'title']], [])
 
+    @isolate_apps('schema')
+    def test_index_together_with_unique_together_same_fields(self):
+        """
+        Tests that deleting index_together works when unique_together exists
+        on the same fields. Regression test for issue where both constraints
+        were found when looking for index constraints to delete.
+        """
+        class TestModel(Model):
+            field1 = CharField(max_length=100)
+            field2 = CharField(max_length=100)
+            
+            class Meta:
+                app_label = 'schema'
+                unique_together = [('field1', 'field2')]
+                index_together = [('field1', 'field2')]
+
+        self.isolated_local_models = [TestModel]
+
+        # Create the table with both constraints
+        with connection.schema_editor() as editor:
+            editor.create_model(TestModel)
+
+        # Verify both constraints exist
+        constraints = self.get_constraints(TestModel._meta.db_table)
+        field_constraints = [
+            details for details in constraints.values()
+            if details['columns'] == ['field1', 'field2']
+        ]
+        
+        index_constraints = [c for c in field_constraints if c['index'] and not c['unique']]
+        unique_constraints = [c for c in field_constraints if c['unique']]
+        
+        self.assertEqual(len(index_constraints), 1, "Should have one index constraint")
+        self.assertEqual(len(unique_constraints), 1, "Should have one unique constraint")
+
+        # This should not raise an error (was failing before the fix)
+        with connection.schema_editor() as editor:
+            editor.alter_index_together(TestModel, [('field1', 'field2')], [])
+
+        # Verify only the index constraint was deleted
+        constraints = self.get_constraints(TestModel._meta.db_table)
+        field_constraints = [
+            details for details in constraints.values()
+            if details['columns'] == ['field1', 'field2']
+        ]
+        
+        index_constraints = [c for c in field_constraints if c['index'] and not c['unique']]
+        unique_constraints = [c for c in field_constraints if c['unique']]
+        
+        self.assertEqual(len(index_constraints), 0, "Index constraint should be deleted")
+        self.assertEqual(len(unique_constraints), 1, "Unique constraint should remain")
+
     def test_create_index_together(self):
         """
         Tests creating models with index_together already defined
