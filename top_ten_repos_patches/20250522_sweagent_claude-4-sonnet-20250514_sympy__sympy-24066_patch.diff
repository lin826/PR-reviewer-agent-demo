diff --git a/sympy/physics/units/unitsystem.py b/sympy/physics/units/unitsystem.py
index 3daf84c108..563db7323d 100644
--- a/sympy/physics/units/unitsystem.py
+++ b/sympy/physics/units/unitsystem.py
@@ -192,8 +192,61 @@ def _collect_factor_and_dimension(self, expr):
         elif isinstance(expr, Function):
             fds = [self._collect_factor_and_dimension(
                 arg) for arg in expr.args]
-            return (expr.func(*(f[0] for f in fds)),
-                    *(d[1] for d in fds))
+            factors = [f[0] for f in fds]
+            dimensions = [d[1] for d in fds]
+            
+            # For most mathematical functions, if all arguments are dimensionless,
+            # the result should be dimensionless
+            from sympy.functions.elementary.exponential import ExpBase, log
+            from sympy.functions.elementary.trigonometric import TrigonometricFunction, InverseTrigonometricFunction
+            from sympy.functions.elementary.hyperbolic import HyperbolicFunction, InverseHyperbolicFunction
+            from sympy.functions.elementary.miscellaneous import sqrt
+            from sympy.functions.elementary.complexes import Abs, re, im, arg, conjugate
+            
+            # Check if this is a function that should return dimensionless result
+            # when given dimensionless arguments
+            dimensionless_functions = (
+                ExpBase,  # exp, exp_polar
+                TrigonometricFunction,  # sin, cos, tan, sec, csc, cot, sinc
+                InverseTrigonometricFunction,  # asin, acos, atan, asec, acsc, acot
+                HyperbolicFunction,  # sinh, cosh, tanh, coth, sech, csch
+                InverseHyperbolicFunction,  # asinh, acosh, atanh, acoth, asech, acsch
+            )
+            
+            # Special case: log always returns dimensionless
+            if isinstance(expr, log):
+                return expr.func(*factors), Dimension(1)
+            
+            # For dimensionless functions, check if all arguments are dimensionless
+            if isinstance(expr, dimensionless_functions):
+                if all(self.get_dimension_system().is_dimensionless(d) for d in dimensions):
+                    return expr.func(*factors), Dimension(1)
+                else:
+                    # If arguments are not dimensionless, this is an error for most functions
+                    # But we'll let it pass through for now and let other validation catch it
+                    pass
+            
+            # For functions like Abs, re, im, the result has the same dimension as the argument
+            if isinstance(expr, (Abs, re, im)):
+                if len(dimensions) == 1:
+                    return expr.func(*factors), dimensions[0]
+            
+            # For sqrt and other power-like functions
+            if expr.func == sqrt:
+                if len(dimensions) == 1:
+                    return expr.func(*factors), dimensions[0] ** S.Half
+            
+            # Default case: if we don't know how to handle this function,
+            # we'll assume it preserves the dimension of its first argument
+            # This is a fallback that may not be correct for all functions
+            if len(dimensions) == 1:
+                return expr.func(*factors), dimensions[0]
+            elif len(dimensions) == 0:
+                return expr.func(*factors), Dimension(1)
+            else:
+                # Multiple arguments - this is complex, for now return the first dimension
+                # This may need more sophisticated handling for specific functions
+                return expr.func(*factors), dimensions[0]
         elif isinstance(expr, Dimension):
             return S.One, expr
         else:
