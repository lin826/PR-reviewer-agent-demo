diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py
index a44adfc760..c52e6c8258 100644
--- a/django/db/models/sql/compiler.py
+++ b/django/db/models/sql/compiler.py
@@ -425,7 +425,11 @@ class SQLCompiler:
                 # If the columns list is limited, then all combined queries
                 # must have the same columns list. Set the selects defined on
                 # the query on all combined queries, if not already set.
-                if not compiler.query.values_select and self.query.values_select:
+                if self.query.values_select and (
+                    not compiler.query.values_select or
+                    (compiler.query.model == self.query.model and
+                     tuple(compiler.query.values_select) != tuple(self.query.values_select))
+                ):
                     compiler.query.set_values((
                         *self.query.extra_select,
                         *self.query.values_select,
diff --git a/tests/queries/test_qs_combinators.py b/tests/queries/test_qs_combinators.py
index 3902db59e2..cc42c7ba33 100644
--- a/tests/queries/test_qs_combinators.py
+++ b/tests/queries/test_qs_combinators.py
@@ -220,6 +220,49 @@ class QuerySetSetOperationTests(TestCase):
         # switched order, now 'exists' again:
         list(qs2.union(qs1).order_by('num'))
 
+    def test_union_values_list_multiple_calls(self):
+        """
+        Test that multiple values_list() calls on union queries work correctly.
+        Regression test for issue where composed queries couldn't change the
+        list of columns when values()/values_list() was evaluated multiple times.
+        """
+        ReservedName.objects.create(name='first', order=1)
+        ReservedName.objects.create(name='second', order=2)
+        qs = ReservedName.objects.all()
+        
+        # First call with multiple columns
+        result1 = list(qs.union(qs).values_list('name', 'order'))
+        expected1 = [('first', 1), ('second', 2)]
+        self.assertEqual(result1, expected1)
+        
+        # Second call with single column should only return that column
+        result2 = list(qs.union(qs).values_list('order'))
+        expected2 = [(1,), (2,)]
+        self.assertEqual(result2, expected2)
+        
+        # Third call with different single column
+        result3 = list(qs.union(qs).values_list('name'))
+        expected3 = [('first',), ('second',)]
+        self.assertEqual(result3, expected3)
+
+    def test_union_values_multiple_calls(self):
+        """
+        Test that multiple values() calls on union queries work correctly.
+        """
+        ReservedName.objects.create(name='first', order=1)
+        ReservedName.objects.create(name='second', order=2)
+        qs = ReservedName.objects.all()
+        
+        # First call with multiple columns
+        result1 = list(qs.union(qs).values('name', 'order'))
+        expected1 = [{'name': 'first', 'order': 1}, {'name': 'second', 'order': 2}]
+        self.assertEqual(result1, expected1)
+        
+        # Second call with single column should only return that column
+        result2 = list(qs.union(qs).values('order'))
+        expected2 = [{'order': 1}, {'order': 2}]
+        self.assertEqual(result2, expected2)
+
     @skipUnlessDBFeature('supports_select_difference', 'supports_select_intersection')
     def test_qs_with_subcompound_qs(self):
         qs1 = Number.objects.all()
