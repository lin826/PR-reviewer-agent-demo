diff --git a/astropy/utils/introspection.py b/astropy/utils/introspection.py
index 3e784f9fc3..4b7235d3c5 100644
--- a/astropy/utils/introspection.py
+++ b/astropy/utils/introspection.py
@@ -6,7 +6,15 @@
 import inspect
 import types
 import importlib
-from distutils.version import LooseVersion
+
+# Try to use packaging.version.parse for robust version comparison
+try:
+    from packaging.version import parse as parse_version
+    HAS_PACKAGING = True
+except ImportError:
+    HAS_PACKAGING = False
+    # Fallback to distutils.version.LooseVersion with error handling
+    from distutils.version import LooseVersion
 
 
 __all__ = ['resolve_name', 'minversion', 'find_current_module',
@@ -88,6 +96,61 @@ def resolve_name(name, *additional_parts):
     return ret
 
 
+def _fallback_version_compare(have_version, required_version, inclusive=True):
+    """
+    Fallback version comparison when LooseVersion fails due to mixed int/str types.
+    
+    This handles the case where LooseVersion cannot compare versions like 
+    '1.14.3' vs '1.14dev' due to Python 3's restriction on comparing int and str.
+    """
+    import re
+    
+    def normalize_version(version_str):
+        """
+        Normalize a version string for comparison by extracting numeric parts
+        and handling common suffixes like 'dev', 'rc', 'alpha', 'beta'.
+        """
+        # Extract the main numeric version
+        numeric_match = re.match(r'^(\d+(?:\.\d+)*)', version_str)
+        if not numeric_match:
+            # If no numeric part found, treat as 0.0.0
+            numeric_part = '0.0.0'
+            suffix = version_str
+        else:
+            numeric_part = numeric_match.group(1)
+            suffix = version_str[len(numeric_part):]
+        
+        # Convert numeric part to tuple of integers for comparison
+        numeric_tuple = tuple(int(x) for x in numeric_part.split('.'))
+        
+        # Normalize suffix for comparison
+        # Development versions are considered less than release versions
+        suffix = suffix.lower().strip()
+        if suffix.startswith('dev') or suffix.startswith('.dev'):
+            suffix_priority = -1  # dev versions are less than release
+        elif suffix.startswith('rc') or suffix.startswith('.rc'):
+            suffix_priority = -0.5  # rc versions are less than release but more than dev
+        elif suffix.startswith('alpha') or suffix.startswith('.alpha') or suffix.startswith('a'):
+            suffix_priority = -0.8
+        elif suffix.startswith('beta') or suffix.startswith('.beta') or suffix.startswith('b'):
+            suffix_priority = -0.6
+        elif suffix == '' or suffix.startswith('final') or suffix.startswith('.final'):
+            suffix_priority = 0  # release version
+        else:
+            # Unknown suffix, treat as release version
+            suffix_priority = 0
+            
+        return numeric_tuple, suffix_priority
+    
+    have_norm = normalize_version(have_version)
+    required_norm = normalize_version(required_version)
+    
+    if inclusive:
+        return have_norm >= required_norm
+    else:
+        return have_norm > required_norm
+
+
 def minversion(module, version, inclusive=True, version_path='__version__'):
     """
     Returns `True` if the specified Python module satisfies a minimum version
@@ -139,10 +202,25 @@ def minversion(module, version, inclusive=True, version_path='__version__'):
     else:
         have_version = resolve_name(module.__name__, version_path)
 
-    if inclusive:
-        return LooseVersion(have_version) >= LooseVersion(version)
+    # Use packaging.version.parse if available, otherwise fall back to LooseVersion
+    # with error handling for the known bug with mixed int/str comparisons
+    if HAS_PACKAGING:
+        if inclusive:
+            return parse_version(have_version) >= parse_version(version)
+        else:
+            return parse_version(have_version) > parse_version(version)
     else:
-        return LooseVersion(have_version) > LooseVersion(version)
+        # Use LooseVersion with error handling for the Python 3 bug
+        try:
+            if inclusive:
+                return LooseVersion(have_version) >= LooseVersion(version)
+            else:
+                return LooseVersion(have_version) > LooseVersion(version)
+        except TypeError:
+            # Handle the case where LooseVersion fails due to mixed int/str comparison
+            # This happens when comparing versions like '1.14.3' vs '1.14dev'
+            # Fall back to a simple string-based comparison after normalizing
+            return _fallback_version_compare(have_version, version, inclusive)
 
 
 def find_current_module(depth=1, finddiff=False):
diff --git a/astropy/utils/tests/test_introspection.py b/astropy/utils/tests/test_introspection.py
index d8262d4581..816867c2a5 100644
--- a/astropy/utils/tests/test_introspection.py
+++ b/astropy/utils/tests/test_introspection.py
@@ -73,3 +73,48 @@ def test_minversion():
         assert minversion(test_module, version)
     for version in bad_versions:
         assert not minversion(test_module, version)
+
+
+def test_minversion_dev_versions():
+    """
+    Test minversion with development versions that previously caused
+    TypeError due to LooseVersion bug with mixed int/str comparisons.
+    
+    This tests the fix for issue #7671 where comparing versions like
+    '1.14.3' vs '1.14dev' would fail with TypeError.
+    """
+    from types import ModuleType
+    
+    # Test the original failing case from the issue
+    test_module = ModuleType("test_module")
+    test_module.__version__ = '1.14.3'
+    
+    # This should not raise TypeError and should return True
+    assert minversion(test_module, '1.14dev')
+    
+    # Test various combinations that were problematic
+    test_cases = [
+        # (module_version, required_version, expected_result, inclusive)
+        ('1.14.3', '1.14dev', True, True),    # Original failing case
+        ('1.15.1', '1.15dev', True, True),    # Another failing case
+        ('1.14.0', '1.14dev', True, True),    # Release vs dev
+        ('1.13.9', '1.14dev', False, True),   # Older version vs dev
+        ('1.15.0', '1.15rc1', True, True),    # Release vs rc
+        ('1.15.0', '1.15alpha1', True, True), # Release vs alpha
+        ('1.15.0', '1.15beta1', True, True),  # Release vs beta
+        ('1.15rc2', '1.15rc1', True, True),   # rc vs rc
+        ('1.15rc1', '1.15rc2', False, True),  # rc vs rc (reverse)
+        ('1.15dev', '1.14.9', True, True),    # dev vs release
+        ('1.14dev', '1.15.0', False, True),   # dev vs higher release
+        ('1.14.0', '1.14.0', True, True),     # Equal, inclusive
+        ('1.14.0', '1.14.0', False, False),   # Equal, exclusive
+        ('1.14.1', '1.14.0', True, False),    # Greater, exclusive
+    ]
+    
+    for module_version, required_version, expected_result, inclusive in test_cases:
+        test_module.__version__ = module_version
+        result = minversion(test_module, required_version, inclusive=inclusive)
+        assert result == expected_result, (
+            f"minversion('{module_version}', '{required_version}', inclusive={inclusive}) "
+            f"returned {result}, expected {expected_result}"
+        )
