diff --git a/xarray/core/weighted.py b/xarray/core/weighted.py
index 996d2e4c..f7249c86 100644
--- a/xarray/core/weighted.py
+++ b/xarray/core/weighted.py
@@ -142,7 +142,13 @@ class Weighted:
         # we need to mask data values that are nan; else the weights are wrong
         mask = da.notnull()
 
-        sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
+        # Convert boolean weights to numeric to avoid boolean arithmetic in dot product
+        # When both mask and weights are boolean, dot product returns boolean instead of sum
+        weights = self.weights
+        if weights.dtype == bool:
+            weights = weights.astype(int)
+
+        sum_of_weights = self._reduce(mask, weights, dim=dim, skipna=False)
 
         # 0-weights are not valid
         valid_weights = sum_of_weights != 0.0
diff --git a/xarray/tests/test_weighted.py b/xarray/tests/test_weighted.py
index 24531215..4b012528 100644
--- a/xarray/tests/test_weighted.py
+++ b/xarray/tests/test_weighted.py
@@ -309,3 +309,107 @@ def test_weighted_operations_keep_attr_da_in_ds(operation):
     result = getattr(data.weighted(weights), operation)(keep_attrs=True)
 
     assert data.a.attrs == result.a.attrs
+
+
+@pytest.mark.parametrize("as_dataset", (True, False))
+def test_weighted_boolean_weights(as_dataset):
+    """Test that boolean weights work correctly (GH issue)"""
+    
+    # Test case from the original issue
+    data = DataArray([1., 1., 1.])
+    weights = DataArray([True, True, False])
+    
+    if as_dataset:
+        data = data.to_dataset(name="data")
+    
+    # Test weighted mean
+    result = data.weighted(weights).mean()
+    expected = DataArray(1.0)
+    if as_dataset:
+        expected = expected.to_dataset(name="data")
+    
+    assert_equal(expected, result)
+    
+    # Test sum of weights
+    sum_weights = data.weighted(weights).sum_of_weights()
+    expected_sum = DataArray(2.0)
+    if as_dataset:
+        expected_sum = expected_sum.to_dataset(name="data")
+    
+    assert_equal(expected_sum, sum_weights)
+    
+    # Test weighted sum
+    weighted_sum = data.weighted(weights).sum()
+    expected_weighted_sum = DataArray(2.0)
+    if as_dataset:
+        expected_weighted_sum = expected_weighted_sum.to_dataset(name="data")
+    
+    assert_equal(expected_weighted_sum, weighted_sum)
+
+
+@pytest.mark.parametrize("as_dataset", (True, False))
+@pytest.mark.parametrize(
+    ("data_vals", "weight_vals", "expected_mean", "expected_sum_weights"),
+    [
+        # All True weights
+        ([1., 2., 3.], [True, True, True], 2.0, 3.0),
+        # All False weights  
+        ([1., 2., 3.], [False, False, False], np.nan, np.nan),
+        # Mixed weights
+        ([1., 2., 3.], [True, False, True], 2.0, 2.0),
+        ([2., 4., 6.], [True, True, False], 3.0, 2.0),
+        # Single True weight
+        ([1., 2., 3.], [False, True, False], 2.0, 1.0),
+        # With NaN data
+        ([np.nan, 2., 3.], [True, True, True], 2.5, 2.0),
+        ([1., np.nan, 3.], [True, True, True], 2.0, 2.0),
+    ]
+)
+def test_weighted_boolean_weights_comprehensive(as_dataset, data_vals, weight_vals, expected_mean, expected_sum_weights):
+    """Comprehensive test for boolean weights with various patterns"""
+    
+    data = DataArray(data_vals)
+    weights = DataArray(weight_vals)
+    
+    if as_dataset:
+        data = data.to_dataset(name="data")
+    
+    # Test sum of weights
+    sum_weights = data.weighted(weights).sum_of_weights()
+    expected_sum = DataArray(expected_sum_weights)
+    if as_dataset:
+        expected_sum = expected_sum.to_dataset(name="data")
+    
+    assert_equal(expected_sum, sum_weights)
+    
+    # Test weighted mean
+    result = data.weighted(weights).mean()
+    expected = DataArray(expected_mean)
+    if as_dataset:
+        expected = expected.to_dataset(name="data")
+    
+    assert_equal(expected, result)
+
+
+def test_weighted_boolean_weights_mixed_dtypes():
+    """Test boolean weights with different data dtypes"""
+    
+    # Integer data with boolean weights
+    data_int = DataArray([1, 2, 3])
+    weights_bool = DataArray([True, True, False])
+    
+    result = data_int.weighted(weights_bool).mean()
+    expected = DataArray(1.5)
+    assert_equal(expected, result)
+    
+    # Float data with boolean weights (original issue case)
+    data_float = DataArray([1., 1., 1.])
+    result = data_float.weighted(weights_bool).mean()
+    expected = DataArray(1.0)
+    assert_equal(expected, result)
+    
+    # Complex data with boolean weights
+    data_complex = DataArray([1+0j, 2+0j, 3+0j])
+    result = data_complex.weighted(weights_bool).mean()
+    expected = DataArray(1.5+0j)
+    assert_equal(expected, result)
