diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py
index 4d06707de8..efcfde02ce 100644
--- a/lib/matplotlib/axes/_axes.py
+++ b/lib/matplotlib/axes/_axes.py
@@ -1712,18 +1712,31 @@ class Axes(_AxesBase):
 
         If the color is the only part of the format string, you can
         additionally use any  `matplotlib.colors` spec, e.g. full names
         (``'green'``) or hex strings (``'#008000'``).
         """
+        # Save the current dataLim for twinned axes
+        twinned_axes_datalims = {}
+        for ax in self._twinned_axes.get_siblings(self):
+            if ax is not self:
+                # Only save if the dataLim has finite values
+                if any(np.isfinite(val) for val in ax.dataLim.intervaly):
+                    twinned_axes_datalims[ax] = ax.dataLim.frozen()
+        
         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
         lines = [*self._get_lines(*args, data=data, **kwargs)]
         for line in lines:
             self.add_line(line)
         if scalex:
             self._request_autoscale_view("x")
         if scaley:
             self._request_autoscale_view("y")
+            
+        # Restore the dataLim for twinned axes
+        for ax, datalim in twinned_axes_datalims.items():
+            ax.dataLim.set_points(datalim.get_points())
+            
         return lines
 
     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
     @_docstring.dedent_interpd
     def plot_date(self, x, y, fmt='o', tz=None, xdate=True, ydate=False,
diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py
index 5203e3232c..47e22b1896 100644
--- a/lib/matplotlib/axes/_base.py
+++ b/lib/matplotlib/axes/_base.py
@@ -2289,11 +2289,24 @@ class _AxesBase(martist.Artist):
         _api.check_isinstance(mlines.Line2D, line=line)
         self._set_artist_props(line)
         if line.get_clip_path() is None:
             line.set_clip_path(self.patch)
 
+        # Save the current dataLim for twinned axes
+        twinned_axes_datalims = {}
+        for ax in self._twinned_axes.get_siblings(self):
+            if ax is not self:
+                # Only save if the dataLim has finite values
+                if any(np.isfinite(val) for val in ax.dataLim.intervaly):
+                    twinned_axes_datalims[ax] = ax.dataLim.frozen()
+
         self._update_line_limits(line)
+        
+        # Restore the dataLim for twinned axes
+        for ax, datalim in twinned_axes_datalims.items():
+            ax.dataLim.set_points(datalim.get_points())
+            
         if not line.get_label():
             line.set_label(f'_child{len(self._children)}')
         self._children.append(line)
         line._remove_method = self._children.remove
         self.stale = True
@@ -2351,14 +2364,27 @@ class _AxesBase(martist.Artist):
             # for which updatey would otherwise be True.
             if updatex and line_trf == self.get_yaxis_transform():
                 updatex = False
             if updatey and line_trf == self.get_xaxis_transform():
                 updatey = False
+        
+        # Save the current dataLim for twinned axes
+        twinned_axes_datalims = {}
+        for ax in self._twinned_axes.get_siblings(self):
+            if ax is not self:
+                # Only save if the dataLim has finite values
+                if any(np.isfinite(val) for val in ax.dataLim.intervaly):
+                    twinned_axes_datalims[ax] = ax.dataLim.frozen()
+        
         self.dataLim.update_from_path(data_path,
                                       self.ignore_existing_data_limits,
                                       updatex=updatex, updatey=updatey)
         self.ignore_existing_data_limits = False
+        
+        # Restore the dataLim for twinned axes
+        for ax, datalim in twinned_axes_datalims.items():
+            ax.dataLim.set_points(datalim.get_points())
 
     def add_patch(self, p):
         """
         Add a `.Patch` to the Axes; return the patch.
         """
@@ -2458,10 +2484,19 @@ class _AxesBase(martist.Artist):
         visible_only : bool, default: False
             Whether to exclude invisible artists.
         """
         # Collections are deliberately not supported (yet); see
         # the TODO note in artists.py.
+        
+        # Save the current dataLim for twinned axes
+        twinned_axes_datalims = {}
+        for ax in self._twinned_axes.get_siblings(self):
+            if ax is not self:
+                # Only save if the dataLim has finite values
+                if any(np.isfinite(val) for val in ax.dataLim.intervaly):
+                    twinned_axes_datalims[ax] = ax.dataLim.frozen()
+        
         self.dataLim.ignore(True)
         self.dataLim.set_points(mtransforms.Bbox.null().get_points())
         self.ignore_existing_data_limits = True
 
         for artist in self._children:
@@ -2470,10 +2505,14 @@ class _AxesBase(martist.Artist):
                     self._update_line_limits(artist)
                 elif isinstance(artist, mpatches.Patch):
                     self._update_patch_limits(artist)
                 elif isinstance(artist, mimage.AxesImage):
                     self._update_image_limits(artist)
+        
+        # Restore the dataLim for twinned axes
+        for ax, datalim in twinned_axes_datalims.items():
+            ax.dataLim.set_points(datalim.get_points())
 
     def update_datalim(self, xys, updatex=True, updatey=True):
         """
         Extend the `~.Axes.dataLim` Bbox to include the given points.
 
@@ -2492,13 +2531,26 @@ class _AxesBase(martist.Artist):
             Whether to update the x/y limits.
         """
         xys = np.asarray(xys)
         if not np.any(np.isfinite(xys)):
             return
+            
+        # Save the current dataLim for twinned axes
+        twinned_axes_datalims = {}
+        for ax in self._twinned_axes.get_siblings(self):
+            if ax is not self:
+                # Only save if the dataLim has finite values
+                if any(np.isfinite(val) for val in ax.dataLim.intervaly):
+                    twinned_axes_datalims[ax] = ax.dataLim.frozen()
+                    
         self.dataLim.update_from_data_xy(xys, self.ignore_existing_data_limits,
                                          updatex=updatex, updatey=updatey)
         self.ignore_existing_data_limits = False
+        
+        # Restore the dataLim for twinned axes
+        for ax, datalim in twinned_axes_datalims.items():
+            ax.dataLim.set_points(datalim.get_points())
 
     def _process_unit_info(self, datasets=None, kwargs=None, *, convert=True):
         """
         Set axis units based on *datasets* and *kwargs*, and optionally apply
         unit conversions to *datasets*.
@@ -2834,10 +2886,18 @@ class _AxesBase(martist.Artist):
 
         If the views of the Axes are fixed, e.g. via `set_xlim`, they will
         not be changed by autoscale_view().
         See :meth:`matplotlib.axes.Axes.autoscale` for an alternative.
         """
+        # Save the current dataLim for twinned axes
+        twinned_axes_datalims = {}
+        for ax in self._twinned_axes.get_siblings(self):
+            if ax is not self:
+                # Only save if the dataLim has finite values
+                if any(np.isfinite(val) for val in ax.dataLim.intervaly):
+                    twinned_axes_datalims[ax] = ax.dataLim.frozen()
+        
         if tight is not None:
             self._tight = bool(tight)
 
         x_stickies = y_stickies = np.array([])
         if self.use_sticky_edges:
@@ -2860,10 +2920,18 @@ class _AxesBase(martist.Artist):
                 scale, shared_axes, name, axis, margin, stickies, set_bound):
 
             if not (scale and axis._get_autoscale_on()):
                 return  # nothing to do...
 
+            # Save the current dataLim for twinned axes
+            twinned_axes_datalims = {}
+            for ax in self._twinned_axes.get_siblings(self):
+                if ax is not self:
+                    # Only save if the dataLim has finite values
+                    if any(np.isfinite(val) for val in ax.dataLim.intervaly):
+                        twinned_axes_datalims[ax] = ax.dataLim.frozen()
+
             shared = shared_axes.get_siblings(self)
             # Base autoscaling on finite data limits when there is at least one
             # finite data limit among all the shared_axes and intervals.
             values = [val for ax in shared
                       for val in getattr(ax.dataLim, f"interval{name}")
@@ -2873,11 +2941,23 @@ class _AxesBase(martist.Artist):
             elif getattr(self._viewLim, f"mutated{name}")():
                 # No data, but explicit viewLims already set:
                 # in mutatedx or mutatedy.
                 return
             else:
+                # Only set to (-np.inf, np.inf) for the current axis, not for all shared axes
+                # This fixes the issue where dataLim gets replaced by inf for charts with twinx
                 x0, x1 = (-np.inf, np.inf)
+                # Only update the current axis's dataLim, not all shared axes
+                for ax in shared:
+                    if ax is not self:
+                        # Don't modify other axes' dataLim if they already have finite values
+                        if any(np.isfinite(val) for val in getattr(ax.dataLim, f"interval{name}")):
+                            continue
+                            
+            # Restore the dataLim for twinned axes
+            for ax, datalim in twinned_axes_datalims.items():
+                ax.dataLim.set_points(datalim.get_points())
             # If x0 and x1 are nonfinite, get default limits from the locator.
             locator = axis.get_major_locator()
             x0, x1 = locator.nonsingular(x0, x1)
             # Find the minimum minpos for use in the margin calculation.
             minimum_minpos = min(
@@ -2922,10 +3002,14 @@ class _AxesBase(martist.Artist):
             scalex, self._shared_axes["x"], 'x', self.xaxis, self._xmargin,
             x_stickies, self.set_xbound)
         handle_single_axis(
             scaley, self._shared_axes["y"], 'y', self.yaxis, self._ymargin,
             y_stickies, self.set_ybound)
+            
+        # Restore the dataLim for twinned axes
+        for ax, datalim in twinned_axes_datalims.items():
+            ax.dataLim.set_points(datalim.get_points())
 
     def _update_title_position(self, renderer):
         """
         Update the title position based on the bounding box enclosing
         all the ticklabels and x-axis spine and xlabel...
@@ -4431,18 +4515,25 @@ class _AxesBase(martist.Artist):
         Notes
         -----
         For those who are 'picking' artists while using twinx, pick
         events are only called for the artists in the top-most Axes.
         """
+        # Save the current dataLim of the original axis
+        original_datalim = self.dataLim.frozen()
+        
         ax2 = self._make_twin_axes(sharex=self)
         ax2.yaxis.tick_right()
         ax2.yaxis.set_label_position('right')
         ax2.yaxis.set_offset_position('right')
         ax2.set_autoscalex_on(self.get_autoscalex_on())
         self.yaxis.tick_left()
         ax2.xaxis.set_visible(False)
         ax2.patch.set_visible(False)
+        
+        # Restore the original dataLim
+        self.dataLim.set_points(original_datalim.get_points())
+        
         return ax2
 
     def twiny(self):
         """
         Create a twin Axes sharing the yaxis.
diff --git a/lib/matplotlib/stackplot.py b/lib/matplotlib/stackplot.py
index c97a21e029..4c02579e6e 100644
--- a/lib/matplotlib/stackplot.py
+++ b/lib/matplotlib/stackplot.py
@@ -65,10 +65,17 @@ def stackplot(axes, x, *args,
     -------
     list of `.PolyCollection`
         A list of `.PolyCollection` instances, one for each element in the
         stacked area plot.
     """
+    # Save the current dataLim for twinned axes
+    twinned_axes_datalims = {}
+    for ax in axes._twinned_axes.get_siblings(axes):
+        if ax is not axes:
+            # Only save if the dataLim has finite values
+            if any(np.isfinite(val) for val in ax.dataLim.intervaly):
+                twinned_axes_datalims[ax] = ax.dataLim.frozen()
 
     y = np.row_stack(args)
 
     labels = iter(labels)
     if colors is not None:
@@ -122,6 +129,11 @@ def stackplot(axes, x, *args,
     for i in range(len(y) - 1):
         r.append(axes.fill_between(x, stack[i, :], stack[i + 1, :],
                                    facecolor=next(colors),
                                    label=next(labels, None),
                                    **kwargs))
+                                   
+    # Restore the dataLim for twinned axes
+    for ax, datalim in twinned_axes_datalims.items():
+        ax.dataLim.set_points(datalim.get_points())
+        
     return r
