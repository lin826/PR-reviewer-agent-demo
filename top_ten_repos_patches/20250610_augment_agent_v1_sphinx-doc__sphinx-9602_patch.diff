diff --git b/sphinx/ext/autodoc/typehints.py a/sphinx/ext/autodoc/typehints.py
index e86ffbe4d..af4b47bb0 100644
--- b/sphinx/ext/autodoc/typehints.py
+++ a/sphinx/ext/autodoc/typehints.py
@@ -28,13 +28,13 @@ def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,
             annotations = app.env.temp_data.setdefault('annotations', {})
             annotation = annotations.setdefault(name, OrderedDict())
             sig = inspect.signature(obj, type_aliases=app.config.autodoc_type_aliases)
             for param in sig.parameters.values():
                 if param.annotation is not param.empty:
-                    annotation[param.name] = typing.restify(param.annotation)
+                    annotation[param.name] = typing.stringify(param.annotation)
             if sig.return_annotation is not sig.empty:
-                annotation['return'] = typing.restify(sig.return_annotation)
+                annotation['return'] = typing.stringify(sig.return_annotation)
     except (TypeError, ValueError):
         pass
 
 
 def merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -> None:
diff --git b/sphinx/util/inspect.py a/sphinx/util/inspect.py
index 15db3b568..d55ebceec 100644
--- b/sphinx/util/inspect.py
+++ a/sphinx/util/inspect.py
@@ -27,48 +27,11 @@ from typing import Any, Callable, Dict, Mapping, Optional, Sequence, Tuple, Type
 from sphinx.deprecation import RemovedInSphinx50Warning
 from sphinx.pycode.ast import ast  # for py36-37
 from sphinx.pycode.ast import unparse as ast_unparse
 from sphinx.util import logging
 from sphinx.util.typing import ForwardRef
-from sphinx.util.typing import restify, stringify
-
-
-def stringify_annotation(annotation):
-    """Convert type annotation to string, with special handling for Literal types."""
-    # Use stringify but with special post-processing for Literal types
-    result = stringify(annotation)
-    
-    # If the result contains Literal with quoted values, we need to be careful
-    # The issue is that when this gets parsed as reStructuredText, the quoted
-    # values inside Literal[...] are treated as potential cross-references
-    # We need to escape them or mark them as literal text
-    
-    import re
-    
-    # Pattern to match Literal[...] with quoted strings
-    literal_pattern = r'Literal\[([^\]]+)\]'
-    
-    def escape_literal_contents(match):
-        contents = match.group(1)
-        # Replace all potential cross-reference targets with escaped versions
-        # This prevents them from being treated as cross-references
-        
-        # Handle quoted strings
-        escaped_contents = re.sub(r"'([^']*)'", r"``'\1'``", contents)
-        escaped_contents = re.sub(r'"([^"]*)"', r'``"\1"``', escaped_contents)
-        
-        # Handle boolean literals
-        escaped_contents = re.sub(r'\bTrue\b', r'``True``', escaped_contents)
-        escaped_contents = re.sub(r'\bFalse\b', r'``False``', escaped_contents)
-        
-        # Handle integer literals (but be careful not to escape parts of other identifiers)
-        escaped_contents = re.sub(r'\b(\d+)\b', r'``\1``', escaped_contents)
-        
-        return f'Literal[{escaped_contents}]'
-    
-    result = re.sub(literal_pattern, escape_literal_contents, result)
-    return result
+from sphinx.util.typing import stringify as stringify_annotation
 
 if sys.version_info > (3, 7):
     from types import ClassMethodDescriptorType, MethodDescriptorType, WrapperDescriptorType
 else:
     ClassMethodDescriptorType = type(object.__init__)
diff --git b/sphinx/util/typing.py a/sphinx/util/typing.py
index 10b615618..cf4318cda 100644
--- b/sphinx/util/typing.py
+++ a/sphinx/util/typing.py
@@ -107,17 +107,11 @@ def is_system_TypeVar(typ: Any) -> bool:
 def restify(cls: Optional[Type]) -> str:
     """Convert python class to a reST reference."""
     from sphinx.util import inspect  # lazy loading
 
     try:
-        if isinstance(cls, str):
-            if cls.startswith("'") and cls.endswith("'"):
-                # might be a double Forward-ref'ed type.  Go unquoting.
-                return cls[1:-1]
-            else:
-                return cls
-        elif cls is None or cls is NoneType:
+        if cls is None or cls is NoneType:
             return ':obj:`None`'
         elif cls is Ellipsis:
             return '...'
         elif cls in INVALID_BUILTIN_CLASSES:
             return ':class:`%s`' % INVALID_BUILTIN_CLASSES[cls]
