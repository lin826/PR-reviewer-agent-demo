diff --git a/sympy/sets/sets.py b/sympy/sets/sets.py
index 3c4aa86e36..ea2fb62bdf 100644
--- a/sympy/sets/sets.py
+++ b/sympy/sets/sets.py
@@ -842,6 +842,32 @@ def __iter__(self):
         then return the Cartesian Product. Otherwise, raise TypeError.
         """
         return iproduct(*self.sets)
+        
+    def _eval_is_subset(self, other):
+        """
+        Returns True if self is a subset of other, False if it is not, and
+        None if the comparison is indeterminate.
+        """
+        if other.is_ProductSet and len(self.sets) == len(other.sets):
+            # For ProductSets with the same number of factors, 
+            # check if each factor is a subset of the corresponding factor
+            return fuzzy_and(s1.is_subset(s2) for s1, s2 in zip(self.sets, other.sets))
+        
+        if other.is_FiniteSet:
+            # An infinite ProductSet cannot be a subset of a FiniteSet
+            if fuzzy_not(self.is_finite_set):
+                return False
+                
+            # If both are finite, check if all elements of self are in other
+            if self.is_iterable:
+                return fuzzy_and(other._contains(e) for e in self)
+                
+        if other.is_Union:
+            # self is a subset of Union(X, Y, ...) if it's a subset of any of X, Y, ...
+            return fuzzy_or(self.is_subset(s) for s in other.args)
+            
+        # For other cases, let the general subset algorithm handle it
+        return None
 
     @property
     def is_empty(self):
