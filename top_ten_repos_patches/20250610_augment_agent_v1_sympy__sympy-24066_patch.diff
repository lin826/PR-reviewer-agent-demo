diff --git a/sympy/physics/units/unitsystem.py b/sympy/physics/units/unitsystem.py
index 3daf84c108..dedf639067 100644
--- a/sympy/physics/units/unitsystem.py
+++ b/sympy/physics/units/unitsystem.py
@@ -190,12 +190,40 @@ def _collect_factor_and_dimension(self, expr):
                 dim /= idim**count
             return factor, dim
         elif isinstance(expr, Function):
             fds = [self._collect_factor_and_dimension(
                 arg) for arg in expr.args]
-            return (expr.func(*(f[0] for f in fds)),
-                    *(d[1] for d in fds))
+            factors = [f[0] for f in fds]
+            dims = [f[1] for f in fds]
+            
+            # List of mathematical functions that require dimensionless arguments
+            # and return dimensionless results
+            dimensionless_functions = {
+                'exp', 'exp2', 'expm1', 'log', 'ln', 'log10', 'log2',
+                'sin', 'cos', 'tan', 'sec', 'csc', 'cot',
+                'asin', 'acos', 'atan', 'asec', 'acsc', 'acot', 'atan2',
+                'sinh', 'cosh', 'tanh', 'sech', 'csch', 'coth',
+                'asinh', 'acosh', 'atanh', 'asech', 'acsch', 'acoth'
+            }
+            
+            func_name = expr.func.__name__
+            if func_name in dimensionless_functions:
+                # These functions require dimensionless arguments and return dimensionless results
+                if all(self.get_dimension_system().is_dimensionless(dim) for dim in dims):
+                    return expr.func(*factors), Dimension(1)
+                else:
+                    raise ValueError(f"Function {func_name} requires dimensionless arguments")
+            else:
+                # For other functions, use the original logic but fix the return format
+                # Check if all arguments are dimensionless
+                if all(self.get_dimension_system().is_dimensionless(dim) for dim in dims):
+                    return expr.func(*factors), Dimension(1)
+                else:
+                    # For functions with dimensional arguments, we need more sophisticated logic
+                    # For now, return the function with the first argument's dimension
+                    # This is a fallback that maintains backward compatibility
+                    return expr.func(*factors), dims[0] if dims else Dimension(1)
         elif isinstance(expr, Dimension):
             return S.One, expr
         else:
             return expr, Dimension(1)
 
