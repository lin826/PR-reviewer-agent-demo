diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py
index b8efb9f881..00c9663d19 100644
--- a/django/utils/autoreload.py
+++ b/django/utils/autoreload.py
@@ -216,14 +216,18 @@ def get_child_arguments():
     executable is reported to not have the .exe extension which can cause bugs
     on reloading.
     """
-    import django.__main__
-    django_main_path = Path(django.__main__.__file__)
     py_script = Path(sys.argv[0])
 
     args = [sys.executable] + ['-W%s' % o for o in sys.warnoptions]
-    if py_script == django_main_path:
-        # The server was started with `python -m django runserver`.
-        args += ['-m', 'django']
+    
+    # Check if Python was launched with -m by examining __main__.__spec__
+    main_module = sys.modules['__main__']
+    if (hasattr(main_module, '__spec__') and 
+        main_module.__spec__ is not None and 
+        main_module.__spec__.parent and
+        py_script.name == '__main__.py'):
+        # Python was started with -m <package>
+        args += ['-m', main_module.__spec__.parent]
         args += sys.argv[1:]
     elif not py_script.exists():
         # sys.argv[0] may not exist for several reasons on Windows.
diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py
index b9f2db7276..145c91b74e 100644
--- a/tests/utils_tests/test_autoreload.py
+++ b/tests/utils_tests/test_autoreload.py
@@ -202,6 +202,78 @@ class TestChildArguments(SimpleTestCase):
         with self.assertRaisesMessage(RuntimeError, msg):
             autoreload.get_child_arguments()
 
+    @mock.patch('sys.warnoptions', [])
+    def test_run_as_non_django_module(self):
+        """Test detection of -m usage for packages other than Django."""
+        # Mock __main__.__spec__ to simulate python -m test_pkg
+        class MockSpec:
+            def __init__(self, name, parent):
+                self.name = name
+                self.parent = parent
+        
+        original_spec = getattr(sys.modules['__main__'], '__spec__', None)
+        try:
+            sys.modules['__main__'].__spec__ = MockSpec('test_pkg.__main__', 'test_pkg')
+            with mock.patch('sys.argv', ['/some/path/test_pkg/__main__.py', 'runserver']):
+                self.assertEqual(
+                    autoreload.get_child_arguments(),
+                    [sys.executable, '-m', 'test_pkg', 'runserver']
+                )
+        finally:
+            if original_spec is not None:
+                sys.modules['__main__'].__spec__ = original_spec
+            else:
+                if hasattr(sys.modules['__main__'], '__spec__'):
+                    delattr(sys.modules['__main__'], '__spec__')
+
+    @mock.patch('sys.warnoptions', [])
+    def test_run_as_nested_module(self):
+        """Test detection of -m usage for nested packages."""
+        # Mock __main__.__spec__ to simulate python -m myapp.management
+        class MockSpec:
+            def __init__(self, name, parent):
+                self.name = name
+                self.parent = parent
+        
+        original_spec = getattr(sys.modules['__main__'], '__spec__', None)
+        try:
+            sys.modules['__main__'].__spec__ = MockSpec('myapp.management.__main__', 'myapp.management')
+            with mock.patch('sys.argv', ['/some/path/myapp/management/__main__.py', 'runserver']):
+                self.assertEqual(
+                    autoreload.get_child_arguments(),
+                    [sys.executable, '-m', 'myapp.management', 'runserver']
+                )
+        finally:
+            if original_spec is not None:
+                sys.modules['__main__'].__spec__ = original_spec
+            else:
+                if hasattr(sys.modules['__main__'], '__spec__'):
+                    delattr(sys.modules['__main__'], '__spec__')
+
+    @mock.patch('sys.warnoptions', [])
+    def test_no_module_detection_for_non_main_script(self):
+        """Test that -m is not detected for scripts that are not __main__.py."""
+        # Mock __main__.__spec__ but use a script name that's not __main__.py
+        class MockSpec:
+            def __init__(self, name, parent):
+                self.name = name
+                self.parent = parent
+        
+        original_spec = getattr(sys.modules['__main__'], '__spec__', None)
+        try:
+            sys.modules['__main__'].__spec__ = MockSpec('some_module', 'some_package')
+            with mock.patch('sys.argv', [__file__, 'runserver']):
+                self.assertEqual(
+                    autoreload.get_child_arguments(),
+                    [sys.executable, __file__, 'runserver']
+                )
+        finally:
+            if original_spec is not None:
+                sys.modules['__main__'].__spec__ = original_spec
+            else:
+                if hasattr(sys.modules['__main__'], '__spec__'):
+                    delattr(sys.modules['__main__'], '__spec__')
+
 
 class TestUtilities(SimpleTestCase):
     def test_is_django_module(self):
