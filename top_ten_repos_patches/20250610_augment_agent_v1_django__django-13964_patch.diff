diff --git a/django/db/models/base.py b/django/db/models/base.py
index 2428218696..bfa403e968 100644
--- a/django/db/models/base.py
+++ b/django/db/models/base.py
@@ -931,18 +931,18 @@ class Model(metaclass=ModelBase):
                         field.remote_field.delete_cached_value(obj)
                     raise ValueError(
                         "%s() prohibited to prevent data loss due to unsaved "
                         "related object '%s'." % (operation_name, field.name)
                     )
-                elif getattr(self, field.attname) is None:
-                    # Use pk from related object if it has been saved after
-                    # an assignment.
+                # Use pk from related object if it has been saved after an assignment
+                # or if the current foreign key value doesn't match the related object's pk
+                elif (getattr(self, field.attname) is None or 
+                      getattr(obj, field.target_field.attname) != getattr(self, field.attname)):
                     setattr(self, field.attname, obj.pk)
-                # If the relationship's pk/to_field was changed, clear the
-                # cached relationship.
-                if getattr(obj, field.target_field.attname) != getattr(self, field.attname):
-                    field.delete_cached_value(self)
+                    # If the relationship's pk/to_field was changed, clear the cached relationship.
+                    if field.is_cached(self):
+                        field.delete_cached_value(self)
 
     def delete(self, using=None, keep_parents=False):
         using = using or router.db_for_write(self.__class__, instance=self)
         assert self.pk is not None, (
             "%s object can't be deleted because its %s attribute is set to None." %
diff --git a/tests/model_fields/test_foreignkey.py b/tests/model_fields/test_foreignkey.py
index d30cca9b5c..4985ab75d7 100644
--- a/tests/model_fields/test_foreignkey.py
+++ b/tests/model_fields/test_foreignkey.py
@@ -145,5 +145,42 @@ class ForeignKeyTests(TestCase):
             "'model_fields.Related.child' refers to field 'key' which is not "
             "local to model 'model_fields.Child'."
         )
         with self.assertRaisesMessage(FieldError, msg):
             Related._meta.get_field('child').related_fields
+
+    def test_foreign_key_update_on_save_with_non_auto_pk(self):
+        """
+        Test that foreign key fields are updated when the related object's
+        primary key changes after assignment, specifically for non-auto primary keys.
+        
+        This tests the fix for the issue where assigning an empty instance to a
+        foreign key and then setting the primary key later would result in the
+        foreign key field not being updated.
+        """
+        # Create instances - this is the problematic case
+        fk_to_char = FkToChar()
+        char_model = PrimaryKeyCharModel()  # Empty model with no string set
+        
+        # Assign the empty model to the foreign key
+        fk_to_char.out = char_model
+        
+        # At this point, fk_to_char.out_id should be empty string
+        self.assertEqual(fk_to_char.out_id, '')
+        
+        # Now set the string on the char model
+        char_model.string = "test-str"
+        char_model.save()
+        
+        # The foreign key field should still be empty at this point
+        self.assertEqual(fk_to_char.out_id, '')
+        
+        # When we save the fk_to_char, the foreign key should be updated
+        fk_to_char.save()
+        
+        # Now the foreign key field should match the char model's string
+        self.assertEqual(fk_to_char.out_id, "test-str")
+        
+        # Verify that queries work correctly
+        self.assertTrue(FkToChar.objects.filter(out_id="test-str").exists())
+        self.assertTrue(FkToChar.objects.filter(out=char_model).exists())
+        self.assertFalse(FkToChar.objects.filter(out_id="").exists())
