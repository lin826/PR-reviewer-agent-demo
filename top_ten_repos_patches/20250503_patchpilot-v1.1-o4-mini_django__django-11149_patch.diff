diff --git a/django/contrib/admin/forms.py b/django/contrib/admin/forms.py
index e973c61972..1998798861 100644
--- a/django/contrib/admin/forms.py
+++ b/django/contrib/admin/forms.py
@@ -27,4 +27,4 @@ class AdminAuthenticationForm(AuthenticationForm):
 
 
 class AdminPasswordChangeForm(PasswordChangeForm):
-    required_css_class = 'required'
+    required_css_class = 'required'
diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py
index 880a2cc17b..c671dd77a0 100644
--- a/django/contrib/admin/options.py
+++ b/django/contrib/admin/options.py
@@ -2105,39 +2105,73 @@ class InlineModelAdmin(BaseModelAdmin):
     def _get_form_for_get_fields(self, request, obj=None):
         return self.get_formset(request, obj, fields=None).form
 
+
     def get_queryset(self, request):
         queryset = super().get_queryset(request)
         if not self.has_view_or_change_permission(request):
             queryset = queryset.none()
         return queryset
 
+    def _get_m2m_target_opts(self):
+        """
+        Return the _meta of the target model for an auto‑created intermediary
+        model used by a ManyToManyField. The target model is the one that is
+        not the parent model of this inline. If the inline model isn't
+        auto‑created or the target cannot be determined, default to the parent
+        model's _meta.
+        """
+        if self.opts.auto_created:
+            for field in self.opts.fields:
+                remote_field = getattr(field, 'remote_field', None)
+                if remote_field and remote_field.model is not self.parent_model:
+                    return remote_field.model._meta
+        return self.parent_model._meta
+
+
+
+
     def has_add_permission(self, request, obj):
         if self.opts.auto_created:
-            # We're checking the rights to an auto-created intermediate model,
-            # which doesn't have its own individual permissions. The user needs
-            # to have the view permission for the related model in order to
-            # be able to do anything with the intermediate model.
-            return self.has_view_permission(request, obj)
+            # Delegate permission checks to the target model of the M2M
+            # relation (i.e. the model that isn't the parent of this inline).
+            target_opts = self._get_m2m_target_opts()
+            change_perm = '%s.%s' % (
+                target_opts.app_label,
+                get_permission_codename('change', target_opts),
+            )
+            return request.user.has_perm(change_perm)
         return super().has_add_permission(request)
 
+
+
     def has_change_permission(self, request, obj=None):
         if self.opts.auto_created:
-            # We're checking the rights to an auto-created intermediate model,
-            # which doesn't have its own individual permissions. The user needs
-            # to have the view permission for the related model in order to
-            # be able to do anything with the intermediate model.
-            return self.has_view_permission(request, obj)
-        return super().has_change_permission(request)
+            # Allow changes only if the user can change the target model of the
+            # many‑to‑many relation.
+            target_opts = self._get_m2m_target_opts()
+            change_perm = '%s.%s' % (
+                target_opts.app_label,
+                get_permission_codename('change', target_opts),
+            )
+            return request.user.has_perm(change_perm)
+        return super().has_change_permission(request, obj)
+
+
 
     def has_delete_permission(self, request, obj=None):
         if self.opts.auto_created:
-            # We're checking the rights to an auto-created intermediate model,
-            # which doesn't have its own individual permissions. The user needs
-            # to have the view permission for the related model in order to
-            # be able to do anything with the intermediate model.
-            return self.has_view_permission(request, obj)
+            # Allow deletions only if the user can change the target model of
+            # the many‑to‑many relation.
+            target_opts = self._get_m2m_target_opts()
+            change_perm = '%s.%s' % (
+                target_opts.app_label,
+                get_permission_codename('change', target_opts),
+            )
+            return request.user.has_perm(change_perm)
         return super().has_delete_permission(request, obj)
 
+
+
     def has_view_permission(self, request, obj=None):
         if self.opts.auto_created:
             opts = self.opts
@@ -2159,4 +2193,4 @@ class StackedInline(InlineModelAdmin):
 
 
 class TabularInline(InlineModelAdmin):
-    template = 'admin/edit_inline/tabular.html'
+    template = 'admin/edit_inline/tabular.html'
diff --git a/django/contrib/admin/views/main.py b/django/contrib/admin/views/main.py
index 7d8d33d9d7..4dc481066a 100644
--- a/django/contrib/admin/views/main.py
+++ b/django/contrib/admin/views/main.py
@@ -475,4 +475,4 @@ class ChangeList:
         return reverse('admin:%s_%s_change' % (self.opts.app_label,
                                                self.opts.model_name),
                        args=(quote(pk),),
-                       current_app=self.model_admin.admin_site.name)
+                       current_app=self.model_admin.admin_site.name)
diff --git a/django/contrib/auth/backends.py b/django/contrib/auth/backends.py
index 7549d71273..822125acc2 100644
--- a/django/contrib/auth/backends.py
+++ b/django/contrib/auth/backends.py
@@ -185,4 +185,4 @@ class RemoteUserBackend(ModelBackend):
 
 class AllowAllUsersRemoteUserBackend(RemoteUserBackend):
     def user_can_authenticate(self, user):
-        return True
+        return True
diff --git a/django/contrib/auth/models.py b/django/contrib/auth/models.py
index 324faa6f3e..6d24348dcf 100644
--- a/django/contrib/auth/models.py
+++ b/django/contrib/auth/models.py
@@ -427,4 +427,4 @@ class AnonymousUser:
         return False
 
     def get_username(self):
-        return self.username
+        return self.username
