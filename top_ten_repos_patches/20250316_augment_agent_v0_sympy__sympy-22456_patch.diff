diff --git a/sympy/codegen/ast.py b/sympy/codegen/ast.py
index a02714b174..6d57839078 100644
--- a/sympy/codegen/ast.py
+++ b/sympy/codegen/ast.py
@@ -893,21 +893,47 @@ class String(Token):
     >>> print(repr(f))
     String('foo')
 
     """
     __slots__ = ('text',)
-    not_in_args = ['text']
+    not_in_args = []
     is_Atom = True
 
     @classmethod
     def _construct_text(cls, text):
         if not isinstance(text, str):
             raise TypeError("Argument text is not a string type.")
         return text
 
     def _sympystr(self, printer, *args, **kwargs):
         return self.text
+        
+    def __eq__(self, other):
+        if type(self) == type(other):
+            return self.text == other.text
+        return NotImplemented
+        
+    def __hash__(self):
+        return hash((self.__class__.__name__, self.text))
+        
+    @property
+    def args(self):
+        return (self.text,)
+        
+    def atoms(self, *types):
+        if types:
+            if any(isinstance(self, t) for t in types):
+                return {self}
+            return set()
+        return {self}
+        
+    def match(self, pattern, old=False):
+        if isinstance(pattern, String):
+            if self.text == pattern.text:
+                return {}
+            return None
+        return super().match(pattern, old)
 
 
 class QuotedString(String):
     """ Represents a string which should be printed with quotes. """
 
@@ -1856,8 +1882,34 @@ class FunctionCall(Token, Expr):
     >>> print(pycode(fcall))
     foo(bar, baz)
 
     """
     __slots__ = ('name', 'function_args')
+    
+    def atoms(self, *types):
+        result = set()
+        if not types or any(isinstance(self, t) for t in types):
+            if not types:
+                if isinstance(self.name, str):
+                    result.add(String(self.name))
+                elif hasattr(self.name, 'atoms'):
+                    result.update(self.name.atoms())
+                    
+                for arg in self.function_args:
+                    if hasattr(arg, 'atoms'):
+                        result.update(arg.atoms())
+        else:
+            if isinstance(self.name, str):
+                name_obj = String(self.name)
+                if any(isinstance(name_obj, t) for t in types):
+                    result.add(name_obj)
+            elif hasattr(self.name, 'atoms'):
+                result.update(self.name.atoms(*types))
+                
+            for arg in self.function_args:
+                if hasattr(arg, 'atoms'):
+                    result.update(arg.atoms(*types))
+                
+        return result
 
     _construct_name = String
     _construct_function_args = staticmethod(lambda args: Tuple(*args))
