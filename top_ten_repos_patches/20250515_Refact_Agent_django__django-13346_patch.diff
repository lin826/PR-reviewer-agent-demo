diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py
index fafc1beee8..2d88cdbb3c 100644
--- a/django/db/models/fields/json.py
+++ b/django/db/models/fields/json.py
@@ -455,6 +455,38 @@ class KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, look
     pass
 
 
+class KeyTransformIn(lookups.In):
+    """
+    JSON-aware __in lookup for key transforms.
+
+    PostgreSQL has a native jsonb type so the generic In works there.
+    For the other back-ends build an OR-chain of KeyTransformExact
+    comparisons â€“ this reuses the already correct JSON wrapping logic.
+    """
+
+    def as_sql(self, compiler, connection):
+        if connection.features.has_native_json_field or not self.rhs_is_direct_value():
+            return super().as_sql(compiler, connection)
+
+        # The values the generic In prepared are JSON-dumps() strings already;
+        # decode them so KeyTransformExact doesn't double-quote strings.
+        def py(v):
+            try:
+                return json.loads(v) if isinstance(v, str) else v
+            except ValueError:
+                return v
+
+        conditions, params = [], []
+        for value in (py(v) for v in self.rhs):
+            cond_sql, cond_params = KeyTransformExact(self.lhs, value).as_sql(
+                compiler, connection
+            )
+            conditions.append(cond_sql)
+            params.extend(cond_params)
+
+        return '(' + ' OR '.join(conditions) + ')', params
+
+
 class KeyTransformNumericLookupMixin:
     def process_rhs(self, compiler, connection):
         rhs, rhs_params = super().process_rhs(compiler, connection)
@@ -489,6 +521,7 @@ KeyTransform.register_lookup(KeyTransformEndsWith)
 KeyTransform.register_lookup(KeyTransformIEndsWith)
 KeyTransform.register_lookup(KeyTransformRegex)
 KeyTransform.register_lookup(KeyTransformIRegex)
+KeyTransform.register_lookup(KeyTransformIn)
 
 KeyTransform.register_lookup(KeyTransformLt)
 KeyTransform.register_lookup(KeyTransformLte)
