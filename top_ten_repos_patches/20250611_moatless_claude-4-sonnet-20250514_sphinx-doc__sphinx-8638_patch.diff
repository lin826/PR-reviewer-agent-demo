--- a/sphinx/domains/python.py
+++ b/sphinx/domains/python.py
@@ -1155,11 +1155,45 @@
                     elif name in self.objects and self.objects[name].objtype in objtypes:
                         newname = name
                     else:
-                        # "fuzzy" searching mode
+                        # "fuzzy" searching mode with context-aware prioritization
                         searchname = '.' + name
-                        matches = [(oname, self.objects[oname]) for oname in self.objects
-                                   if oname.endswith(searchname) and
-                                   self.objects[oname].objtype in objtypes]
+                        fuzzy_matches = [(oname, self.objects[oname]) for oname in self.objects
+                                       if oname.endswith(searchname) and
+                                       self.objects[oname].objtype in objtypes]
+                        
+                        if fuzzy_matches:
+                            # Prioritize matches based on context proximity
+                            def get_priority(match_name: str) -> int:
+                                """Get priority for fuzzy match based on context.
+                                Lower numbers = higher priority."""
+                                # Exact match in current class context
+                                if modname and classname and match_name == f"{modname}.{classname}.{name}":
+                                    return 0
+                                # Match in current class (different attribute)
+                                elif modname and classname and match_name.startswith(f"{modname}.{classname}."):
+                                    return 1
+                                # Match in current module
+                                elif modname and match_name.startswith(f"{modname}."):
+                                    return 2
+                                # Match in same module tree (shared prefix)
+                                elif modname:
+                                    # Compare module prefixes to find shared ancestry
+                                    mod_parts = modname.split('.')
+                                    match_parts = match_name.split('.')
+                                    shared_depth = 0
+                                    for i, (mod_part, match_part) in enumerate(zip(mod_parts, match_parts)):
+                                        if mod_part == match_part:
+                                            shared_depth = i + 1
+                                        else:
+                                            break
+                                    return 3 + (len(mod_parts) - shared_depth)
+                                else:
+                                    # No context, use original order
+                                    return 10
+                            
+                            # Sort by priority, then by name for deterministic results
+                            fuzzy_matches.sort(key=lambda x: (get_priority(x[0]), x[0]))
+                            matches = fuzzy_matches
         else:
             # NOTE: searching for exact match, object type is not considered
             if name in self.objects:
