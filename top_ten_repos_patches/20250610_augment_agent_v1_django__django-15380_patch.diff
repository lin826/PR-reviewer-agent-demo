diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py
index bf9c2acd26..817babb6e7 100644
--- a/django/db/migrations/autodetector.py
+++ b/django/db/migrations/autodetector.py
@@ -819,19 +819,85 @@ class MigrationAutodetector:
             )
 
     def generate_renamed_fields(self):
         """Work out renamed fields."""
         self.renamed_fields = {}
+        
+        # Track fields that have been renamed to avoid processing them as add/remove
+        self.renamed_field_keys = set()
+        
+        # Handle field renames in renamed models separately
+        for (app_label, new_model_name), old_model_name in self.renamed_models.items():
+            old_model_state = self.from_state.models[app_label, old_model_name]
+            new_model_state = self.to_state.models[app_label, new_model_name]
+            
+            # Find fields that exist in new model but not old model
+            old_field_names = set(old_model_state.fields.keys())
+            new_field_names = set(new_model_state.fields.keys())
+            
+            for new_field_name in new_field_names - old_field_names:
+                new_field = new_model_state.get_field(new_field_name)
+                new_field_dec = self.deep_deconstruct(new_field)
+                
+                # Check if this new field matches any old field (potential rename)
+                for old_field_name in old_field_names - new_field_names:
+                    old_field = old_model_state.get_field(old_field_name)
+                    old_field_dec = self.deep_deconstruct(old_field)
+                    
+                    # Handle remote field model references for renamed models
+                    if new_field.remote_field and new_field.remote_field.model and 'to' in old_field_dec[2]:
+                        old_rel_to = old_field_dec[2]['to']
+                        if old_rel_to in self.renamed_models_rel:
+                            old_field_dec[2]['to'] = self.renamed_models_rel[old_rel_to]
+                    
+                    old_field.set_attributes_from_name(old_field_name)
+                    old_db_column = old_field.get_attname_column()[1]
+                    
+                    if (old_field_dec == new_field_dec or (
+                            # Was the field renamed and db_column equal to the
+                            # old field's column added?
+                            old_field_dec[0:2] == new_field_dec[0:2] and
+                            dict(old_field_dec[2], db_column=old_db_column) == new_field_dec[2])):
+                        if self.questioner.ask_rename(new_model_name, old_field_name, new_field_name, new_field):
+                            # A db_column mismatch requires a prior noop
+                            # AlterField for the subsequent RenameField to be a
+                            # noop on attempts at preserving the old name.
+                            if old_field.db_column != new_field.db_column:
+                                altered_field = new_field.clone()
+                                altered_field.name = old_field_name
+                                self.add_operation(
+                                    app_label,
+                                    operations.AlterField(
+                                        model_name=new_model_name,
+                                        name=old_field_name,
+                                        field=altered_field,
+                                    ),
+                                )
+                            self.add_operation(
+                                app_label,
+                                operations.RenameField(
+                                    model_name=new_model_name,
+                                    old_name=old_field_name,
+                                    new_name=new_field_name,
+                                )
+                            )
+                            self.renamed_fields[app_label, new_model_name, new_field_name] = old_field_name
+                            # Track these fields to avoid processing them as add/remove
+                            self.renamed_field_keys.add((app_label, new_model_name, old_field_name))
+                            self.renamed_field_keys.add((app_label, new_model_name, new_field_name))
+                            break
+        
+        # Handle field renames in non-renamed models (original logic)
         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):
             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
             old_model_state = self.from_state.models[app_label, old_model_name]
-            new_model_state = self.to_state.models[app_label, old_model_name]
+            new_model_state = self.to_state.models[app_label, model_name]
             field = new_model_state.get_field(field_name)
             # Scan to see if this is actually a rename!
             field_dec = self.deep_deconstruct(field)
             for rem_app_label, rem_model_name, rem_field_name in sorted(self.old_field_keys - self.new_field_keys):
-                if rem_app_label == app_label and rem_model_name == model_name:
+                if rem_app_label == app_label and rem_model_name == old_model_name:
                     old_field = old_model_state.get_field(rem_field_name)
                     old_field_dec = self.deep_deconstruct(old_field)
                     if field.remote_field and field.remote_field.model and 'to' in old_field_dec[2]:
                         old_rel_to = old_field_dec[2]['to']
                         if old_rel_to in self.renamed_models_rel:
@@ -872,11 +938,13 @@ class MigrationAutodetector:
                             break
 
     def generate_added_fields(self):
         """Make AddField operations."""
         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):
-            self._generate_added_field(app_label, model_name, field_name)
+            # Skip fields that have been renamed
+            if (app_label, model_name, field_name) not in getattr(self, 'renamed_field_keys', set()):
+                self._generate_added_field(app_label, model_name, field_name)
 
     def _generate_added_field(self, app_label, model_name, field_name):
         field = self.to_state.models[app_label, model_name].get_field(field_name)
         # Fields that are foreignkeys/m2ms depend on stuff
         dependencies = []
@@ -916,11 +984,13 @@ class MigrationAutodetector:
         )
 
     def generate_removed_fields(self):
         """Make RemoveField operations."""
         for app_label, model_name, field_name in sorted(self.old_field_keys - self.new_field_keys):
-            self._generate_removed_field(app_label, model_name, field_name)
+            # Skip fields that have been renamed
+            if (app_label, model_name, field_name) not in getattr(self, 'renamed_field_keys', set()):
+                self._generate_removed_field(app_label, model_name, field_name)
 
     def _generate_removed_field(self, app_label, model_name, field_name):
         self.add_operation(
             app_label,
             operations.RemoveField(
diff --git a/tests/migrations/test_autodetector.py b/tests/migrations/test_autodetector.py
index bb37af24e3..b469a2bacf 100644
--- a/tests/migrations/test_autodetector.py
+++ b/tests/migrations/test_autodetector.py
@@ -1156,10 +1156,36 @@ class AutodetectorTests(TestCase):
         changes = self.get_changes(before, after, MigrationQuestioner({"ask_rename_model": True}))
         self.assertNumberMigrations(changes, "testapp", 1)
         self.assertOperationTypes(changes, "testapp", 0, ["RenameModel"])
         self.assertOperationAttributes(changes, "testapp", 0, 0, old_name="EntityB", new_name="RenamedEntityB")
 
+    def test_rename_model_and_field(self):
+        """
+        Tests autodetection of renamed models while simultaneously renaming
+        a field on the same model. Regression test for #15380.
+        """
+        before = [
+            ModelState("testapp", "Author", [
+                ("id", models.AutoField(primary_key=True)),
+                ("old_field", models.CharField(max_length=255)),
+            ]),
+        ]
+        after = [
+            ModelState("testapp", "Writer", [
+                ("id", models.AutoField(primary_key=True)),
+                ("new_field", models.CharField(max_length=255)),
+            ]),
+        ]
+        changes = self.get_changes(
+            before, after, 
+            MigrationQuestioner({"ask_rename_model": True, "ask_rename": True})
+        )
+        self.assertNumberMigrations(changes, "testapp", 1)
+        self.assertOperationTypes(changes, "testapp", 0, ["RenameModel", "RenameField"])
+        self.assertOperationAttributes(changes, "testapp", 0, 0, old_name="Author", new_name="Writer")
+        self.assertOperationAttributes(changes, "testapp", 0, 1, old_name="old_field", new_name="new_field")
+
     def test_rename_model_reverse_relation_dependencies(self):
         """
         The migration to rename a model pointed to by a foreign key in another
         app must run after the other app's migration that adds the foreign key
         with model's original name. Therefore, the renaming migration has a
