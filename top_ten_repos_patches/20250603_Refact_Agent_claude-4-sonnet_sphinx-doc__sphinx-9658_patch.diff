diff --git a/sphinx/util/typing.py b/sphinx/util/typing.py
index 87707d48f..196a6745c 100644
--- a/sphinx/util/typing.py
+++ b/sphinx/util/typing.py
@@ -117,6 +117,19 @@ def restify(cls: Optional[Type]) -> str:
             return cls
         elif cls in INVALID_BUILTIN_CLASSES:
             return ':py:class:`%s`' % INVALID_BUILTIN_CLASSES[cls]
+        elif hasattr(cls, '__sphinx_mock__'):
+            # Handle mocked objects by using their __display_name__
+            display_name = getattr(cls, '__display_name__', None)
+            if display_name and '.' in display_name:
+                return ':py:class:`%s`' % display_name
+            else:
+                # Fallback to module.name if display_name is not available or malformed
+                module = getattr(cls, '__module__', '')
+                name = getattr(cls, '__name__', repr(cls))
+                if module and hasattr(cls, '__name__'):
+                    return ':py:class:`%s.%s`' % (module, name)
+                else:
+                    return ':py:class:`%s`' % (display_name or repr(cls))
         elif inspect.isNewType(cls):
             if sys.version_info > (3, 10):
                 # newtypes have correct module info since Python 3.10+
diff --git a/tests/test_util_typing.py b/tests/test_util_typing.py
index d493a0040..69dbf9bf1 100644
--- a/tests/test_util_typing.py
+++ b/tests/test_util_typing.py
@@ -18,6 +18,7 @@ from typing import (Any, Callable, Dict, Generator, List, NewType, Optional, Tup
 import pytest
 
 from sphinx.util.typing import restify, stringify
+from sphinx.ext.autodoc.mock import _make_subclass
 
 
 class MyClass1:
@@ -294,3 +295,29 @@ def test_stringify_type_union_operator():
 
 def test_stringify_broken_type_hints():
     assert stringify(BrokenType) == 'tests.test_util_typing.BrokenType'
+
+
+def test_restify_mock_objects():
+    """Test that restify correctly handles mocked objects."""
+    # Test case 1: Standard torch.nn.Module case
+    torch_nn_module = _make_subclass('Module', 'torch.nn')()
+    result = restify(torch_nn_module)
+    assert result == ':py:class:`torch.nn.Module`'
+    
+    # Test case 2: Different module structure
+    sklearn_base = _make_subclass('BaseEstimator', 'sklearn.base')()
+    result = restify(sklearn_base)
+    assert result == ':py:class:`sklearn.base.BaseEstimator`'
+    
+    # Test case 3: Single level module
+    simple_mock = _make_subclass('SomeClass', 'mymodule')()
+    result = restify(simple_mock)
+    assert result == ':py:class:`mymodule.SomeClass`'
+    
+    # Test case 4: Class inheritance from mock (the actual use case)
+    class DeepKernel(torch_nn_module):
+        pass
+    
+    # When documenting inheritance, restify is called on the base class
+    base_result = restify(DeepKernel.__bases__[0])
+    assert base_result == ':py:class:`torch.nn.Module`'
