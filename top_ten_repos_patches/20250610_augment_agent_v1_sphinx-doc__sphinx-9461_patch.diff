diff --git b/sphinx/ext/autodoc/__init__.py a/sphinx/ext/autodoc/__init__.py
index fb6888d3c..1cecb1f79 100644
--- b/sphinx/ext/autodoc/__init__.py
+++ a/sphinx/ext/autodoc/__init__.py
@@ -716,11 +716,11 @@ class Documenter:
                 isattr = True
             else:
                 isattr = False
 
             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,
-                         self.object, membername)
+                         self.parent, self.object_name)
             if not isinstance(doc, str):
                 # Ignore non-string __doc__
                 doc = None
 
             # if the member __doc__ is the same as self's __doc__, it's just
@@ -2659,74 +2659,28 @@ class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  #
     priority = AttributeDocumenter.priority + 1
 
     @classmethod
     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
                             ) -> bool:
-        if inspect.isproperty(member) and isinstance(parent, ClassDocumenter):
-            return True
-        
-        # Check for @classmethod @property combinations
-        if isinstance(parent, ClassDocumenter):
-            # Look in the class __dict__ for the original definition
-            class_dict = safe_getattr(parent.object, '__dict__', {})
-            if membername in class_dict:
-                dict_value = class_dict[membername]
-                # Check if it's a classmethod wrapping a property
-                if (isinstance(dict_value, classmethod) and 
-                    isinstance(dict_value.__func__, property)):
-                    return True
-        
-        return False
+        return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)
 
     def document_members(self, all_members: bool = False) -> None:
         pass
-    
-    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:
-        """Get the docstring, handling @classmethod @property combinations."""
-        # Check if this is a @classmethod @property combination
-        if self.parent and hasattr(self.parent, 'object'):
-            class_dict = safe_getattr(self.parent.object, '__dict__', {})
-            if self.object_name in class_dict:
-                dict_value = class_dict[self.object_name]
-                if (isinstance(dict_value, classmethod) and 
-                    isinstance(dict_value.__func__, property)):
-                    # Extract docstring from the original function
-                    prop = dict_value.__func__
-                    if prop.fget and hasattr(prop.fget, '__doc__'):
-                        docstring = prop.fget.__doc__
-                        if docstring:
-                            tab_width = self.directive.state.document.settings.tab_width
-                            return [prepare_docstring(docstring, ignore, tab_width)]
-                        return []
-        
-        # Fall back to default behavior for regular properties
-        return super().get_doc(ignore)
 
     def get_real_modname(self) -> str:
         real_modname = self.get_attr(self.parent or self.object, '__module__', None)
         return real_modname or self.modname
 
     def add_directive_header(self, sig: str) -> None:
         super().add_directive_header(sig)
         sourcename = self.get_sourcename()
-        
-        # Get the actual property object for @classmethod @property combinations
-        prop_obj = self.object
-        if self.parent and hasattr(self.parent, 'object'):
-            class_dict = safe_getattr(self.parent.object, '__dict__', {})
-            if self.object_name in class_dict:
-                dict_value = class_dict[self.object_name]
-                if (isinstance(dict_value, classmethod) and 
-                    isinstance(dict_value.__func__, property)):
-                    prop_obj = dict_value.__func__
-        
-        if inspect.isabstractmethod(prop_obj):
+        if inspect.isabstractmethod(self.object):
             self.add_line('   :abstractmethod:', sourcename)
 
-        if safe_getattr(prop_obj, 'fget', None) and self.config.autodoc_typehints != 'none':
+        if safe_getattr(self.object, 'fget', None) and self.config.autodoc_typehints != 'none':
             try:
-                signature = inspect.signature(prop_obj.fget,
+                signature = inspect.signature(self.object.fget,
                                               type_aliases=self.config.autodoc_type_aliases)
                 if signature.return_annotation is not Parameter.empty:
                     objrepr = stringify_typehint(signature.return_annotation)
                     self.add_line('   :type: ' + objrepr, sourcename)
             except TypeError as exc:
diff --git b/sphinx/util/inspect.py a/sphinx/util/inspect.py
index 0e66dc329..23dd9e930 100644
--- b/sphinx/util/inspect.py
+++ a/sphinx/util/inspect.py
@@ -834,30 +834,15 @@ def getdoc(obj: Any, attrgetter: Callable = safe_getattr,
     This tries to obtain the docstring for some kind of objects additionally:
 
     * partial functions
     * inherited docstring
     * inherited decorated methods
-    * @classmethod @property combinations
     """
     doc = attrgetter(obj, '__doc__', None)
     if ispartial(obj) and doc == obj.__class__.__doc__:
         return getdoc(obj.func)
-    elif cls and name:
-        # Check for @classmethod @property combinations
-        class_dict = safe_getattr(cls, '__dict__', {})
-        if name in class_dict:
-            dict_value = class_dict[name]
-            if (isinstance(dict_value, classmethod) and 
-                isinstance(dict_value.__func__, property)):
-                # Extract docstring from the original function
-                prop = dict_value.__func__
-                if prop.fget and hasattr(prop.fget, '__doc__'):
-                    prop_doc = prop.fget.__doc__
-                    if prop_doc:
-                        return prop_doc
-    
-    if doc is None and allow_inherited:
+    elif doc is None and allow_inherited:
         if cls and name:
             # Check a docstring of the attribute or method from super classes.
             for basecls in getmro(cls):
                 meth = safe_getattr(basecls, name, None)
                 if meth is not None:
