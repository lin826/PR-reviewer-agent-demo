diff --git a/sympy/printing/python.py b/sympy/printing/python.py
index dc6d8ffe59..ab6a196715 100644
--- a/sympy/printing/python.py
+++ b/sympy/printing/python.py
@@ -34,6 +34,7 @@ def _print_Function(self, expr):
             self.functions.append(func)
         return StrPrinter._print_Function(self, expr)
 
+
     # procedure (!) for defining symbols which have be defined in print_python()
     def _print_Symbol(self, expr):
         symbol = self._str(expr)
@@ -41,6 +42,26 @@ def _print_Symbol(self, expr):
             self.symbols.append(symbol)
         return StrPrinter._print_Symbol(self, expr)
 
+    def _print_Relational(self, expr):
+        # Keep the original, symbol-agnostic behaviour so that python()
+        # does not generate Symbol(...) declarations for relational operands.
+        charmap = {
+            "==": "Eq",
+            "!=": "Ne",
+            ":=": "Assignment",
+            "+=": "AddAugmentedAssignment",
+            "-=": "SubAugmentedAssignment",
+            "*=": "MulAugmentedAssignment",
+            "/=": "DivAugmentedAssignment",
+            "%=": "ModAugmentedAssignment",
+        }
+        if expr.rel_op in charmap:
+            return "%s(%s, %s)" % (charmap[expr.rel_op], expr.lhs, expr.rhs)
+        # For the remaining relational operators fall back to the generic
+        # StrPrinter version (which is unaffected by symbol collection).
+        return StrPrinter._print_Relational(self, expr)
+
+
     def _print_module(self, expr):
         raise ValueError('Modules in the expression are unacceptable')
 
diff --git a/sympy/printing/str.py b/sympy/printing/str.py
index cc1d19fcce..97c6e70624 100644
--- a/sympy/printing/str.py
+++ b/sympy/printing/str.py
@@ -189,11 +189,15 @@ def _print_Interval(self, i):
             m = ''
         elif l and r:
             m = '.open'
+
         elif l:
             m = '.Lopen'
         else:
             m = '.Ropen'
-        return fin.format(**{'a': a, 'b': b, 'm': m})
+        return fin.format(**{'a': self._print(a),
+                             'b': self._print(b),
+                             'm': m})
+
 
     def _print_AccumulationBounds(self, i):
         return "AccumBounds(%s, %s)" % (self._print(i.min), self._print(i.max))
@@ -215,10 +219,12 @@ def _print_LatticeOp(self, expr):
 
     def _print_Limit(self, expr):
         e, z, z0, dir = expr.args
+
         if str(dir) == "+":
-            return "Limit(%s, %s, %s)" % (e, z, z0)
+            return "Limit(%s, %s, %s)" % (self._print(e), self._print(z), self._print(z0))
         else:
-            return "Limit(%s, %s, %s, dir='%s')" % (e, z, z0, dir)
+            return "Limit(%s, %s, %s, dir='%s')" % (self._print(e), self._print(z), self._print(z0), dir)
+
 
     def _print_list(self, expr):
         return "[%s]" % self.stringify(expr, ", ")
@@ -629,8 +635,12 @@ def _print_Relational(self, expr):
             "%=": "ModAugmentedAssignment",
         }
 
+
         if expr.rel_op in charmap:
-            return '%s(%s, %s)' % (charmap[expr.rel_op], expr.lhs, expr.rhs)
+            return '%s(%s, %s)' % (charmap[expr.rel_op],
+                                   self._print(expr.lhs),
+                                   self._print(expr.rhs))
+
 
         return '%s %s %s' % (self.parenthesize(expr.lhs, precedence(expr)),
                            self._relationals.get(expr.rel_op) or expr.rel_op,
@@ -845,4 +855,4 @@ def sstrrepr(expr, **settings):
     p = StrReprPrinter(settings)
     s = p.doprint(expr)
 
-    return s
+    return s
