diff --git a/sklearn/ensemble/_iforest.py b/sklearn/ensemble/_iforest.py
index 4d6c1c3f0..137dbcdca 100644
--- a/sklearn/ensemble/_iforest.py
+++ b/sklearn/ensemble/_iforest.py
@@ -343,11 +343,13 @@ class IsolationForest(OutlierMixin, BaseBagging):
             # we take the opposite as we consider the opposite of their score.
             self.offset_ = -0.5
             return self
 
         # else, define offset_ wrt contamination parameter
-        self.offset_ = np.percentile(self.score_samples(X), 100.0 * self.contamination)
+        # Use _score_samples_no_validation to avoid feature name validation
+        # during fit, since X has already been validated in fit()
+        self.offset_ = np.percentile(self._score_samples_no_validation(X), 100.0 * self.contamination)
 
         return self
 
     def predict(self, X):
         """
@@ -437,10 +439,34 @@ class IsolationForest(OutlierMixin, BaseBagging):
 
         # Take the opposite of the scores as bigger is better (here less
         # abnormal)
         return -self._compute_chunked_score_samples(X)
 
+    def _score_samples_no_validation(self, X):
+        """
+        Compute anomaly scores without input validation.
+        
+        This method is used internally during fit() to avoid feature name
+        validation issues when X has already been validated.
+        
+        Parameters
+        ----------
+        X : {array-like, sparse matrix} of shape (n_samples, n_features)
+            The input samples. Must already be validated.
+            
+        Returns
+        -------
+        scores : ndarray of shape (n_samples,)
+            The anomaly score of the input samples.
+            The lower, the more abnormal.
+        """
+        check_is_fitted(self)
+        
+        # Take the opposite of the scores as bigger is better (here less
+        # abnormal)
+        return -self._compute_chunked_score_samples(X)
+
     def _compute_chunked_score_samples(self, X):
         n_samples = _num_samples(X)
 
         if self._max_features == X.shape[1]:
             subsample_features = False
