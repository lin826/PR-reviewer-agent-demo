diff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py
index 800a25c92..07c35b11e 100644
--- a/src/_pytest/mark/structures.py
+++ b/src/_pytest/mark/structures.py
@@ -355,13 +355,28 @@ class MarkDecorator:
         return self.with_args(*args, **kwargs)
 
 
 def get_unpacked_marks(obj: object) -> Iterable[Mark]:
     """Obtain the unpacked marks that are stored on an object."""
-    mark_list = getattr(obj, "pytestmark", [])
-    if not isinstance(mark_list, list):
-        mark_list = [mark_list]
+    mark_list = []
+    
+    # For classes, we need to consider the entire MRO to collect marks from all base classes
+    if inspect.isclass(obj):
+        # Iterate through the MRO and collect pytestmark from each class
+        for cls in obj.__mro__:
+            # Use __dict__ to get marks directly from each class, avoiding MRO resolution
+            if "pytestmark" in cls.__dict__:
+                cls_marks = cls.__dict__["pytestmark"]
+                if not isinstance(cls_marks, list):
+                    cls_marks = [cls_marks]
+                mark_list.extend(cls_marks)
+    else:
+        # For non-class objects (functions, methods, etc.), use the original behavior
+        mark_list = getattr(obj, "pytestmark", [])
+        if not isinstance(mark_list, list):
+            mark_list = [mark_list]
+    
     return normalize_mark_list(mark_list)
 
 
 def normalize_mark_list(
     mark_list: Iterable[Union[Mark, MarkDecorator]]
@@ -378,19 +393,28 @@ def normalize_mark_list(
         if not isinstance(mark_obj, Mark):
             raise TypeError(f"got {repr(mark_obj)} instead of Mark")
         yield mark_obj
 
 
+def _get_direct_marks(obj: object) -> Iterable[Mark]:
+    """Get marks directly stored on an object, without considering MRO."""
+    mark_list = getattr(obj, "pytestmark", [])
+    if not isinstance(mark_list, list):
+        mark_list = [mark_list]
+    return normalize_mark_list(mark_list)
+
+
 def store_mark(obj, mark: Mark) -> None:
     """Store a Mark on an object.
 
     This is used to implement the Mark declarations/decorators correctly.
     """
     assert isinstance(mark, Mark), mark
     # Always reassign name to avoid updating pytestmark in a reference that
     # was only borrowed.
-    obj.pytestmark = [*get_unpacked_marks(obj), mark]
+    # Use _get_direct_marks to avoid including inherited marks when storing
+    obj.pytestmark = [*_get_direct_marks(obj), mark]
 
 
 # Typing for builtin pytest marks. This is cheating; it gives builtin marks
 # special privilege, and breaks modularity. But practicality beats purity...
 if TYPE_CHECKING:
